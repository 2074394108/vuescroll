{"version":3,"file":"vuescroll.min.js","sources":["../src/util/index.js","../src/mixins/mode/native-mode.js","../src/third-party/easingPattern/index.js","../src/third-party/scroller/animate.js","../src/third-party/scroller/requestAnimationFrame.js","../src/shared/constants.js","../src/third-party/scroller/index.js","../src/mixins/mode/slide-mode.js","../src/shared/global-config.js","../src/mixins/hack-lifecycle.js","../src/mixins/api.js","../src/third-party/resize-detector/index.js","../src/shared/scroll-map.js","../src/components/child-components/vuescroll-bar.js","../src/components/child-components/vuescroll-panel.js","../src/components/child-components/vuescroll-content.js","../src/components/vuescroll.js","../src/third-party/scroller/render.js","../src/third-party/scroller/listener.js","../src/mixins/computed.js","../src/mixins/event-emitter.js","../src/mixins/event-handler.js","../src/mixins/helper.js","../src/mixins/init.js","../src/mixins/refresh.js","../src/mixins/resize.js","../src/index.js"],"sourcesContent":["import Vue from 'vue';\r\n\r\nexport function deepCopy(source, target) {\r\n  target = (typeof target === 'object' && target) || {};\r\n  for (var key in source) {\r\n    target[key] =\r\n      typeof source[key] === 'object'\r\n        ? deepCopy(source[key], (target[key] = {}))\r\n        : source[key];\r\n  }\r\n  return target;\r\n}\r\n\r\nexport function deepMerge(from, to) {\r\n  to = to || {};\r\n  for (var key in from) {\r\n    if (typeof from[key] === 'object') {\r\n      if (typeof to[key] === 'undefined') {\r\n        to[key] = {};\r\n        deepCopy(from[key], to[key]);\r\n      } else {\r\n        deepMerge(from[key], to[key]);\r\n      }\r\n    } else {\r\n      if (typeof to[key] === 'undefined') to[key] = from[key];\r\n    }\r\n  }\r\n  return to;\r\n}\r\n\r\nexport function defineReactive(target, key, source, souceKey) {\r\n  let getter = null;\r\n  /* istanbul ignore if */\r\n  if (!source[key] && typeof source !== 'function') {\r\n    return;\r\n  }\r\n  souceKey = souceKey || key;\r\n  if (typeof source === 'function') {\r\n    getter = source;\r\n  }\r\n  Object.defineProperty(target, key, {\r\n    get:\r\n      getter ||\r\n      function() {\r\n        return source[souceKey];\r\n      },\r\n    configurable: true\r\n  });\r\n}\r\n\r\nlet scrollBarWidth;\r\n\r\nexport function getGutter() {\r\n  /* istanbul ignore next */\r\n  if (Vue.prototype.$isServer) return 0;\r\n  if (scrollBarWidth !== undefined) return scrollBarWidth;\r\n  const outer = document.createElement('div');\r\n  outer.style.visibility = 'hidden';\r\n  outer.style.width = '100px';\r\n  outer.style.position = 'absolute';\r\n  outer.style.top = '-9999px';\r\n  document.body.appendChild(outer);\r\n\r\n  const widthNoScroll = outer.offsetWidth;\r\n  outer.style.overflow = 'scroll';\r\n  const inner = document.createElement('div');\r\n  inner.style.width = '100%';\r\n  outer.appendChild(inner);\r\n\r\n  const widthWithScroll = inner.offsetWidth;\r\n  outer.parentNode.removeChild(outer);\r\n  scrollBarWidth = widthNoScroll - widthWithScroll;\r\n  return scrollBarWidth;\r\n}\r\n\r\nexport function eventCenter(\r\n  dom,\r\n  eventName,\r\n  hander,\r\n  capture = false,\r\n  type = 'on'\r\n) {\r\n  type == 'on'\r\n    ? dom.addEventListener(eventName, hander, capture)\r\n    : dom.removeEventListener(eventName, hander, capture);\r\n}\r\n\r\nexport const error = msg => {\r\n  console.error(`[vuescroll] ${msg}`);\r\n};\r\nexport const warn = msg => {\r\n  console.warn(`[vuescroll] ${msg}`);\r\n};\r\n\r\nexport function isChildInParent(child, parent) {\r\n  let flag = false;\r\n  if (!child || !parent) {\r\n    return flag;\r\n  }\r\n  while (\r\n    child.parentNode !== parent &&\r\n    child.parentNode.nodeType !== 9 &&\r\n    !child.parentNode._isVuescroll\r\n  ) {\r\n    child = child.parentNode;\r\n  }\r\n  if (child.parentNode == parent) {\r\n    flag = true;\r\n  }\r\n  return flag;\r\n}\r\n\r\nconst pxValueReg = /(.*?)px/;\r\nexport function extractNumberFromPx(value) {\r\n  const _return = pxValueReg.exec(value);\r\n  return _return && _return[1];\r\n}\r\n\r\nexport function isSupportTouch() {\r\n  return 'ontouchstart' in window;\r\n}\r\n\r\nexport function getPrefix(global) {\r\n  var docStyle = document.documentElement.style;\r\n  var engine;\r\n  /* istanbul ignore if */\r\n  if (\r\n    global.opera &&\r\n    Object.prototype.toString.call(opera) === '[object Opera]'\r\n  ) {\r\n    engine = 'presto';\r\n  } /* istanbul ignore next */ else if ('MozAppearance' in docStyle) {\r\n    engine = 'gecko';\r\n  } else if ('WebkitAppearance' in docStyle) {\r\n    engine = 'webkit';\r\n  } /* istanbul ignore next */ else if (\r\n    typeof navigator.cpuClass === 'string'\r\n  ) {\r\n    engine = 'trident';\r\n  }\r\n  var vendorPrefix = {\r\n    trident: 'ms',\r\n    gecko: 'moz',\r\n    webkit: 'webkit',\r\n    presto: 'O'\r\n  }[engine];\r\n  return vendorPrefix;\r\n}\r\n\r\nexport function isSupportGivenStyle(property, value) {\r\n  const compatibleValue = `-${getPrefix(window)}-${value}`;\r\n  const testElm = document.createElement('div');\r\n  testElm.style[property] = compatibleValue;\r\n  if (testElm.style[property] == compatibleValue) {\r\n    return compatibleValue;\r\n  }\r\n  /* istanbul ignore next */\r\n  return false;\r\n}\r\n\r\nexport function isIE() /* istanbul ignore next */ {\r\n  var agent = navigator.userAgent.toLowerCase();\r\n  return (\r\n    agent.indexOf('msie') !== -1 ||\r\n    agent.indexOf('trident') !== -1 ||\r\n    agent.indexOf(' edge/') !== -1\r\n  );\r\n}\r\n\r\nexport function insertChildrenIntoSlot(h, parentVnode, childVNode, data) {\r\n  parentVnode = parentVnode[0] ? parentVnode[0] : parentVnode;\r\n  const tag =\r\n    (parentVnode.componentOptions && parentVnode.componentOptions.tag) ||\r\n    parentVnode.tag;\r\n  // if (!Array.isArray(childVNode)) {\r\n  //   childVNode = [childVNode];\r\n  // }\r\n\r\n  // // Remove null node\r\n  // for (let index = 0; index < childVNode.length; index++) {\r\n  //   const element = childVNode[index];\r\n  //   if (!element) {\r\n  //     childVNode.splice(index, 1);\r\n  //     index--;\r\n  //   }\r\n  // }\r\n  const _data = parentVnode.componentOptions || parentVnode.data || {};\r\n\r\n  // If component, use `nativeOn` intead.\r\n  if (parentVnode.componentOptions) {\r\n    data.nativeOn = data.on;\r\n    _data.props = _data.propsData;\r\n\r\n    delete data.on;\r\n    delete data.propsData;\r\n  }\r\n\r\n  return h(\r\n    tag,\r\n    {\r\n      ...data,\r\n      ..._data\r\n    },\r\n    childVNode\r\n  );\r\n}\r\n\r\nexport function getRealParent(ctx) {\r\n  let parent = ctx.$parent;\r\n\r\n  if (!parent._isVuescrollRoot && parent) {\r\n    parent = parent.$parent;\r\n  }\r\n\r\n  return parent;\r\n}\r\n","import { extractNumberFromPx } from '../../util';\r\nexport default {\r\n  methods: {\r\n    updateNativeModeBarState() {\r\n      const scrollPanel = this.scrollPanelElm;\r\n      const vuescroll = this.$el;\r\n      const isPercent = this.mergedOptions.vuescroll.sizeStrategy == 'percent';\r\n      const clientWidth = isPercent\r\n        ? vuescroll.clientWidth\r\n        : extractNumberFromPx(this.vuescroll.state.width);\r\n      const clientHeight = isPercent\r\n        ? vuescroll.clientHeight\r\n        : extractNumberFromPx(this.vuescroll.state.height);\r\n      let heightPercentage = (clientHeight * 100) / scrollPanel.scrollHeight;\r\n      let widthPercentage = (clientWidth * 100) / scrollPanel.scrollWidth;\r\n      this.bar.vBar.state.posValue =\r\n        (scrollPanel.scrollTop * 100) / clientHeight;\r\n      this.bar.hBar.state.posValue =\r\n        (scrollPanel.scrollLeft * 100) / clientWidth;\r\n      this.bar.vBar.state.size =\r\n        heightPercentage < 100 ? heightPercentage + '%' : 0;\r\n      this.bar.hBar.state.size =\r\n        widthPercentage < 100 ? widthPercentage + '%' : 0;\r\n    }\r\n  }\r\n};\r\n","/**\r\n *  Compatible to scroller's animation function\r\n */\r\nexport function createEasingFunction(easing, easingPattern) {\r\n  return function(time) {\r\n    return easingPattern(easing, time);\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate the easing pattern\r\n * @link https://github.com/cferdinandi/smooth-scroll/blob/master/src/js/smooth-scroll.js\r\n * modified by wangyi7099\r\n * @param {String} type Easing pattern\r\n * @param {Number} time Time animation should take to complete\r\n * @returns {Number}\r\n */\r\nexport function easingPattern(easing, time) {\r\n  let pattern = null;\r\n  /* istanbul ignore next */\r\n  {\r\n    // Default Easing Patterns\r\n    if (easing === 'easeInQuad') pattern = time * time; // accelerating from zero velocity\r\n    if (easing === 'easeOutQuad') pattern = time * (2 - time); // decelerating to zero velocity\r\n    if (easing === 'easeInOutQuad')\r\n      pattern = time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time; // acceleration until halfway, then deceleration\r\n    if (easing === 'easeInCubic') pattern = time * time * time; // accelerating from zero velocity\r\n    if (easing === 'easeOutCubic') pattern = --time * time * time + 1; // decelerating to zero velocity\r\n    if (easing === 'easeInOutCubic')\r\n      pattern =\r\n        time < 0.5\r\n          ? 4 * time * time * time\r\n          : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1; // acceleration until halfway, then deceleration\r\n    if (easing === 'easeInQuart') pattern = time * time * time * time; // accelerating from zero velocity\r\n    if (easing === 'easeOutQuart') pattern = 1 - --time * time * time * time; // decelerating to zero velocity\r\n    if (easing === 'easeInOutQuart')\r\n      pattern =\r\n        time < 0.5\r\n          ? 8 * time * time * time * time\r\n          : 1 - 8 * --time * time * time * time; // acceleration until halfway, then deceleration\r\n    if (easing === 'easeInQuint') pattern = time * time * time * time * time; // accelerating from zero velocity\r\n    if (easing === 'easeOutQuint')\r\n      pattern = 1 + --time * time * time * time * time; // decelerating to zero velocity\r\n    if (easing === 'easeInOutQuint')\r\n      pattern =\r\n        time < 0.5\r\n          ? 16 * time * time * time * time * time\r\n          : 1 + 16 * --time * time * time * time * time; // acceleration until halfway, then deceleration\r\n  }\r\n  return pattern || time; // no easing, no acceleration\r\n}\r\n","/*\r\n * Scroller\r\n * http://github.com/zynga/scroller\r\n *\r\n * Copyright 2011, Zynga Inc.\r\n * Licensed under the MIT License.\r\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\r\n *\r\n * Based on the work of: Unify Project (unify-project.org)\r\n * http://unify-project.org\r\n * Copyright 2011, Deutsche Telekom AG\r\n * License: MIT + Apache (V2)\r\n */\r\n\r\n/**\r\n * Generic animation class with support for dropped frames both optional easing and duration.\r\n *\r\n * Optional duration is useful when the lifetime is defined by another condition than time\r\n * e.g. speed of an animating object, etc.\r\n *\r\n * Dropped frame logic allows to keep using the same updater logic independent from the actual\r\n * rendering. This eases a lot of cases where it might be pretty complex to break down a state\r\n * based on the pure time difference.\r\n */\r\nimport { requestAnimationFrame } from './requestAnimationFrame';\r\n\r\nvar time =\r\n  Date.now ||\r\n  function() {\r\n    return +new Date();\r\n  };\r\nvar desiredFrames = 60;\r\nvar millisecondsPerSecond = 1000;\r\nvar running = {};\r\nvar counter = 1;\r\n\r\nconst core = { effect: {} };\r\nlet global = null;\r\n\r\nif (typeof window !== 'undefined') {\r\n  global = window;\r\n} else {\r\n  global = {};\r\n}\r\n\r\ncore.effect.Animate = {\r\n  /**\r\n   * A requestAnimationFrame wrapper / polyfill.\r\n   *\r\n   * @param callback {Function} The callback to be invoked before the next repaint.\r\n   * @param root {HTMLElement} The root element for the repaint\r\n   */\r\n  requestAnimationFrame: requestAnimationFrame(global),\r\n  /**\r\n   * Stops the given animation.\r\n   *\r\n   * @param id {Integer} Unique animation ID\r\n   * @return {Boolean} Whether the animation was stopped (aka, was running before)\r\n   */\r\n  stop: function(id) {\r\n    var cleared = running[id] != null;\r\n    if (cleared) {\r\n      running[id] = null;\r\n    }\r\n\r\n    return cleared;\r\n  },\r\n\r\n  /**\r\n   * Whether the given animation is still running.\r\n   *\r\n   * @param id {Integer} Unique animation ID\r\n   * @return {Boolean} Whether the animation is still running\r\n   */\r\n  isRunning: function(id) {\r\n    return running[id] != null;\r\n  },\r\n\r\n  /**\r\n   * Start the animation.\r\n   *\r\n   * @param stepCallback {Function} Pointer to function which is executed on every step.\r\n   *   Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`\r\n   * @param verifyCallback {Function} Executed before every animation step.\r\n   *   Signature of the method should be `function() { return continueWithAnimation; }`\r\n   * @param completedCallback {Function}\r\n   *   Signature of the method should be `function(droppedFrames, finishedAnimation) {}`\r\n   * @param duration {Integer} Milliseconds to run the animation\r\n   * @param easingMethod {Function} Pointer to easing function\r\n   *   Signature of the method should be `function(percent) { return modifiedValue; }`\r\n   * @param root {Element ? document.body} Render root, when available. Used for internal\r\n   *   usage of requestAnimationFrame.\r\n   * @return {Integer} Identifier of animation. Can be used to stop it any time.\r\n   */\r\n  start: function(\r\n    stepCallback,\r\n    verifyCallback,\r\n    completedCallback,\r\n    duration,\r\n    easingMethod,\r\n    root\r\n  ) {\r\n    var start = time();\r\n    var lastFrame = start;\r\n    var percent = 0;\r\n    var dropCounter = 0;\r\n    var id = counter++;\r\n\r\n    if (!root) {\r\n      root = document.body;\r\n    }\r\n\r\n    // Compacting running db automatically every few new animations\r\n    if (id % 20 === 0) {\r\n      var newRunning = {};\r\n      for (var usedId in running) {\r\n        newRunning[usedId] = true;\r\n      }\r\n      running = newRunning;\r\n    }\r\n\r\n    // This is the internal step method which is called every few milliseconds\r\n    var step = function(virtual) {\r\n      // Normalize virtual value\r\n      var render = virtual !== true;\r\n\r\n      // Get current time\r\n      var now = time();\r\n\r\n      // Verification is executed before next animation step\r\n      if (!running[id] || (verifyCallback && !verifyCallback(id))) {\r\n        running[id] = null;\r\n        completedCallback &&\r\n          completedCallback(\r\n            desiredFrames -\r\n              dropCounter / ((now - start) / millisecondsPerSecond),\r\n            id,\r\n            false\r\n          );\r\n        return;\r\n      }\r\n\r\n      // For the current rendering to apply let's update omitted steps in memory.\r\n      // This is important to bring internal state variables up-to-date with progress in time.\r\n      if (render) {\r\n        var droppedFrames =\r\n          Math.round(\r\n            (now - lastFrame) / (millisecondsPerSecond / desiredFrames)\r\n          ) - 1;\r\n        for (var j = 0; j < Math.min(droppedFrames, 4); j++) {\r\n          step(true);\r\n          dropCounter++;\r\n        }\r\n      }\r\n\r\n      // Compute percent value\r\n      if (duration) {\r\n        percent = (now - start) / duration;\r\n        if (percent > 1) {\r\n          percent = 1;\r\n        }\r\n      }\r\n\r\n      // Execute step callback, then...\r\n      var value = easingMethod ? easingMethod(percent) : percent;\r\n      if (\r\n        (stepCallback(value, now, render) === false || percent === 1) &&\r\n        render\r\n      ) {\r\n        running[id] = null;\r\n        completedCallback &&\r\n          completedCallback(\r\n            desiredFrames -\r\n              dropCounter / ((now - start) / millisecondsPerSecond),\r\n            id,\r\n            percent === 1 || duration == null\r\n          );\r\n      } else if (render) {\r\n        lastFrame = now;\r\n        core.effect.Animate.requestAnimationFrame(step, root);\r\n      }\r\n    };\r\n\r\n    // Mark as running\r\n    running[id] = true;\r\n\r\n    // Init first step\r\n    core.effect.Animate.requestAnimationFrame(step, root);\r\n\r\n    // Return unique animation ID\r\n    return id;\r\n  }\r\n};\r\n\r\nexport { core };\r\n","export function requestAnimationFrame(global) {\r\n  // Check for request animation Frame support\r\n  var requestFrame =\r\n    global.requestAnimationFrame ||\r\n    global.webkitRequestAnimationFrame ||\r\n    global.mozRequestAnimationFrame ||\r\n    global.oRequestAnimationFrame;\r\n  var isNative = !!requestFrame;\r\n\r\n  if (\r\n    requestFrame &&\r\n    !/requestAnimationFrame\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}/i.test(\r\n      requestFrame.toString()\r\n    )\r\n  ) {\r\n    isNative = false;\r\n  }\r\n\r\n  if (isNative) {\r\n    return function(callback, root) {\r\n      requestFrame(callback, root);\r\n    };\r\n  }\r\n\r\n  var TARGET_FPS = 60;\r\n  var requests = {};\r\n  var rafHandle = 1;\r\n  var intervalHandle = null;\r\n  var lastActive = +new Date();\r\n\r\n  return function(callback) {\r\n    var callbackHandle = rafHandle++;\r\n\r\n    // Store callback\r\n    requests[callbackHandle] = callback;\r\n    requestCount++;\r\n\r\n    // Create timeout at first request\r\n    if (intervalHandle === null) {\r\n      intervalHandle = setInterval(function() {\r\n        var time = +new Date();\r\n        var currentRequests = requests;\r\n\r\n        // Reset data structure before executing callbacks\r\n        requests = {};\r\n        requestCount = 0;\r\n\r\n        for (var key in currentRequests) {\r\n          if (currentRequests.hasOwnProperty(key)) {\r\n            currentRequests[key](time);\r\n            lastActive = time;\r\n          }\r\n        }\r\n\r\n        // Disable the timeout when nothing happens for a certain\r\n        // period of time\r\n        if (time - lastActive > 2500) {\r\n          clearInterval(intervalHandle);\r\n          intervalHandle = null;\r\n        }\r\n      }, 1000 / TARGET_FPS);\r\n    }\r\n\r\n    return callbackHandle;\r\n  };\r\n}\r\n","// all modes\r\nexport const modes = ['slide', 'native', 'pure-native'];\r\n// do nothing\r\nexport const NOOP = () => {};\r\n// some small changes.\r\nexport const smallChangeArray = [\r\n  'mergedOptions.vuescroll.pullRefresh.tips',\r\n  'mergedOptions.vuescroll.pushLoad.tips',\r\n  'mergedOptions.rail',\r\n  'mergedOptions.bar'\r\n];\r\n","/*\r\n * Scroller\r\n * http://github.com/zynga/scroller\r\n *\r\n * modified by wangyi7099\r\n * \r\n * Copyright 2011, Zynga Inc.\r\n * Licensed under the MIT License.\r\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\r\n *\r\n * Based on the work of: Unify Project (unify-project.org)\r\n * http://unify-project.org\r\n * Copyright 2011, Deutsche Telekom AG\r\n * License: MIT + Apache (V2)\r\n */\r\nimport { easingPattern, createEasingFunction } from '../easingPattern';\r\nimport { core } from './animate';\r\nimport { NOOP } from '../../shared/constants';\r\n\r\nvar animatingMethod = null;\r\n\r\nvar noAnimatingMethod = null;\r\n\r\nexport default function Scroller(callback, options) {\r\n  this.__callback = callback;\r\n\r\n  this.options = {\r\n    /** Enable scrolling on x-axis */\r\n    scrollingX: true,\r\n\r\n    /** Enable scrolling on y-axis */\r\n    scrollingY: true,\r\n\r\n    /** Enable animations for deceleration, snap back, zooming and scrolling */\r\n    animating: true,\r\n\r\n    /** duration for animations triggered by scrollTo/zoomTo */\r\n    animationDuration: 250,\r\n\r\n    /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\r\n    bouncing: true,\r\n\r\n    /** Enable locking to the main axis if user moves only slightly on one of them at start */\r\n    locking: true,\r\n\r\n    /** Enable pagination mode (switching between full page content panes) */\r\n    paging: false,\r\n\r\n    /** Enable snapping of content to a configured pixel grid */\r\n    snapping: false,\r\n\r\n    /** Enable zooming of content via API, fingers and mouse wheel */\r\n    zooming: false,\r\n\r\n    /** Minimum zoom level */\r\n    minZoom: 0.5,\r\n\r\n    /** Maximum zoom level */\r\n    maxZoom: 3,\r\n\r\n    /** Multiply or decrease scrolling speed **/\r\n    speedMultiplier: 1,\r\n\r\n    /** Callback that is fired on the later of touch end or deceleration end,\r\n\t\t\t\tprovided that another scrolling action has not begun. Used to know\r\n\t\t\t\twhen to fade out a scrollbar. */\r\n    scrollingComplete: NOOP,\r\n\r\n    animatingEasing: 'easeOutCubic',\r\n\r\n    noAnimatingEasing: 'easeInOutCubic',\r\n\r\n    /** This configures the amount of change applied to deceleration when reaching boundaries  **/\r\n    penetrationDeceleration: 0.03,\r\n\r\n    /** This configures the amount of change applied to acceleration when reaching boundaries  **/\r\n    penetrationAcceleration: 0.08\r\n  };\r\n\r\n  for (var key in options) {\r\n    this.options[key] = options[key];\r\n  }\r\n\r\n  animatingMethod = createEasingFunction(\r\n    this.options.animatingEasing,\r\n    easingPattern\r\n  );\r\n  noAnimatingMethod = createEasingFunction(\r\n    this.options.noAnimatingEasing,\r\n    easingPattern\r\n  );\r\n}\r\n\r\nvar members = {\r\n  /*\r\n\t---------------------------------------------------------------------------\r\n\t\tINTERNAL FIELDS :: STATUS\r\n\t---------------------------------------------------------------------------\r\n\t*/\r\n\r\n  /** {Boolean} Whether only a single finger is used in touch handling */\r\n  __isSingleTouch: false,\r\n\r\n  /** {Boolean} Whether a touch event sequence is in progress */\r\n  __isTracking: false,\r\n\r\n  /** {Boolean} Whether a deceleration animation went to completion. */\r\n  __didDecelerationComplete: false,\r\n\r\n  /**\r\n   * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when\r\n   * a gesturestart event happens. This has higher priority than dragging.\r\n   */\r\n  __isGesturing: false,\r\n\r\n  /**\r\n   * {Boolean} Whether the user has moved by such a distance that we have enabled\r\n   * dragging mode. Hint: It's only enabled after some pixels of movement to\r\n   * not interrupt with clicks etc.\r\n   */\r\n  __isDragging: false,\r\n\r\n  /**\r\n   * {Boolean} Not touching and dragging anymore, and smoothly animating the\r\n   * touch sequence using deceleration.\r\n   */\r\n  __isDecelerating: false,\r\n\r\n  /**\r\n   * {Boolean} Smoothly animating the currently configured change\r\n   */\r\n  __isAnimating: false,\r\n\r\n  /*\r\n\t---------------------------------------------------------------------------\r\n\t\tINTERNAL FIELDS :: DIMENSIONS\r\n\t---------------------------------------------------------------------------\r\n\t*/\r\n\r\n  /** {Integer} Available outer left position (from document perspective) */\r\n  __clientLeft: 0,\r\n\r\n  /** {Integer} Available outer top position (from document perspective) */\r\n  __clientTop: 0,\r\n\r\n  /** {Integer} Available outer width */\r\n  __clientWidth: 0,\r\n\r\n  /** {Integer} Available outer height */\r\n  __clientHeight: 0,\r\n\r\n  /** {Integer} Outer width of content */\r\n  __contentWidth: 0,\r\n\r\n  /** {Integer} Outer height of content */\r\n  __contentHeight: 0,\r\n\r\n  /** {Integer} Snapping width for content */\r\n  __snapWidth: 100,\r\n\r\n  /** {Integer} Snapping height for content */\r\n  __snapHeight: 100,\r\n\r\n  /** {Integer} Height to assign to refresh area */\r\n  __refreshHeight: null,\r\n  /** {Integer} Height to assign to refresh area */\r\n  __loadHeight: null,\r\n  /** {Boolean} Whether the refresh process is enabled when the event is released now */\r\n  __refreshActive: false,\r\n\r\n  /** {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release */\r\n  __refreshActivate: null,\r\n\r\n  __refreshBeforeDeactivate: null,\r\n\r\n  /** {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled */\r\n  __refreshDeactivate: null,\r\n\r\n  /** {Function} Callback to execute to start the actual refresh. Call {@link #refreshFinish} when done */\r\n  __refreshStart: null,\r\n\r\n  __loadActive: null,\r\n\r\n  __loadActivate: null,\r\n\r\n  __loadBeforeDeactivate: null,\r\n\r\n  __loadDeactivate: null,\r\n\r\n  __loadStart: null,\r\n  /** {Number} Zoom level */\r\n  __zoomLevel: 1,\r\n\r\n  /** {Number} Scroll position on x-axis */\r\n  __scrollLeft: 0,\r\n\r\n  /** {Number} Scroll position on y-axis */\r\n  __scrollTop: 0,\r\n\r\n  /** {Integer} Maximum allowed scroll position on x-axis */\r\n  __maxScrollLeft: 0,\r\n\r\n  /** {Integer} Maximum allowed scroll position on y-axis */\r\n  __maxScrollTop: 0,\r\n\r\n  /* {Number} Scheduled left position (final position when animating) */\r\n  __scheduledLeft: 0,\r\n\r\n  /* {Number} Scheduled top position (final position when animating) */\r\n  __scheduledTop: 0,\r\n\r\n  /* {Number} Scheduled zoom level (final scale when animating) */\r\n  __scheduledZoom: 0,\r\n\r\n  /**\r\n   * current page\r\n   */\r\n  __currentPageX: null,\r\n\r\n  __currentPageY: null,\r\n\r\n  /**\r\n   * total page\r\n   */\r\n  __totalXPage: null,\r\n\r\n  __totalYPage: null,\r\n  /*\r\n\t---------------------------------------------------------------------------\r\n\t\tINTERNAL FIELDS :: LAST POSITIONS\r\n\t---------------------------------------------------------------------------\r\n\t*/\r\n  /** whether the scroller is disabled or not */\r\n  __disable: false,\r\n  /** {Number} Left position of finger at start */\r\n  __lastTouchLeft: null,\r\n\r\n  /** {Number} Top position of finger at start */\r\n  __lastTouchTop: null,\r\n\r\n  /** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */\r\n  __lastTouchMove: null,\r\n\r\n  /** {Array} List of positions, uses three indexes for each state: left, top, timestamp */\r\n  __positions: null,\r\n\r\n  /*\r\n\t---------------------------------------------------------------------------\r\n\t\tINTERNAL FIELDS :: DECELERATION SUPPORT\r\n\t---------------------------------------------------------------------------\r\n\t*/\r\n\r\n  /** {Integer} Minimum left scroll position during deceleration */\r\n  __minDecelerationScrollLeft: null,\r\n\r\n  /** {Integer} Minimum top scroll position during deceleration */\r\n  __minDecelerationScrollTop: null,\r\n\r\n  /** {Integer} Maximum left scroll position during deceleration */\r\n  __maxDecelerationScrollLeft: null,\r\n\r\n  /** {Integer} Maximum top scroll position during deceleration */\r\n  __maxDecelerationScrollTop: null,\r\n\r\n  /** {Number} Current factor to modify horizontal scroll position with on every step */\r\n  __decelerationVelocityX: null,\r\n\r\n  /** {Number} Current factor to modify vertical scroll position with on every step */\r\n  __decelerationVelocityY: null,\r\n\r\n  /*\r\n\t---------------------------------------------------------------------------\r\n\t\tPUBLIC API\r\n\t---------------------------------------------------------------------------\r\n\t*/\r\n\r\n  /**\r\n   * Configures the dimensions of the client (outer) and content (inner) elements.\r\n   * Requires the available space for the outer element and the outer size of the inner element.\r\n   * All values which are falsy (null or zero etc.) are ignored and the old value is kept.\r\n   *\r\n   * @param clientWidth {Integer ? null} Inner width of outer element\r\n   * @param clientHeight {Integer ? null} Inner height of outer element\r\n   * @param contentWidth {Integer ? null} Outer width of inner element\r\n   * @param contentHeight {Integer ? null} Outer height of inner element\r\n   */\r\n  setDimensions: function(\r\n    clientWidth,\r\n    clientHeight,\r\n    contentWidth,\r\n    contentHeight,\r\n    animate,\r\n    noScroll = false\r\n  ) {\r\n    var self = this;\r\n\r\n    // Only update values which are defined\r\n    if (clientWidth === +clientWidth) {\r\n      self.__clientWidth = clientWidth;\r\n    }\r\n\r\n    if (clientHeight === +clientHeight) {\r\n      self.__clientHeight = clientHeight;\r\n    }\r\n\r\n    if (contentWidth === +contentWidth) {\r\n      self.__contentWidth = contentWidth;\r\n    }\r\n\r\n    if (contentHeight === +contentHeight) {\r\n      self.__contentHeight = contentHeight;\r\n    }\r\n\r\n    // Refresh maximums\r\n    self.__computeScrollMax();\r\n\r\n    if (!noScroll) {\r\n      // Refresh scroll position\r\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, animate);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sets the client coordinates in relation to the document.\r\n   *\r\n   * @param left {Integer ? 0} Left position of outer element\r\n   * @param top {Integer ? 0} Top position of outer element\r\n   */\r\n  setPosition: function(left, top) {\r\n    var self = this;\r\n\r\n    self.__clientLeft = left || 0;\r\n    self.__clientTop = top || 0;\r\n  },\r\n\r\n  /**\r\n   * Configures the snapping (when snapping is active)\r\n   *\r\n   * @param width {Integer} Snapping width\r\n   * @param height {Integer} Snapping height\r\n   */\r\n  setSnapSize: function(width, height) {\r\n    var self = this;\r\n\r\n    self.__snapWidth = width;\r\n    self.__snapHeight = height;\r\n  },\r\n\r\n  /**\r\n   * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever\r\n   * the user event is released during visibility of this zone. This was introduced by some apps on iOS like\r\n   * the official Twitter client.\r\n   *\r\n   * @param height {Integer} Height of pull-to-refresh zone on top of rendered list\r\n   * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.\r\n   * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.\r\n   * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.\r\n   */\r\n  activatePullToRefresh: function(\r\n    height,\r\n    {\r\n      activateCallback,\r\n      deactivateCallback,\r\n      startCallback,\r\n      beforeDeactivateCallback\r\n    }\r\n  ) {\r\n    var self = this;\r\n\r\n    self.__refreshHeight = height;\r\n    self.__refreshActivate = activateCallback;\r\n    self.__refreshBeforeDeactivate = beforeDeactivateCallback;\r\n    self.__refreshDeactivate = deactivateCallback;\r\n    self.__refreshStart = startCallback;\r\n  },\r\n  activatePushToLoad: function(\r\n    height,\r\n    {\r\n      activateCallback,\r\n      deactivateCallback,\r\n      startCallback,\r\n      beforeDeactivateCallback\r\n    }\r\n  ) {\r\n    var self = this;\r\n\r\n    self.__loadHeight = height;\r\n    self.__loadActivate = activateCallback;\r\n    self.__loadBeforeDeactivate = beforeDeactivateCallback;\r\n    self.__loadDeactivate = deactivateCallback;\r\n    self.__loadStart = startCallback;\r\n  },\r\n\r\n  /**\r\n   * Starts pull-to-refresh manually.\r\n   */\r\n  triggerRefreshOrLoad: function(type = 'refresh') {\r\n    var wasDecelerating = this.__isDecelerating;\r\n    if (wasDecelerating) {\r\n      core.effect.Animate.stop(wasDecelerating);\r\n      this.__isDecelerating = false;\r\n    }\r\n    // Use publish instead of scrollTo to allow scrolling to out of boundary position\r\n    // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\r\n    if (type == 'refresh') {\r\n      this.__publish(\r\n        this.__scrollLeft,\r\n        -this.__refreshHeight,\r\n        this.__zoomLevel,\r\n        true\r\n      );\r\n      if (this.__refreshStart) {\r\n        this.__refreshStart();\r\n        this.__refreshActive = true;\r\n      }\r\n    } else {\r\n      this.__publish(\r\n        this.__scrollLeft,\r\n        this.__maxScrollTop + this.__loadHeight,\r\n        this.__zoomLevel,\r\n        true\r\n      );\r\n      if (this.__loadStart) {\r\n        this.__loadStart();\r\n        this.__loadActive = true;\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Signalizes that pull-to-refresh is finished.\r\n   */\r\n  finishRefreshOrLoad: function() {\r\n    var self = this;\r\n\r\n    if (self.__refreshBeforeDeactivate && self.__refreshActive) {\r\n      self.__refreshActive = false;\r\n      self.__refreshBeforeDeactivate(function() {\r\n        if (self.__refreshDeactivate) {\r\n          self.__refreshDeactivate();\r\n        }\r\n        self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\r\n      });\r\n    } else if (self.__refreshDeactivate && self.__refreshActive) {\r\n      self.__refreshActive = false;\r\n      self.__refreshDeactivate();\r\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\r\n    }\r\n\r\n    if (self.__loadBeforeDeactivate && self.__loadActive) {\r\n      self.__loadActive = false;\r\n      self.__loadBeforeDeactivate(function() {\r\n        if (self.__loadDeactivate) {\r\n          self.__loadDeactivate();\r\n        }\r\n        self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\r\n      });\r\n    } else if (self.__loadDeactivate && self.__loadActive) {\r\n      self.__loadActive = false;\r\n      self.__loadDeactivate();\r\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Returns the scroll position and zooming values\r\n   *\r\n   * @return {Map} `left` and `top` scroll position and `zoom` level\r\n   */\r\n  getValues: function() {\r\n    var self = this;\r\n\r\n    return {\r\n      left: self.__scrollLeft,\r\n      top: self.__scrollTop,\r\n      zoom: self.__zoomLevel\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Returns the maximum scroll values\r\n   *\r\n   * @return {Map} `left` and `top` maximum scroll values\r\n   */\r\n  getScrollMax: function() {\r\n    var self = this;\r\n\r\n    return {\r\n      left: self.__maxScrollLeft,\r\n      top: self.__maxScrollTop\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Zooms to the given level. Supports optional animation. Zooms\r\n   * the center when no coordinates are given.\r\n   *\r\n   * @param level {Number} Level to zoom to\r\n   * @param animate {Boolean ? false} Whether to use animation\r\n   * @param originLeft {Number ? null} Zoom in at given left coordinate\r\n   * @param originTop {Number ? null} Zoom in at given top coordinate\r\n   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\r\n   */\r\n  zoomTo: function(level, animate, originLeft, originTop, callback) {\r\n    var self = this;\r\n\r\n    if (!self.options.zooming) {\r\n      throw new Error('Zooming is not enabled!');\r\n    }\r\n\r\n    // Add callback if exists\r\n    if (callback) {\r\n      self.__zoomComplete = callback;\r\n    }\r\n\r\n    // Stop deceleration\r\n    if (self.__isDecelerating) {\r\n      core.effect.Animate.stop(self.__isDecelerating);\r\n      self.__isDecelerating = false;\r\n    }\r\n\r\n    var oldLevel = self.__zoomLevel;\r\n\r\n    // Normalize input origin to center of viewport if not defined\r\n    if (originLeft == null) {\r\n      originLeft = self.__clientWidth / 2;\r\n    }\r\n\r\n    if (originTop == null) {\r\n      originTop = self.__clientHeight / 2;\r\n    }\r\n\r\n    // Limit level according to configuration\r\n    level = Math.max(\r\n      Math.min(level, self.options.maxZoom),\r\n      self.options.minZoom\r\n    );\r\n\r\n    // Recompute maximum values while temporary tweaking maximum scroll ranges\r\n    self.__computeScrollMax(level);\r\n\r\n    // Recompute left and top coordinates based on new zoom level\r\n    var left =\r\n      ((originLeft + self.__scrollLeft) * level) / oldLevel - originLeft;\r\n    var top = ((originTop + self.__scrollTop) * level) / oldLevel - originTop;\r\n\r\n    // Limit x-axis\r\n    if (left > self.__maxScrollLeft) {\r\n      left = self.__maxScrollLeft;\r\n    } else if (left < 0) {\r\n      left = 0;\r\n    }\r\n\r\n    // Limit y-axis\r\n    if (top > self.__maxScrollTop) {\r\n      top = self.__maxScrollTop;\r\n    } else if (top < 0) {\r\n      top = 0;\r\n    }\r\n\r\n    // Push values out\r\n    self.__publish(left, top, level, animate);\r\n  },\r\n\r\n  /**\r\n   * Zooms the content by the given factor.\r\n   *\r\n   * @param factor {Number} Zoom by given factor\r\n   * @param animate {Boolean ? false} Whether to use animation\r\n   * @param originLeft {Number ? 0} Zoom in at given left coordinate\r\n   * @param originTop {Number ? 0} Zoom in at given top coordinate\r\n   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\r\n   */\r\n  zoomBy: function(factor, animate, originLeft, originTop, callback) {\r\n    var self = this;\r\n\r\n    self.zoomTo(\r\n      self.__zoomLevel * factor,\r\n      animate,\r\n      originLeft,\r\n      originTop,\r\n      callback\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Scrolls to the given position. Respect limitations and snapping automatically.\r\n   *\r\n   * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>\r\n   * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>\r\n   * @param animate {Boolean?false} Whether the scrolling should happen using an animation\r\n   * @param zoom {Number?null} Zoom level to go to\r\n   */\r\n  scrollTo: function(left, top, animate, zoom, force) {\r\n    var self = this;\r\n\r\n    // Stop deceleration\r\n    if (self.__isDecelerating) {\r\n      core.effect.Animate.stop(self.__isDecelerating);\r\n      self.__isDecelerating = false;\r\n    }\r\n\r\n    // Correct coordinates based on new zoom level\r\n    if (zoom != null && zoom !== self.__zoomLevel) {\r\n      if (!self.options.zooming) {\r\n        throw new Error('Zooming is not enabled!');\r\n      }\r\n\r\n      left *= zoom;\r\n      top *= zoom;\r\n\r\n      // Recompute maximum values while temporary tweaking maximum scroll ranges\r\n      self.__computeScrollMax(zoom);\r\n    } else {\r\n      // Keep zoom when not defined\r\n      zoom = self.__zoomLevel;\r\n    }\r\n\r\n    if (!self.options.scrollingX && !force) {\r\n      left = self.__scrollLeft;\r\n    } else {\r\n      if (self.options.paging) {\r\n        left = Math.round(left / self.__clientWidth) * self.__clientWidth;\r\n      } else if (self.options.snapping) {\r\n        left = Math.round(left / self.__snapWidth) * self.__snapWidth;\r\n      }\r\n    }\r\n\r\n    if (!self.options.scrollingY && !force) {\r\n      top = self.__scrollTop;\r\n    } else {\r\n      if (self.options.paging) {\r\n        top = Math.round(top / self.__clientHeight) * self.__clientHeight;\r\n      } else if (self.options.snapping) {\r\n        top = Math.round(top / self.__snapHeight) * self.__snapHeight;\r\n      }\r\n    }\r\n\r\n    // Limit for allowed ranges\r\n    left = Math.max(Math.min(self.__maxScrollLeft, left), 0);\r\n    top = Math.max(Math.min(self.__maxScrollTop, top), 0);\r\n    // Don't animate when no change detected, still call publish to make sure\r\n    // that rendered position is really in-sync with internal data\r\n    if (left === self.__scrollLeft && top === self.__scrollTop) {\r\n      animate = false;\r\n    }\r\n\r\n    // Publish new values\r\n    if (!self.__isTracking) {\r\n      self.__publish(left, top, zoom, animate);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Scroll by the given offset\r\n   *\r\n   * @param left {Number ? 0} Scroll x-axis by given offset\r\n   * @param top {Number ? 0} Scroll x-axis by given offset\r\n   * @param animate {Boolean ? false} Whether to animate the given change\r\n   */\r\n  scrollBy: function(left, top, animate) {\r\n    var self = this;\r\n\r\n    var startLeft = self.__isAnimating\r\n      ? self.__scheduledLeft\r\n      : self.__scrollLeft;\r\n    var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;\r\n\r\n    self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);\r\n  },\r\n  getCurrentPage() {\r\n    this.__computePage();\r\n    return {\r\n      x: this.__currentPageX,\r\n      y: this.__currentPageY\r\n    };\r\n  },\r\n\r\n  goToPage({ x, y }, animate) {\r\n    if (isNaN(x)) {\r\n      x = 1;\r\n    }\r\n    if (isNaN(y)) {\r\n      y = 1;\r\n    }\r\n    this.scrollTo(\r\n      (x - 1) * this.__clientWidth,\r\n      (y - 1) * this.__clientHeight,\r\n      animate\r\n    );\r\n  },\r\n\r\n  /*\r\n\t---------------------------------------------------------------------------\r\n\t\tEVENT CALLBACKS\r\n\t---------------------------------------------------------------------------\r\n\t*/\r\n\r\n  /**\r\n   * Mouse wheel handler for zooming support\r\n   */\r\n  doMouseZoom: function(wheelDelta, timeStamp, pageX, pageY) {\r\n    var self = this;\r\n    var change = wheelDelta > 0 ? 0.97 : 1.03;\r\n\r\n    return self.zoomTo(\r\n      self.__zoomLevel * change,\r\n      false,\r\n      pageX - self.__clientLeft,\r\n      pageY - self.__clientTop\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Touch start handler for scrolling support\r\n   */\r\n  doTouchStart: function(touches, timeStamp) {\r\n    // Array-like check is enough here\r\n    if (touches.length == null) {\r\n      throw new Error('Invalid touch list: ' + touches);\r\n    }\r\n\r\n    if (timeStamp instanceof Date) {\r\n      timeStamp = timeStamp.valueOf();\r\n    }\r\n    if (typeof timeStamp !== 'number') {\r\n      throw new Error('Invalid timestamp value: ' + timeStamp);\r\n    }\r\n\r\n    var self = this;\r\n\r\n    // Reset interruptedAnimation flag\r\n    self.__interruptedAnimation = true;\r\n\r\n    // Stop deceleration\r\n    if (self.__isDecelerating) {\r\n      core.effect.Animate.stop(self.__isDecelerating);\r\n      self.__isDecelerating = false;\r\n      self.__interruptedAnimation = true;\r\n    }\r\n\r\n    // Stop animation\r\n    if (self.__isAnimating) {\r\n      core.effect.Animate.stop(self.__isAnimating);\r\n      self.__isAnimating = false;\r\n      self.__interruptedAnimation = true;\r\n    }\r\n\r\n    // Use center point when dealing with two fingers\r\n    var currentTouchLeft, currentTouchTop;\r\n    var isSingleTouch = touches.length === 1;\r\n    if (isSingleTouch) {\r\n      currentTouchLeft = touches[0].pageX;\r\n      currentTouchTop = touches[0].pageY;\r\n    } else {\r\n      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\r\n      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\r\n    }\r\n\r\n    // Store initial positions\r\n    self.__initialTouchLeft = currentTouchLeft;\r\n    self.__initialTouchTop = currentTouchTop;\r\n\r\n    // Store current zoom level\r\n    self.__zoomLevelStart = self.__zoomLevel;\r\n\r\n    // Store initial touch positions\r\n    self.__lastTouchLeft = currentTouchLeft;\r\n    self.__lastTouchTop = currentTouchTop;\r\n\r\n    // Store initial move time stamp\r\n    self.__lastTouchMove = timeStamp;\r\n\r\n    // Reset initial scale\r\n    self.__lastScale = 1;\r\n\r\n    // Reset locking flags\r\n    self.__enableScrollX = !isSingleTouch && self.options.scrollingX;\r\n    self.__enableScrollY = !isSingleTouch && self.options.scrollingY;\r\n\r\n    // Reset tracking flag\r\n    self.__isTracking = true;\r\n\r\n    // Reset deceleration complete flag\r\n    self.__didDecelerationComplete = false;\r\n\r\n    // Dragging starts directly with two fingers, otherwise lazy with an offset\r\n    self.__isDragging = !isSingleTouch;\r\n\r\n    // Some features are  in multi touch scenarios\r\n    self.__isSingleTouch = isSingleTouch;\r\n\r\n    // Clearing data structure\r\n    self.__positions = [];\r\n  },\r\n\r\n  /**\r\n   * Touch move handler for scrolling support\r\n   */\r\n  doTouchMove: function(touches, timeStamp, scale) {\r\n    // Array-like check is enough here\r\n    if (touches.length == null) {\r\n      throw new Error('Invalid touch list: ' + touches);\r\n    }\r\n\r\n    if (timeStamp instanceof Date) {\r\n      timeStamp = timeStamp.valueOf();\r\n    }\r\n    if (typeof timeStamp !== 'number') {\r\n      throw new Error('Invalid timestamp value: ' + timeStamp);\r\n    }\r\n\r\n    var self = this;\r\n\r\n    // Ignore event when tracking is not enabled (event might be outside of element)\r\n    if (!self.__isTracking) {\r\n      return;\r\n    }\r\n\r\n    var currentTouchLeft, currentTouchTop;\r\n\r\n    // Compute move based around of center of fingers\r\n    if (touches.length === 2) {\r\n      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\r\n      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\r\n    } else {\r\n      currentTouchLeft = touches[0].pageX;\r\n      currentTouchTop = touches[0].pageY;\r\n    }\r\n\r\n    var positions = self.__positions;\r\n\r\n    // Are we already is dragging mode?\r\n    if (self.__isDragging) {\r\n      // Compute move distance\r\n      var moveX = currentTouchLeft - self.__lastTouchLeft;\r\n      var moveY = currentTouchTop - self.__lastTouchTop;\r\n\r\n      // Read previous scroll position and zooming\r\n      var scrollLeft = self.__scrollLeft;\r\n      var scrollTop = self.__scrollTop;\r\n      var level = self.__zoomLevel;\r\n\r\n      // Work with scaling\r\n      if (scale != null && self.options.zooming) {\r\n        var oldLevel = level;\r\n\r\n        // Recompute level based on previous scale and new scale\r\n        level = (level / self.__lastScale) * scale;\r\n\r\n        // Limit level according to configuration\r\n        level = Math.max(\r\n          Math.min(level, self.options.maxZoom),\r\n          self.options.minZoom\r\n        );\r\n\r\n        // Only do further compution when change happened\r\n        if (oldLevel !== level) {\r\n          // Compute relative event position to container\r\n          var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;\r\n          var currentTouchTopRel = currentTouchTop - self.__clientTop;\r\n\r\n          // Recompute left and top coordinates based on new zoom level\r\n          scrollLeft =\r\n            ((currentTouchLeftRel + scrollLeft) * level) / oldLevel -\r\n            currentTouchLeftRel;\r\n          scrollTop =\r\n            ((currentTouchTopRel + scrollTop) * level) / oldLevel -\r\n            currentTouchTopRel;\r\n\r\n          // Recompute max scroll values\r\n          self.__computeScrollMax(level);\r\n        }\r\n      }\r\n\r\n      if (self.__enableScrollX) {\r\n        scrollLeft -= moveX * this.options.speedMultiplier;\r\n        var maxScrollLeft = self.__maxScrollLeft;\r\n\r\n        if (scrollLeft > maxScrollLeft || scrollLeft < 0) {\r\n          // Slow down on the edges\r\n          if (self.options.bouncing) {\r\n            scrollLeft += (moveX / 2) * this.options.speedMultiplier;\r\n          } else if (scrollLeft > maxScrollLeft) {\r\n            scrollLeft = maxScrollLeft;\r\n          } else {\r\n            scrollLeft = 0;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Compute new vertical scroll position\r\n      if (self.__enableScrollY) {\r\n        scrollTop -= moveY * this.options.speedMultiplier;\r\n        var maxScrollTop = self.__maxScrollTop;\r\n\r\n        if (scrollTop > maxScrollTop || scrollTop < 0) {\r\n          // Slow down on the edges\r\n          if (self.options.bouncing) {\r\n            scrollTop += (moveY / 2) * this.options.speedMultiplier;\r\n\r\n            // Support pull-to-refresh (only when only y is scrollable)\r\n            if (\r\n              !self.__enableScrollX &&\r\n              (self.__refreshHeight != null || self.__loadHeight != null)\r\n            ) {\r\n              if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {\r\n                self.__refreshActive = true;\r\n                if (self.__refreshActivate) {\r\n                  self.__refreshActivate();\r\n                }\r\n              } else if (\r\n                self.__refreshActive &&\r\n                scrollTop > -self.__refreshHeight\r\n              ) {\r\n                self.__refreshActive = false;\r\n                if (self.__refreshDeactivate) {\r\n                  self.__refreshDeactivate();\r\n                }\r\n              }\r\n              // handle for push-load\r\n              else if (\r\n                !self.__loadActive &&\r\n                scrollTop >= self.__maxScrollTop + self.__loadHeight\r\n              ) {\r\n                self.__loadActive = true;\r\n                if (self.__loadActivate) {\r\n                  self.__loadActivate();\r\n                }\r\n              } else if (\r\n                self.__refreshActive &&\r\n                scrollTop < self.__maxScrollTop + self.__loadHeight\r\n              ) {\r\n                self.__loadActive = false;\r\n                if (self.__loadDeactivate) {\r\n                  self.__loadDeactivate();\r\n                }\r\n              }\r\n            }\r\n          } else if (scrollTop > maxScrollTop) {\r\n            scrollTop = maxScrollTop;\r\n          } else {\r\n            scrollTop = 0;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Keep list from growing infinitely (holding min 10, max 20 measure points)\r\n      if (positions.length > 60) {\r\n        positions.splice(0, 30);\r\n      }\r\n\r\n      // Track scroll movement for decleration\r\n      positions.push(scrollLeft, scrollTop, timeStamp);\r\n\r\n      // Sync scroll position\r\n      self.__publish(scrollLeft, scrollTop, level);\r\n\r\n      // Otherwise figure out whether we are switching into dragging mode now.\r\n    } else {\r\n      var minimumTrackingForScroll = self.options.locking ? 3 : 0;\r\n      var minimumTrackingForDrag = 5;\r\n\r\n      var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);\r\n      var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);\r\n\r\n      self.__enableScrollX =\r\n        self.options.scrollingX && distanceX >= minimumTrackingForScroll;\r\n      self.__enableScrollY =\r\n        self.options.scrollingY && distanceY >= minimumTrackingForScroll;\r\n\r\n      positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);\r\n\r\n      self.__isDragging =\r\n        (self.__enableScrollX || self.__enableScrollY) &&\r\n        (distanceX >= minimumTrackingForDrag ||\r\n          distanceY >= minimumTrackingForDrag);\r\n      if (self.__isDragging) {\r\n        self.__interruptedAnimation = false;\r\n      }\r\n    }\r\n\r\n    // Update last touch positions and time stamp for next event\r\n    self.__lastTouchLeft = currentTouchLeft;\r\n    self.__lastTouchTop = currentTouchTop;\r\n    self.__lastTouchMove = timeStamp;\r\n    self.__lastScale = scale;\r\n  },\r\n\r\n  /**\r\n   * Touch end handler for scrolling support\r\n   */\r\n  doTouchEnd: function(timeStamp) {\r\n    if (timeStamp instanceof Date) {\r\n      timeStamp = timeStamp.valueOf();\r\n    }\r\n    if (typeof timeStamp !== 'number') {\r\n      throw new Error('Invalid timestamp value: ' + timeStamp);\r\n    }\r\n\r\n    var self = this;\r\n\r\n    // Ignore event when tracking is not enabled (no touchstart event on element)\r\n    // This is required as this listener ('touchmove') sits on the document and not on the element itself.\r\n    if (!self.__isTracking) {\r\n      return;\r\n    }\r\n\r\n    // Not touching anymore (when two finger hit the screen there are two touch end events)\r\n    self.__isTracking = false;\r\n\r\n    // Be sure to reset the dragging flag now. Here we also detect whether\r\n    // the finger has moved fast enough to switch into a deceleration animation.\r\n    if (self.__isDragging) {\r\n      // Reset dragging flag\r\n      self.__isDragging = false;\r\n\r\n      // Start deceleration\r\n      // Verify that the last move detected was in some relevant time frame\r\n      if (\r\n        self.__isSingleTouch &&\r\n        self.options.animating &&\r\n        timeStamp - self.__lastTouchMove <= 100\r\n      ) {\r\n        // Then figure out what the scroll position was about 100ms ago\r\n        var positions = self.__positions;\r\n        var endPos = positions.length - 1;\r\n        var startPos = endPos;\r\n\r\n        // Move pointer to position measured 100ms ago\r\n        for (\r\n          var i = endPos;\r\n          i > 0 && positions[i] > self.__lastTouchMove - 100;\r\n          i -= 3\r\n        ) {\r\n          startPos = i;\r\n        }\r\n\r\n        // If start and stop position is identical in a 100ms timeframe,\r\n        // we cannot compute any useful deceleration.\r\n        if (startPos !== endPos) {\r\n          // Compute relative movement between these two points\r\n          var timeOffset = positions[endPos] - positions[startPos];\r\n          var movedLeft = self.__scrollLeft - positions[startPos - 2];\r\n          var movedTop = self.__scrollTop - positions[startPos - 1];\r\n\r\n          // Based on 50ms compute the movement to apply for each render step\r\n          self.__decelerationVelocityX = (movedLeft / timeOffset) * (1000 / 60);\r\n          self.__decelerationVelocityY = (movedTop / timeOffset) * (1000 / 60);\r\n\r\n          // How much velocity is required to start the deceleration\r\n          var minVelocityToStartDeceleration =\r\n            self.options.paging || self.options.snapping ? 4 : 1;\r\n\r\n          // Verify that we have enough velocity to start deceleration\r\n          if (\r\n            Math.abs(self.__decelerationVelocityX) >\r\n              minVelocityToStartDeceleration ||\r\n            Math.abs(self.__decelerationVelocityY) >\r\n              minVelocityToStartDeceleration\r\n          ) {\r\n            // Deactivate pull-to-refresh when decelerating\r\n            if (!self.__refreshActive && !self.__loadActive) {\r\n              self.__startDeceleration(timeStamp);\r\n            }\r\n          } else {\r\n            self.__scrollComplete();\r\n          }\r\n        } else {\r\n          self.__scrollComplete();\r\n        }\r\n      } else if (timeStamp - self.__lastTouchMove > 100) {\r\n        self.__scrollComplete();\r\n      }\r\n    }\r\n\r\n    // If this was a slower move it is per default non decelerated, but this\r\n    // still means that we want snap back to the bounds which is done here.\r\n    // This is placed outside the condition above to improve edge case stability\r\n    // e.g. touchend fired without enabled dragging. This should normally do not\r\n    // have modified the scroll positions or even showed the scrollbars though.\r\n    if (!self.__isDecelerating) {\r\n      if (self.__refreshActive && self.__refreshStart) {\r\n        // Use publish instead of scrollTo to allow scrolling to out of boundary position\r\n        // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\r\n        self.__publish(\r\n          self.__scrollLeft,\r\n          -self.__refreshHeight,\r\n          self.__zoomLevel,\r\n          true\r\n        );\r\n\r\n        if (self.__refreshStart) {\r\n          self.__refreshStart();\r\n        }\r\n      } else if (self.__loadActive && self.__loadStart) {\r\n        // Use publish instead of scrollTo to allow scrolling to out of boundary position\r\n        // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\r\n        self.__publish(\r\n          self.__scrollLeft,\r\n          self.__maxScrollTop + self.__loadHeight,\r\n          self.__zoomLevel,\r\n          true\r\n        );\r\n\r\n        if (self.__loadStart) {\r\n          self.__loadStart();\r\n        }\r\n      } else {\r\n        if (self.__interruptedAnimation || self.__isDragging) {\r\n          self.__scrollComplete();\r\n        }\r\n        self.scrollTo(\r\n          self.__scrollLeft,\r\n          self.__scrollTop,\r\n          true,\r\n          self.__zoomLevel\r\n        );\r\n\r\n        // Directly signalize deactivation (nothing todo on refresh?)\r\n        if (self.__refreshActive) {\r\n          self.__refreshActive = false;\r\n          if (self.__refreshDeactivate) {\r\n            self.__refreshDeactivate();\r\n          }\r\n        } else if (self.__loadActive) {\r\n          self.__loadActive = false;\r\n          if (self.__loadDeactivate) {\r\n            self.__loadDeactivate();\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fully cleanup list\r\n    self.__positions.length = 0;\r\n  },\r\n\r\n  /** Handle for scroll/publish */\r\n  onScroll: NOOP,\r\n\r\n  stop: function() {\r\n    var self = this;\r\n\r\n    self.__disable = true;\r\n  },\r\n  start: function() {\r\n    self.__disable = true;\r\n  },\r\n  /*\r\n\t---------------------------------------------------------------------------\r\n\t\tPRIVATE API\r\n\t---------------------------------------------------------------------------\r\n\t*/\r\n\r\n  /**\r\n   * Applies the scroll position to the content element\r\n   *\r\n   * @param left {Number} Left scroll position\r\n   * @param top {Number} Top scroll position\r\n   * @param animate {Boolean?false} Whether animation should be used to move to the new coordinates\r\n   */\r\n  __publish: function(left, top, zoom, animate) {\r\n    var self = this;\r\n    if (self.__disable) {\r\n      return;\r\n    }\r\n    if (isNaN(left)) {\r\n      left = this.__scrollLeft;\r\n    }\r\n    if (isNaN(top)) {\r\n      top = this.__scrollTop;\r\n    }\r\n    // Remember whether we had an animation, then we try to continue based on the current \"drive\" of the animation\r\n    var wasAnimating = self.__isAnimating;\r\n    if (wasAnimating) {\r\n      core.effect.Animate.stop(wasAnimating);\r\n      self.__isAnimating = false;\r\n    }\r\n\r\n    if (animate && self.options.animating) {\r\n      // Keep scheduled positions for scrollBy/zoomBy functionality\r\n      self.__scheduledLeft = left;\r\n      self.__scheduledTop = top;\r\n      self.__scheduledZoom = zoom;\r\n\r\n      var oldLeft = self.__scrollLeft;\r\n      var oldTop = self.__scrollTop;\r\n      var oldZoom = self.__zoomLevel;\r\n\r\n      var diffLeft = left - oldLeft;\r\n      var diffTop = top - oldTop;\r\n      var diffZoom = zoom - oldZoom;\r\n\r\n      var step = function(percent, now, render) {\r\n        if (render) {\r\n          self.__scrollLeft = oldLeft + diffLeft * percent;\r\n          self.__scrollTop = oldTop + diffTop * percent;\r\n          self.__zoomLevel = oldZoom + diffZoom * percent;\r\n\r\n          // Push values out\r\n          if (self.__callback) {\r\n            self.__callback(\r\n              self.__scrollLeft,\r\n              self.__scrollTop,\r\n              self.__zoomLevel\r\n            );\r\n            self.onScroll();\r\n          }\r\n        }\r\n      };\r\n\r\n      var verify = function(id) {\r\n        return self.__isAnimating === id;\r\n      };\r\n\r\n      var completed = function(\r\n        renderedFramesPerSecond,\r\n        animationId,\r\n        wasFinished\r\n      ) {\r\n        if (animationId === self.__isAnimating) {\r\n          self.__isAnimating = false;\r\n        }\r\n        if (self.__didDecelerationComplete || wasFinished) {\r\n          self.__scrollComplete();\r\n        }\r\n\r\n        if (self.options.zooming) {\r\n          self.__computeScrollMax();\r\n          if (self.__zoomComplete) {\r\n            self.__zoomComplete();\r\n            self.__zoomComplete = null;\r\n          }\r\n        }\r\n      };\r\n\r\n      // When continuing based on previous animation we choose an ease-out animation instead of ease-in-out\r\n      self.__isAnimating = core.effect.Animate.start(\r\n        step,\r\n        verify,\r\n        completed,\r\n        self.options.animationDuration,\r\n        wasAnimating ? animatingMethod : noAnimatingMethod\r\n      );\r\n    } else {\r\n      self.__scheduledLeft = self.__scrollLeft = left;\r\n      self.__scheduledTop = self.__scrollTop = top;\r\n      self.__scheduledZoom = self.__zoomLevel = zoom;\r\n\r\n      // Push values out\r\n      if (self.__callback) {\r\n        self.__callback(left, top, zoom);\r\n        self.onScroll();\r\n      }\r\n\r\n      // Fix max scroll ranges\r\n      if (self.options.zooming) {\r\n        self.__computeScrollMax();\r\n        if (self.__zoomComplete) {\r\n          self.__zoomComplete();\r\n          self.__zoomComplete = null;\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Recomputes scroll minimum values based on client dimensions and content dimensions.\r\n   */\r\n  __computeScrollMax: function(zoomLevel) {\r\n    var self = this;\r\n\r\n    if (zoomLevel == null) {\r\n      zoomLevel = self.__zoomLevel;\r\n    }\r\n\r\n    self.__maxScrollLeft = Math.max(\r\n      self.__contentWidth * zoomLevel - self.__clientWidth,\r\n      0\r\n    );\r\n    self.__maxScrollTop = Math.max(\r\n      self.__contentHeight * zoomLevel - self.__clientHeight,\r\n      0\r\n    );\r\n  },\r\n  /** compute current page total page */\r\n  __computePage: function() {\r\n    var self = this;\r\n    var clientWidth = self.__clientWidth;\r\n    var clientHeight = self.__clientHeight;\r\n    var left = self.__scrollLeft;\r\n    var top = self.__scrollTop;\r\n    self.__totalXPage = Math.ceil(self.__contentWidth / clientWidth);\r\n    self.__currentPageX = Math.ceil(left / clientWidth + 1);\r\n    self.__totalYPage = Math.ceil(self.__contentHeight / clientHeight);\r\n    self.__currentPageY = Math.ceil(top / clientHeight + 1);\r\n  },\r\n  /** complete scroll*/\r\n  __scrollComplete: function() {\r\n    var self = this;\r\n    self.options.scrollingComplete();\r\n  },\r\n  /*\r\n\t---------------------------------------------------------------------------\r\n\t\tANIMATION (DECELERATION) SUPPORT\r\n\t---------------------------------------------------------------------------\r\n\t*/\r\n\r\n  /**\r\n   * Called when a touch sequence end and the speed of the finger was high enough\r\n   * to switch into deceleration mode.\r\n   */\r\n  __startDeceleration: function() {\r\n    var self = this;\r\n\r\n    if (self.options.paging) {\r\n      var scrollLeft = Math.max(\r\n        Math.min(self.__scrollLeft, self.__maxScrollLeft),\r\n        0\r\n      );\r\n      var scrollTop = Math.max(\r\n        Math.min(self.__scrollTop, self.__maxScrollTop),\r\n        0\r\n      );\r\n      var clientWidth = self.__clientWidth;\r\n      var clientHeight = self.__clientHeight;\r\n\r\n      // We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.\r\n      // Each page should have exactly the size of the client area.\r\n      self.__minDecelerationScrollLeft =\r\n        Math.floor(scrollLeft / clientWidth) * clientWidth;\r\n      self.__minDecelerationScrollTop =\r\n        Math.floor(scrollTop / clientHeight) * clientHeight;\r\n      self.__maxDecelerationScrollLeft =\r\n        Math.ceil(scrollLeft / clientWidth) * clientWidth;\r\n      self.__maxDecelerationScrollTop =\r\n        Math.ceil(scrollTop / clientHeight) * clientHeight;\r\n    } else {\r\n      self.__minDecelerationScrollLeft = 0;\r\n      self.__minDecelerationScrollTop = 0;\r\n      self.__maxDecelerationScrollLeft = self.__maxScrollLeft;\r\n      self.__maxDecelerationScrollTop = self.__maxScrollTop;\r\n    }\r\n\r\n    // Wrap class method\r\n    var step = function(percent, now, render) {\r\n      self.__stepThroughDeceleration(render);\r\n    };\r\n\r\n    // How much velocity is required to keep the deceleration running\r\n    var minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.001;\r\n\r\n    // Detect whether it's still worth to continue animating steps\r\n    // If we are already slow enough to not being user perceivable anymore, we stop the whole process here.\r\n    var verify = function() {\r\n      var shouldContinue =\r\n        Math.abs(self.__decelerationVelocityX) >=\r\n          minVelocityToKeepDecelerating ||\r\n        Math.abs(self.__decelerationVelocityY) >= minVelocityToKeepDecelerating;\r\n      if (!shouldContinue) {\r\n        self.__didDecelerationComplete = true;\r\n      }\r\n      return shouldContinue;\r\n    };\r\n\r\n    var completed = function() {\r\n      if (!self.__isDecelerating) {\r\n        return;\r\n      }\r\n      self.__isDecelerating = false;\r\n      if (self.__didDecelerationComplete) {\r\n        self.__scrollComplete();\r\n      }\r\n\r\n      // Animate to grid when snapping is active, otherwise just fix out-of-boundary positions\r\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);\r\n    };\r\n\r\n    // Start animation and switch on flag\r\n    self.__isDecelerating = core.effect.Animate.start(step, verify, completed);\r\n  },\r\n\r\n  /**\r\n   * Called on every step of the animation\r\n   *\r\n   * @param inMemory {Boolean?false} Whether to not render the current step, but keep it in memory only. Used internally only!\r\n   */\r\n  __stepThroughDeceleration: function(render) {\r\n    var self = this;\r\n\r\n    //\r\n    // COMPUTE NEXT SCROLL POSITION\r\n    //\r\n\r\n    // Add deceleration to scroll position\r\n    var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;\r\n    var scrollTop = self.__scrollTop + self.__decelerationVelocityY;\r\n\r\n    //\r\n    // HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE\r\n    //\r\n\r\n    if (!self.options.bouncing) {\r\n      var scrollLeftFixed = Math.max(\r\n        Math.min(self.__maxDecelerationScrollLeft, scrollLeft),\r\n        self.__minDecelerationScrollLeft\r\n      );\r\n      if (scrollLeftFixed !== scrollLeft) {\r\n        scrollLeft = scrollLeftFixed;\r\n        self.__decelerationVelocityX = 0;\r\n      }\r\n\r\n      var scrollTopFixed = Math.max(\r\n        Math.min(self.__maxDecelerationScrollTop, scrollTop),\r\n        self.__minDecelerationScrollTop\r\n      );\r\n      if (scrollTopFixed !== scrollTop) {\r\n        scrollTop = scrollTopFixed;\r\n        self.__decelerationVelocityY = 0;\r\n      }\r\n    }\r\n\r\n    //\r\n    // UPDATE SCROLL POSITION\r\n    //\r\n\r\n    if (render) {\r\n      self.__publish(scrollLeft, scrollTop, self.__zoomLevel);\r\n    } else {\r\n      self.__scrollLeft = scrollLeft;\r\n      self.__scrollTop = scrollTop;\r\n    }\r\n\r\n    //\r\n    // SLOW DOWN\r\n    //\r\n\r\n    // Slow down velocity on every iteration\r\n    if (!self.options.paging) {\r\n      // This is the factor applied to every iteration of the animation\r\n      // to slow down the process. This should emulate natural behavior where\r\n      // objects slow down when the initiator of the movement is removed\r\n      var frictionFactor = 0.95;\r\n\r\n      self.__decelerationVelocityX *= frictionFactor;\r\n      self.__decelerationVelocityY *= frictionFactor;\r\n    }\r\n\r\n    //\r\n    // BOUNCING SUPPORT\r\n    //\r\n\r\n    if (self.options.bouncing) {\r\n      var scrollOutsideX = 0;\r\n      var scrollOutsideY = 0;\r\n\r\n      // This configures the amount of change applied to deceleration/acceleration when reaching boundaries\r\n      var penetrationDeceleration = self.options.penetrationDeceleration;\r\n      var penetrationAcceleration = self.options.penetrationAcceleration;\r\n\r\n      // Check limits\r\n      if (scrollLeft < self.__minDecelerationScrollLeft) {\r\n        scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;\r\n      } else if (scrollLeft > self.__maxDecelerationScrollLeft) {\r\n        scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;\r\n      }\r\n\r\n      if (scrollTop < self.__minDecelerationScrollTop) {\r\n        scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;\r\n      } else if (scrollTop > self.__maxDecelerationScrollTop) {\r\n        scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;\r\n      }\r\n\r\n      // Slow down until slow enough, then flip back to snap position\r\n      if (scrollOutsideX !== 0) {\r\n        if (scrollOutsideX * self.__decelerationVelocityX <= 0) {\r\n          self.__decelerationVelocityX +=\r\n            scrollOutsideX * penetrationDeceleration;\r\n        } else {\r\n          self.__decelerationVelocityX =\r\n            scrollOutsideX * penetrationAcceleration;\r\n        }\r\n      }\r\n\r\n      if (scrollOutsideY !== 0) {\r\n        if (scrollOutsideY * self.__decelerationVelocityY <= 0) {\r\n          self.__decelerationVelocityY +=\r\n            scrollOutsideY * penetrationDeceleration;\r\n        } else {\r\n          self.__decelerationVelocityY =\r\n            scrollOutsideY * penetrationAcceleration;\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n// Copy over members to prototype\r\nfor (var key in members) {\r\n  Scroller.prototype[key] = members[key];\r\n}\r\n","import Scroller from '../../third-party/scroller';\r\nimport { render } from '../../third-party/scroller/render';\r\nimport { listenContainer } from '../../third-party/scroller/listener';\r\n\r\n/**\r\n * @description refresh and load callback\r\n */\r\nfunction createStateCallbacks(type, stageName, vm, tipDom) {\r\n  const listeners = vm.$listeners;\r\n\r\n  let activateCallback = () => {\r\n    vm.vuescroll.state[stageName] = 'active';\r\n  };\r\n\r\n  let deactivateCallback = () => {\r\n    vm.vuescroll.state[stageName] = 'deactive';\r\n  };\r\n\r\n  let startCallback = () => {\r\n    vm.vuescroll.state[stageName] = 'start';\r\n    setTimeout(() => {\r\n      vm.scroller.finishRefreshOrLoad();\r\n    }, 2000);\r\n  };\r\n\r\n  let beforeDeactivateCallback = done => {\r\n    vm.vuescroll.state[stageName] = 'beforeDeactive';\r\n    setTimeout(function() {\r\n      done();\r\n    }, 500);\r\n  };\r\n  /* istanbul ignore if */\r\n  if (listeners[type + '-activate']) {\r\n    activateCallback = () => {\r\n      vm.vuescroll.state[stageName] = 'active';\r\n      vm.$emit(type + '-activate', vm, tipDom);\r\n    };\r\n  }\r\n  /* istanbul ignore if */\r\n  if (listeners[type + '-before-deactivate']) {\r\n    beforeDeactivateCallback = done => {\r\n      vm.vuescroll.state[stageName] = 'beforeDeactive';\r\n      vm.$emit(type + '-before-deactivate', vm, tipDom, done.bind(vm.scroller));\r\n    };\r\n  }\r\n  /* istanbul ignore if */\r\n  if (listeners[type + '-deactivate']) {\r\n    deactivateCallback = () => {\r\n      vm.vuescroll.state[stageName] = 'deactive';\r\n      vm.$emit(type + '-deactivate', vm, tipDom);\r\n    };\r\n  }\r\n  /* istanbul ignore if */\r\n  if (listeners[type + '-start']) {\r\n    startCallback = () => {\r\n      vm.vuescroll.state[stageName] = 'start';\r\n      vm.$emit(\r\n        type + '-start',\r\n        vm,\r\n        tipDom,\r\n        vm.scroller.finishRefreshOrLoad.bind(vm.scroller)\r\n      );\r\n    };\r\n  }\r\n\r\n  return {\r\n    activateCallback,\r\n    deactivateCallback,\r\n    startCallback,\r\n    beforeDeactivateCallback\r\n  };\r\n}\r\n\r\nexport default {\r\n  methods: {\r\n    // Update:\r\n    // 1. update height/width\r\n    // 2. update refresh or load\r\n    updateScroller() {\r\n      this.updateDimesion();\r\n      this.registryRefreshLoad();\r\n    },\r\n    updateDimesion() {\r\n      const clientWidth = this.$el.clientWidth;\r\n      const clientHeight = this.$el.clientHeight;\r\n      let contentWidth = this.scrollPanelElm.scrollWidth;\r\n      let contentHeight = this.scrollPanelElm.scrollHeight;\r\n      let refreshHeight = 0;\r\n      let loadHeight = 0;\r\n      // If the refresh option is true,let's  give a \"margin-top\" style to\r\n      // the refresh-tip dom. let it to be invisible when doesn't trigger\r\n      // refresh.\r\n      if (this.mergedOptions.vuescroll.pullRefresh.enable) {\r\n        const refreshDom =\r\n          this.$refs['refreshDom'].elm || this.$refs['refreshDom'];\r\n        refreshHeight = refreshDom.offsetHeight;\r\n        if (!refreshDom.style.marginTop) {\r\n          refreshDom.style.marginTop = -refreshHeight + 'px';\r\n        }\r\n      }\r\n      if (this.mergedOptions.vuescroll.pushLoad.enable) {\r\n        const enableLoad = this.isEnableLoad();\r\n        if (enableLoad) {\r\n          const loadDom = this.$refs['loadDom'].elm || this.$refs['loadDom'];\r\n          loadHeight = loadDom.offsetHeight;\r\n          //  hide the trailing load dom..\r\n          contentHeight -= loadHeight;\r\n        }\r\n      }\r\n      if (this.scroller) {\r\n        this.scroller.setDimensions(\r\n          clientWidth,\r\n          clientHeight,\r\n          contentWidth,\r\n          contentHeight,\r\n          false\r\n        );\r\n      }\r\n    },\r\n    registryRefreshLoad() {\r\n      // registry refresh\r\n      if (this.mergedOptions.vuescroll.pullRefresh.enable) {\r\n        this.registryEvent('refresh');\r\n      }\r\n      // registry load\r\n      if (this.mergedOptions.vuescroll.pushLoad.enable) {\r\n        this.registryEvent('load');\r\n      }\r\n    },\r\n    registryScroller() {\r\n      const preventDefault = this.mergedOptions.vuescroll.scroller\r\n        .preventDefault;\r\n      const paging = this.mergedOptions.vuescroll.paging;\r\n      const snapping = this.mergedOptions.vuescroll.snapping.enable;\r\n      // disale zooming when refresh or load enabled\r\n      let zooming =\r\n        !this.refreshLoad &&\r\n        !paging &&\r\n        !snapping &&\r\n        this.mergedOptions.vuescroll.zooming;\r\n      const { scrollingY, scrollingX } = this.mergedOptions.scrollPanel;\r\n\r\n      const scrollingComplete = this.scrollingComplete.bind(this);\r\n\r\n      // Initialize Scroller\r\n      this.scroller = new Scroller(render(this.scrollPanelElm, window, 'px'), {\r\n        ...this.mergedOptions.vuescroll.scroller,\r\n        zooming,\r\n        scrollingY,\r\n        scrollingX: scrollingX && !this.refreshLoad,\r\n        animationDuration: this.mergedOptions.scrollPanel.speed,\r\n        paging,\r\n        snapping,\r\n        scrollingComplete\r\n      });\r\n\r\n      // Set snap\r\n      if (snapping) {\r\n        this.scroller.setSnapSize(\r\n          this.mergedOptions.vuescroll.snapping.width,\r\n          this.mergedOptions.vuescroll.snapping.height\r\n        );\r\n      }\r\n      var rect = this.$el.getBoundingClientRect();\r\n      this.scroller.setPosition(\r\n        rect.left + this.$el.clientLeft,\r\n        rect.top + this.$el.clientTop\r\n      );\r\n\r\n      // Get destroy callback\r\n      const cb = listenContainer(\r\n        this.$el,\r\n        this.scroller,\r\n        eventType => {\r\n          // Thie is to dispatch the event from the scroller.\r\n          // to let vuescroll refresh the dom\r\n          switch (eventType) {\r\n          case 'mousedown':\r\n            this.vuescroll.state.isDragging = true;\r\n            break;\r\n          case 'onscroll':\r\n            this.handleScroll(false);\r\n            break;\r\n          case 'mouseup':\r\n            this.vuescroll.state.isDragging = false;\r\n            break;\r\n          }\r\n        },\r\n        zooming,\r\n        preventDefault\r\n      );\r\n\r\n      this.updateScroller();\r\n\r\n      return cb;\r\n    },\r\n    updateSlideModeBarState() {\r\n      // update slide mode scrollbars' state\r\n      let heightPercentage, widthPercentage;\r\n      const vuescroll = this.$el;\r\n      const scroller = this.scroller;\r\n      let outerLeft = 0;\r\n      let outerTop = 0;\r\n      const clientWidth = this.$el.clientHeight;\r\n      const clientHeight = this.$el.clientHeight;\r\n      const contentWidth = clientWidth + this.scroller.__maxScrollLeft;\r\n      const contentHeight = clientHeight + this.scroller.__maxScrollTop;\r\n      const __enableScrollX =\r\n        clientWidth < contentWidth && this.mergedOptions.scrollPanel.scrollingX;\r\n      const __enableScrollY =\r\n        clientHeight < contentHeight &&\r\n        this.mergedOptions.scrollPanel.scrollingY;\r\n      // out of horizontal bountry\r\n      if (__enableScrollX) {\r\n        /* istanbul ignore if */\r\n        if (scroller.__scrollLeft < 0) {\r\n          outerLeft = -scroller.__scrollLeft;\r\n        } /* istanbul ignore next */ else if (\r\n          scroller.__scrollLeft > scroller.__maxScrollLeft\r\n        ) {\r\n          outerLeft = scroller.__scrollLeft - scroller.__maxScrollLeft;\r\n        }\r\n      }\r\n      // out of vertical bountry\r\n      if (__enableScrollY) {\r\n        if (scroller.__scrollTop < 0) {\r\n          outerTop = -scroller.__scrollTop;\r\n        } else if (scroller.__scrollTop > scroller.__maxScrollTop) {\r\n          outerTop = scroller.__scrollTop - scroller.__maxScrollTop;\r\n        }\r\n      }\r\n      heightPercentage = (clientHeight * 100) / (contentHeight + outerTop);\r\n      widthPercentage = (clientWidth * 100) / (contentWidth + outerLeft);\r\n      const scrollTop = Math.min(\r\n        Math.max(0, scroller.__scrollTop),\r\n        scroller.__maxScrollTop\r\n      );\r\n      const scrollLeft = Math.min(\r\n        Math.max(0, scroller.__scrollLeft),\r\n        scroller.__maxScrollLeft\r\n      );\r\n      this.bar.vBar.state.posValue =\r\n        ((scrollTop + outerTop) * 100) / vuescroll.clientHeight;\r\n      this.bar.hBar.state.posValue =\r\n        ((scrollLeft + outerLeft) * 100) / vuescroll.clientWidth;\r\n      /* istanbul ignore if */\r\n      if (scroller.__scrollLeft < 0) {\r\n        this.bar.hBar.state.posValue = 0;\r\n      }\r\n      if (scroller.__scrollTop < 0) {\r\n        this.bar.vBar.state.posValue = 0;\r\n      }\r\n      this.bar.vBar.state.size =\r\n        heightPercentage < 100 ? heightPercentage + '%' : 0;\r\n      this.bar.hBar.state.size =\r\n        widthPercentage < 100 ? widthPercentage + '%' : 0;\r\n    },\r\n    registryEvent(type) {\r\n      const domName = type == 'refresh' ? 'refreshDom' : 'loadDom';\r\n      const activateFunc =\r\n        type == 'refresh'\r\n          ? this.scroller.activatePullToRefresh\r\n          : this.scroller.activatePushToLoad;\r\n      const stageName = type == 'refresh' ? 'refreshStage' : 'loadStage';\r\n      const tipDom = this.$refs[domName].elm || this.$refs[domName];\r\n      const cbs = createStateCallbacks(type, stageName, this, tipDom);\r\n      const height = tipDom.offsetHeight;\r\n      activateFunc.bind(this.scroller)(height, cbs);\r\n    }\r\n  }\r\n};\r\n","import { modes } from './constants';\r\nimport { error } from '../util';\r\nexport default {\r\n  // vuescroll\r\n  vuescroll: {\r\n    mode: 'native',\r\n    // vuescroll's size(height/width) should be a percent(100%)\r\n    // or be a number that is equal to its parentNode's width or\r\n    // height ?\r\n    sizeStrategy: 'percent',\r\n    // pullRefresh or pushLoad is only for the slide mode...\r\n    pullRefresh: {\r\n      enable: false,\r\n      tips: {\r\n        deactive: 'Pull to Refresh',\r\n        active: 'Release to Refresh',\r\n        start: 'Refreshing...',\r\n        beforeDeactive: 'Refresh Successfully!'\r\n      }\r\n    },\r\n    pushLoad: {\r\n      enable: false,\r\n      tips: {\r\n        deactive: 'Push to Load',\r\n        active: 'Release to Load',\r\n        start: 'Loading...',\r\n        beforeDeactive: 'Load Successfully!'\r\n      }\r\n    },\r\n    paging: false,\r\n    zooming: true,\r\n    snapping: {\r\n      enable: false,\r\n      width: 100,\r\n      height: 100\r\n    },\r\n    // some scroller options\r\n    scroller: {\r\n      /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\r\n      bouncing: true,\r\n      /** Enable locking to the main axis if user moves only slightly on one of them at start */\r\n      locking: true,\r\n      /** Minimum zoom level */\r\n      minZoom: 0.5,\r\n      /** Maximum zoom level */\r\n      maxZoom: 3,\r\n      /** Multiply or decrease scrolling speed **/\r\n      speedMultiplier: 1,\r\n      /** This configures the amount of change applied to deceleration when reaching boundaries  **/\r\n      penetrationDeceleration: 0.03,\r\n      /** This configures the amount of change applied to acceleration when reaching boundaries  **/\r\n      penetrationAcceleration: 0.08,\r\n      /** Whether call e.preventDefault event when sliding the content or not */\r\n      preventDefault: true\r\n    }\r\n  },\r\n  scrollPanel: {\r\n    // when component mounted.. it will automatically scrolls.\r\n    initialScrollY: false,\r\n    initialScrollX: false,\r\n    // feat: #11\r\n    scrollingX: true,\r\n    scrollingY: true,\r\n    speed: 300,\r\n    easing: undefined\r\n  },\r\n  //\r\n  scrollContent: {\r\n    padding: false\r\n  },\r\n  //\r\n  rail: {\r\n    vRail: {\r\n      width: '6px',\r\n      pos: 'right',\r\n      background: '#01a99a',\r\n      opacity: 0\r\n    },\r\n    //\r\n    hRail: {\r\n      height: '6px',\r\n      pos: 'bottom',\r\n      background: '#01a99a',\r\n      opacity: 0\r\n    }\r\n  },\r\n  bar: {\r\n    showDelay: 500,\r\n    onlyShowBarOnScroll: true,\r\n    vBar: {\r\n      background: '#00a650',\r\n      keepShow: false,\r\n      opacity: 1,\r\n      hover: false\r\n    },\r\n    //\r\n    hBar: {\r\n      background: '#00a650',\r\n      keepShow: false,\r\n      opacity: 1,\r\n      hover: false\r\n    }\r\n  }\r\n};\r\n/**\r\n * validate the options\r\n *\r\n * @export\r\n * @param {any} ops\r\n */\r\nexport function validateOptions(ops) {\r\n  let shouldStopRender = false;\r\n  const { vuescroll, scrollPanel } = ops;\r\n\r\n  // validate vuescroll\r\n  if (!~modes.indexOf(vuescroll.mode)) {\r\n    error(`The vuescroll's option \"mode\" should be one of the ${modes}`);\r\n    shouldStopRender = true;\r\n  }\r\n\r\n  if (\r\n    vuescroll.paging == vuescroll.snapping.enable &&\r\n    vuescroll.paging &&\r\n    (vuescroll.pullRefresh || vuescroll.pushLoad)\r\n  ) {\r\n    error(\r\n      'paging, snapping, (pullRefresh with pushLoad) can only one of them to be true.'\r\n    );\r\n  }\r\n  // validate scrollPanel\r\n  const initialScrollY = scrollPanel['initialScrollY'];\r\n  const initialScrollX = scrollPanel['initialScrollX'];\r\n\r\n  if (initialScrollY && !String(initialScrollY).match(/^\\d+(\\.\\d+)?(%)?$/)) {\r\n    error(\r\n      'The prop `initialScrollY` should be a percent number like 10% or an exact number that greater than or equal to 0 like 100.'\r\n    );\r\n  }\r\n\r\n  if (initialScrollX && !String(initialScrollX).match(/^\\d+(\\.\\d+)?(%)?$/)) {\r\n    error(\r\n      'The prop `initialScrollX` should be a percent number like 10% or an exact number that greater than or equal to 0 like 100.'\r\n    );\r\n  }\r\n\r\n  return shouldStopRender;\r\n}\r\n","import GCF, { validateOptions } from '../shared/global-config';\r\nimport { deepMerge, defineReactive } from '../util';\r\n\r\n/**\r\n * hack the lifeCycle\r\n *\r\n * to merge the global data into user-define data\r\n */\r\nfunction hackPropsData() {\r\n  const vm = this;\r\n  if (vm.$options.name === 'vueScroll') {\r\n    const _gfc = deepMerge(vm.$vuescrollConfig, {});\r\n    const ops = deepMerge(GCF, _gfc);\r\n    vm.$options.propsData.ops = vm.$options.propsData.ops || {};\r\n    Object.keys(vm.$options.propsData.ops).forEach(key => {\r\n      {\r\n        defineReactive(vm.mergedOptions, key, vm.$options.propsData.ops);\r\n      }\r\n    });\r\n    // from ops to mergedOptions\r\n    deepMerge(ops, vm.mergedOptions);\r\n\r\n    const prefix = 'padding-';\r\n    defineReactive(vm.mergedOptions.scrollContent, 'paddPos', () => {\r\n      return prefix + vm.mergedOptions.rail.vRail.pos;\r\n    });\r\n    defineReactive(vm.mergedOptions.scrollContent, 'paddValue', () => {\r\n      return vm.mergedOptions.rail.vRail.width;\r\n    });\r\n  }\r\n}\r\nexport default {\r\n  data() {\r\n    return {\r\n      shouldStopRender: false,\r\n      mergedOptions: {\r\n        vuescroll: {},\r\n        scrollPanel: {},\r\n        scrollContent: {},\r\n        rail: {},\r\n        bar: {}\r\n      }\r\n    };\r\n  },\r\n  created() {\r\n    hackPropsData.call(this);\r\n\r\n    this._isVuescrollRoot = true;\r\n\r\n    this.renderError = validateOptions(this.mergedOptions);\r\n  }\r\n};\r\n","import {\r\n  createEasingFunction,\r\n  easingPattern\r\n} from '../third-party/easingPattern';\r\nimport { core } from '../third-party/scroller/animate';\r\nimport { warn, isChildInParent } from '../util';\r\n\r\nconst vsInstances = {};\r\n\r\nexport function refreshAll() {\r\n  for (let vs in vsInstances) {\r\n    vsInstances[vs].refresh();\r\n  }\r\n}\r\n\r\nfunction getNumericValue(distance, size) {\r\n  let number;\r\n  if (!(number = /(-?\\d+(?:\\.\\d+?)?)%$/.exec(distance))) {\r\n    number = distance - 0;\r\n  } else {\r\n    number = number[1] - 0;\r\n    number = (size * number) / 100;\r\n  }\r\n  return number;\r\n}\r\n\r\nfunction goScrolling(elm, deltaX, deltaY, speed, easing, scrollingComplete) {\r\n  const startLocationY = elm['scrollTop'];\r\n  const startLocationX = elm['scrollLeft'];\r\n  let positionX = startLocationX;\r\n  let positionY = startLocationY;\r\n  /**\r\n   * keep the limit of scroll delta.\r\n   */\r\n  /* istanbul ignore next */\r\n  if (startLocationY + deltaY < 0) {\r\n    deltaY = -startLocationY;\r\n  }\r\n  const scrollHeight = elm['scrollHeight'];\r\n  if (startLocationY + deltaY > scrollHeight) {\r\n    deltaY = scrollHeight - startLocationY;\r\n  }\r\n  if (startLocationX + deltaX < 0) {\r\n    deltaX = -startLocationX;\r\n  }\r\n  if (startLocationX + deltaX > elm['scrollWidth']) {\r\n    deltaX = elm['scrollWidth'] - startLocationX;\r\n  }\r\n\r\n  const easingMethod = createEasingFunction(easing, easingPattern);\r\n\r\n  const stepCallback = percentage => {\r\n    positionX = startLocationX + deltaX * percentage;\r\n    positionY = startLocationY + deltaY * percentage;\r\n    elm['scrollTop'] = Math.floor(positionY);\r\n    elm['scrollLeft'] = Math.floor(positionX);\r\n  };\r\n\r\n  const verifyCallback = () => {\r\n    return (\r\n      Math.abs(positionY - startLocationY) <= Math.abs(deltaY) ||\r\n      Math.abs(positionX - startLocationX) <= Math.abs(deltaX)\r\n    );\r\n  };\r\n\r\n  core.effect.Animate.start(\r\n    stepCallback,\r\n    verifyCallback,\r\n    scrollingComplete,\r\n    speed,\r\n    easingMethod\r\n  );\r\n}\r\n\r\nexport default {\r\n  mounted() {\r\n    vsInstances[this._uid] = this;\r\n  },\r\n  beforeDestroy() {\r\n    delete vsInstances[this._uid];\r\n  },\r\n  methods: {\r\n    // public api\r\n    scrollTo({ x, y }, animate = true, force = false) {\r\n      if (typeof x === 'undefined') {\r\n        x = this.vuescroll.state.internalScrollLeft || 0;\r\n      } else {\r\n        x = getNumericValue(x, this.scrollPanelElm.scrollWidth);\r\n      }\r\n      if (typeof y === 'undefined') {\r\n        y = this.vuescroll.state.internalScrollTop || 0;\r\n      } else {\r\n        y = getNumericValue(y, this.scrollPanelElm.scrollHeight);\r\n      }\r\n      this.internalScrollTo(x, y, animate, force);\r\n    },\r\n    scrollBy({ dx = 0, dy = 0 }, animate = true) {\r\n      let {\r\n        internalScrollLeft = 0,\r\n        internalScrollTop = 0\r\n      } = this.vuescroll.state;\r\n      if (dx) {\r\n        internalScrollLeft += getNumericValue(\r\n          dx,\r\n          this.scrollPanelElm.scrollWidth\r\n        );\r\n      }\r\n      if (dy) {\r\n        internalScrollTop += getNumericValue(\r\n          dy,\r\n          this.scrollPanelElm.scrollHeight\r\n        );\r\n      }\r\n      this.internalScrollTo(internalScrollLeft, internalScrollTop, animate);\r\n    },\r\n    zoomBy(factor, animate, originLeft, originTop, callback) {\r\n      if (this.mode != 'slide') {\r\n        warn('zoomBy and zoomTo are only for slide mode!');\r\n        return;\r\n      }\r\n      this.scroller.zoomBy(factor, animate, originLeft, originTop, callback);\r\n    },\r\n    zoomTo(level, animate = false, originLeft, originTop, callback) {\r\n      if (this.mode != 'slide') {\r\n        warn('zoomBy and zoomTo are only for slide mode!');\r\n        return;\r\n      }\r\n      this.scroller.zoomTo(level, animate, originLeft, originTop, callback);\r\n    },\r\n    getCurrentPage() {\r\n      if (this.mode != 'slide' || !this.mergedOptions.vuescroll.paging) {\r\n        warn(\r\n          'getCurrentPage and goToPage are only for slide mode and paging is enble!'\r\n        );\r\n        return;\r\n      }\r\n      return this.scroller.getCurrentPage();\r\n    },\r\n    goToPage(dest, animate = false) {\r\n      if (this.mode != 'slide' || !this.mergedOptions.vuescroll.paging) {\r\n        warn(\r\n          'getCurrentPage and goToPage are only for slide mode and paging is enble!'\r\n        );\r\n        return;\r\n      }\r\n      this.scroller.goToPage(dest, animate);\r\n    },\r\n    triggerRefreshOrLoad(type) {\r\n      if (this.mode != 'slide') {\r\n        warn('You can only use triggerRefreshOrLoad in slide mode!');\r\n        return;\r\n      }\r\n      const isRefresh = this.mergedOptions.vuescroll.pullRefresh.enable;\r\n      const isLoad = this.mergedOptions.vuescroll.pushLoad.enable;\r\n      if (type == 'refresh' && !isRefresh) {\r\n        warn('refresh must be enabled!');\r\n        return;\r\n      } else if (type == 'load' && !isLoad) {\r\n        warn('load must be enabled and content\\'s height > container\\'s height!');\r\n        return;\r\n      } else if (type !== 'refresh' && type !== 'load') {\r\n        warn('param must be one of load and refresh!');\r\n        return;\r\n      }\r\n      /* istanbul ignore if */\r\n      if (this.vuescroll.state[`${type}Stage`] == 'start') {\r\n        return;\r\n      }\r\n      this.scroller.triggerRefreshOrLoad(type);\r\n      return true;\r\n    },\r\n    getCurrentviewDom() {\r\n      const parent =\r\n        this.mode == 'slide' || this.mode == 'pure-native'\r\n          ? this.scrollPanelElm\r\n          : this.scrollContentElm;\r\n      const children = parent.children;\r\n      const domFragment = [];\r\n      const isCurrentview = dom => {\r\n        const { left, top, width, height } = dom.getBoundingClientRect();\r\n        const {\r\n          left: parentLeft,\r\n          top: parentTop,\r\n          height: parentHeight,\r\n          width: parentWidth\r\n        } = this.$el.getBoundingClientRect();\r\n        if (\r\n          left - parentLeft + width > 0 &&\r\n          left - parentLeft < parentWidth &&\r\n          top - parentTop + height > 0 &&\r\n          top - parentTop < parentHeight\r\n        ) {\r\n          return true;\r\n        }\r\n        return false;\r\n      };\r\n\r\n      for (let i = 0; i < children.length; i++) {\r\n        const dom = children.item(i);\r\n        if (isCurrentview(dom) && !dom.isResizeElm) {\r\n          domFragment.push(dom);\r\n        }\r\n      }\r\n\r\n      return domFragment;\r\n    },\r\n    // private api\r\n    internalScrollTo(destX, destY, animate, force) {\r\n      if (this.mode == 'native' || this.mode == 'pure-native') {\r\n        if (animate) {\r\n          // hadnle for scroll complete\r\n          const scrollingComplete = this.scrollingComplete.bind(this);\r\n\r\n          goScrolling(\r\n            this.$refs['scrollPanel'].$el,\r\n            destX - this.$refs['scrollPanel'].$el.scrollLeft,\r\n            destY - this.$refs['scrollPanel'].$el.scrollTop,\r\n            this.mergedOptions.scrollPanel.speed,\r\n            this.mergedOptions.scrollPanel.easing,\r\n            scrollingComplete\r\n          );\r\n        } else {\r\n          this.$refs['scrollPanel'].$el.scrollTop = destY;\r\n          this.$refs['scrollPanel'].$el.scrollLeft = destX;\r\n        }\r\n      }\r\n      // for non-native we use scroller's scorllTo\r\n      else if (this.mode == 'slide') {\r\n        this.scroller.scrollTo(destX, destY, animate, undefined, force);\r\n      }\r\n    },\r\n    scrollIntoView(elm, animate = true) {\r\n      const parentElm = this.$el;\r\n      if (typeof elm === 'string') {\r\n        elm = parentElm.querySelector(elm);\r\n      }\r\n      if (!isChildInParent(elm, parentElm)) {\r\n        warn(\r\n          'The element or selector you passed is not the element of Vuescroll, please pass the element that is in Vuescroll to scrollIntoView API. '\r\n        );\r\n        return;\r\n      }\r\n      // parent elm left, top\r\n      const { left, top } = this.$el.getBoundingClientRect();\r\n      // child elm left, top\r\n      const { left: childLeft, top: childTop } = elm.getBoundingClientRect();\r\n\r\n      const diffX = left - childLeft;\r\n      const diffY = top - childTop;\r\n\r\n      this.scrollBy(\r\n        {\r\n          dx: -diffX,\r\n          dy: -diffY\r\n        },\r\n        animate\r\n      );\r\n    },\r\n    refresh() {\r\n      this.refreshInternalStatus();\r\n    },\r\n    // Get your scroll times!\r\n    getScrollingTimes() {\r\n      return this.vuescroll.state.scrollingTimes;\r\n    },\r\n    // Clear your scroll times!\r\n    clearScrollingTimes() {\r\n      this.vuescroll.state.scrollingTimes = 0;\r\n    }\r\n  }\r\n};\r\n","// detect content size change\r\nimport { eventCenter, isIE } from '../../util';\r\nexport function listenResize(element, callback) {\r\n  return injectObject(element, callback);\r\n}\r\n\r\nfunction injectObject(element, callback) {\r\n  if (element.hasResized) {\r\n    return;\r\n  }\r\n\r\n  var OBJECT_STYLE =\r\n    'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; padding: 0; margin: 0; opacity: 0; z-index: -1000; pointer-events: none;';\r\n  // define a wrap due to ie's zIndex bug\r\n  var objWrap = document.createElement('div');\r\n  objWrap.style.cssText = OBJECT_STYLE;\r\n  var object = document.createElement('object');\r\n  object.style.cssText = OBJECT_STYLE;\r\n  object.type = 'text/html';\r\n  object.tabIndex = -1;\r\n  object.onload = () => {\r\n    eventCenter(object.contentDocument.defaultView, 'resize', callback);\r\n  };\r\n  // https://github.com/wnr/element-resize-detector/blob/aafe9f7ea11d1eebdab722c7c5b86634e734b9b8/src/detection-strategy/object.js#L159\r\n  if (!isIE()) {\r\n    object.data = 'about:blank';\r\n  }\r\n  objWrap.isResizeElm = true;\r\n  objWrap.appendChild(object);\r\n  element.appendChild(objWrap);\r\n  if (isIE()) {\r\n    object.data = 'about:blank';\r\n  }\r\n  return function destroy() {\r\n    if (object.contentDocument) {\r\n      eventCenter(\r\n        object.contentDocument.defaultView,\r\n        'resize',\r\n        callback,\r\n        'off'\r\n      );\r\n    }\r\n    element.removeChild(objWrap);\r\n    element.hasResized = false;\r\n  };\r\n}\r\n","export default {\r\n  vertical: {\r\n    size: 'height',\r\n    opsSize: 'width',\r\n    posName: 'top',\r\n    opposName: 'bottom',\r\n    page: 'pageY',\r\n    scroll: 'scrollTop',\r\n    scrollSize: 'scrollHeight',\r\n    offset: 'offsetHeight',\r\n    client: 'clientY',\r\n    axis: 'Y'\r\n  },\r\n  horizontal: {\r\n    size: 'width',\r\n    opsSize: 'height',\r\n    posName: 'left',\r\n    opposName: 'right',\r\n    page: 'pageX',\r\n    scroll: 'scrollLeft',\r\n    scrollSize: 'scrollWidth',\r\n    offset: 'offsetWidth',\r\n    client: 'clientX',\r\n    axis: 'X'\r\n  }\r\n};\r\n","import scrollMap from '../../shared/scroll-map';\r\nimport { eventCenter, isSupportTouch, getRealParent } from '../../util';\r\n\r\nconst colorCache = {};\r\nconst rgbReg = /rgb\\(/;\r\nconst extractRgbColor = /rgb\\((.*)\\)/;\r\n\r\n/* istanbul ignore next */\r\nfunction createMouseEvent(ctx) {\r\n  const parent = getRealParent(ctx);\r\n\r\n  function mousedown(e) {\r\n    e.stopImmediatePropagation();\r\n    document.onselectstart = () => false;\r\n    ctx.axisStartPos =\r\n      e[ctx.bar.client] -\r\n      ctx.$refs['inner'].getBoundingClientRect()[ctx.bar.posName];\r\n    // tell parent that the mouse has been down.\r\n    ctx.$emit('setBarClick', true);\r\n    eventCenter(document, 'mousemove', mousemove);\r\n    eventCenter(document, 'mouseup', mouseup);\r\n  }\r\n  function mousemove(e) {\r\n    if (!ctx.axisStartPos) {\r\n      return;\r\n    }\r\n    const delta =\r\n      e[ctx.bar.client] - ctx.$el.getBoundingClientRect()[ctx.bar.posName];\r\n    const percent = (delta - ctx.axisStartPos) / ctx.$el[ctx.bar.offset];\r\n    parent.scrollTo(\r\n      {\r\n        [ctx.bar.axis.toLowerCase()]:\r\n          parent.scrollPanelElm[ctx.bar.scrollSize] * percent\r\n      },\r\n      false\r\n    );\r\n  }\r\n  function mouseup() {\r\n    ctx.$emit('setBarClick', false);\r\n    document.onselectstart = null;\r\n    parent.hideBar();\r\n    ctx.axisStartPos = 0;\r\n    eventCenter(document, 'mousemove', mousemove, false, 'off');\r\n    eventCenter(document, 'mouseup', mouseup, false, 'off');\r\n  }\r\n\r\n  return mousedown;\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction createTouchEvent(ctx) {\r\n  const parent = getRealParent(ctx);\r\n\r\n  function touchstart(e) {\r\n    e.stopImmediatePropagation();\r\n    e.preventDefault();\r\n\r\n    document.onselectstart = () => false;\r\n\r\n    ctx.axisStartPos =\r\n      e.touches[0][ctx.bar.client] -\r\n      ctx.$refs['inner'].getBoundingClientRect()[ctx.bar.posName];\r\n\r\n    // tell parent that the mouse has been down.\r\n    ctx.$emit('setBarClick', true);\r\n    eventCenter(document, 'touchmove', touchmove);\r\n    eventCenter(document, 'touchend', touchend);\r\n  }\r\n  function touchmove(e) {\r\n    if (!ctx.axisStartPos) {\r\n      return;\r\n    }\r\n    const delta =\r\n      e.touches[0][ctx.bar.client] -\r\n      ctx.$el.getBoundingClientRect()[ctx.bar.posName];\r\n    const percent = (delta - ctx.axisStartPos) / ctx.$el[ctx.bar.offset];\r\n    parent.scrollTo(\r\n      {\r\n        [ctx.bar.axis.toLowerCase()]:\r\n          parent.scrollPanelElm[ctx.bar.scrollSize] * percent\r\n      },\r\n      false\r\n    );\r\n  }\r\n  function touchend() {\r\n    ctx.$emit('setBarClick', false);\r\n    document.onselectstart = null;\r\n    parent.hideBar();\r\n    ctx.axisStartPos = 0;\r\n    eventCenter(document, 'touchmove', touchmove, false, 'off');\r\n    eventCenter(document, 'touchend', touchend, false, 'off');\r\n  }\r\n  return touchstart;\r\n}\r\n\r\n// Transform a common color int oa `rgbA` color\r\nfunction getRgbAColor(color, opacity) {\r\n  const id = color + '&' + opacity;\r\n  if (colorCache[id]) {\r\n    return colorCache[id];\r\n  }\r\n\r\n  const div = document.createElement('div');\r\n  div.style.background = color;\r\n  document.body.appendChild(div);\r\n  const computedColor = window.getComputedStyle(div).backgroundColor;\r\n  document.body.removeChild(div);\r\n\r\n  /* istanbul ignore if */\r\n  if (!rgbReg.test(computedColor)) {\r\n    return color;\r\n  }\r\n\r\n  return (colorCache[id] = `rgba(${\r\n    extractRgbColor.exec(computedColor)[1]\r\n  }, ${opacity})`);\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction handleClickTrack(e) {\r\n  const ctx = this;\r\n  const parent = getRealParent(this);\r\n  const { client, offset, posName, axis } = ctx.bar;\r\n  const inner = ctx.$refs['inner'];\r\n  const barOffset = inner[offset];\r\n  const percent =\r\n    (e[client] -\r\n      e.currentTarget.getBoundingClientRect()[posName] -\r\n      barOffset / 2) /\r\n    e.currentTarget[offset];\r\n\r\n  parent.scrollTo({\r\n    [axis.toLowerCase()]: percent * 100 + '%'\r\n  });\r\n}\r\n\r\nexport default {\r\n  name: 'bar',\r\n  props: {\r\n    ops: {\r\n      type: Object,\r\n      required: true\r\n    },\r\n    state: {\r\n      type: Object,\r\n      required: true\r\n    },\r\n    type: {\r\n      type: String,\r\n      required: true\r\n    }\r\n  },\r\n  computed: {\r\n    bar() {\r\n      return scrollMap[this.type];\r\n    }\r\n  },\r\n  render(h) {\r\n    const vm = this;\r\n    const railBackgroundColor = getRgbAColor(\r\n      vm.ops.rail.background,\r\n      vm.ops.rail.opacity\r\n    );\r\n    let style = {\r\n      [vm.bar.size]: vm.state.size,\r\n      background: vm.ops.bar.background,\r\n      opacity: vm.state.opacity,\r\n      transform: `translate${scrollMap[vm.type].axis}(${vm.state.posValue}%)`\r\n    };\r\n    const bar = {\r\n      style: style,\r\n      class: `__bar-is-${vm.type}`,\r\n      ref: 'inner',\r\n      on: {}\r\n    };\r\n\r\n    /* istanbul ignore if */\r\n    if (vm.ops.bar.hover) {\r\n      bar.on['mouseenter'] = () => {\r\n        vm.$el.style.background = vm.ops.hover;\r\n      };\r\n      bar.on['mouseleave'] = () => {\r\n        vm.$el.style.background = vm.ops.background;\r\n      };\r\n    }\r\n    /* istanbul ignore if */\r\n    if (isSupportTouch()) {\r\n      bar.on['touchstart'] = createTouchEvent(this);\r\n    } else {\r\n      bar.on['mousedown'] = createMouseEvent(this);\r\n    }\r\n\r\n    const rail = {\r\n      class: `__rail-is-${vm.type}`,\r\n      style: {\r\n        borderRadius: vm.ops.rail[vm.bar.opsSize],\r\n        background: railBackgroundColor,\r\n        [vm.bar.opsSize]: vm.ops.rail[vm.bar.opsSize],\r\n        [vm.ops.rail.pos]: '2px'\r\n      },\r\n      on: {\r\n        click(e) /* istanbul ignore next */ {\r\n          handleClickTrack.call(vm, e);\r\n        }\r\n      }\r\n    };\r\n\r\n    return (\r\n      <div {...rail}>\r\n        <div {...bar} />\r\n      </div>\r\n    );\r\n  }\r\n};\r\n\r\n/**\r\n * create bars\r\n *\r\n * @param {any} size\r\n * @param {any} type\r\n */\r\nexport function createBar(h, vm, type) {\r\n  const axis = type === 'vertical' ? 'Y' : 'X';\r\n  const barType = `${type.charAt(0)}Bar`;\r\n  const railType = `${type.charAt(0)}Rail`;\r\n\r\n  if (\r\n    !vm.bar[barType].state.size ||\r\n    !vm.mergedOptions.scrollPanel['scrolling' + axis] ||\r\n    vm.mode == 'pure-native' ||\r\n    (vm.refreshLoad && type !== 'vertical' && vm.mode === 'slide')\r\n  ) {\r\n    return null;\r\n  }\r\n\r\n  const barData = {\r\n    props: {\r\n      type: type,\r\n      ops: {\r\n        bar: vm.mergedOptions.bar[barType],\r\n        rail: vm.mergedOptions.rail[railType]\r\n      },\r\n      state: vm.bar[barType].state\r\n    },\r\n    on: {\r\n      setBarClick: vm.setBarClick\r\n    },\r\n    ref: `${type}Bar`\r\n  };\r\n\r\n  return <bar {...barData} />;\r\n}\r\n","// begin importing\r\nimport {\r\n  getGutter,\r\n  isSupportGivenStyle,\r\n  isIE,\r\n  insertChildrenIntoSlot,\r\n  getRealParent\r\n} from '../../util';\r\nimport { createContent } from './vuescroll-content';\r\n// vueScrollPanel\r\nexport default {\r\n  name: 'scrollPanel',\r\n  props: { ops: { type: Object, required: true } },\r\n  methods: {\r\n    // trigger scrollPanel options initialScrollX,\r\n    // initialScrollY\r\n    updateInitialScroll() {\r\n      let x = 0;\r\n      let y = 0;\r\n      const parent = getRealParent(this);\r\n      if (this.ops.initialScrollX) {\r\n        x = this.ops.initialScrollX;\r\n      }\r\n      if (this.ops.initialScrollY) {\r\n        y = this.ops.initialScrollY;\r\n      }\r\n      if (x || y) {\r\n        parent.scrollTo({ x, y });\r\n      }\r\n    }\r\n  },\r\n  mounted() {\r\n    setTimeout(() => {\r\n      if (!this._isDestroyed) {\r\n        this.updateInitialScroll();\r\n      }\r\n    }, 0);\r\n  },\r\n  render(h) {\r\n    // eslint-disable-line\r\n    let data = {\r\n      class: ['__panel']\r\n    };\r\n    const parent = getRealParent(this);\r\n    const customPanel = parent.$slots['scroll-panel'];\r\n    if (customPanel) {\r\n      return insertChildrenIntoSlot(h, customPanel, this.$slots.default, data);\r\n    }\r\n    return <div {...data}>{[this.$slots.default]}</div>;\r\n  }\r\n};\r\n\r\n/**\r\n * create a scrollPanel\r\n *\r\n * @param {any} size\r\n * @param {any} vm\r\n * @returns\r\n */\r\nexport function createPanel(h, vm) {\r\n  // scrollPanel data start\r\n  const scrollPanelData = {\r\n    ref: 'scrollPanel',\r\n    style: {},\r\n    class: [],\r\n    nativeOn: {\r\n      scroll: vm.handleScroll\r\n    },\r\n    props: {\r\n      ops: vm.mergedOptions.scrollPanel\r\n    }\r\n  };\r\n  // set overflow only if the in native mode\r\n  if (vm.mode == 'native') {\r\n    scrollPanelData.class.push('__native');\r\n    // dynamic set overflow scroll\r\n    // feat: #11\r\n    if (vm.mergedOptions.scrollPanel.scrollingY) {\r\n      scrollPanelData.style['overflowY'] = vm.bar.vBar.state.size\r\n        ? 'scroll'\r\n        : '';\r\n    } else {\r\n      scrollPanelData.style['overflowY'] = 'hidden';\r\n    }\r\n    if (vm.mergedOptions.scrollPanel.scrollingX) {\r\n      scrollPanelData.style['overflowX'] = vm.bar.hBar.state.size\r\n        ? 'scroll'\r\n        : '';\r\n    } else {\r\n      scrollPanelData.style['overflowX'] = 'hidden';\r\n    }\r\n    let gutter = getGutter();\r\n    /* istanbul ignore if */\r\n    if (!gutter && vm.mergedOptions.vuescroll.mode != 'pure-native') {\r\n      scrollPanelData.class.push('__hidebar');\r\n    } else {\r\n      // hide system bar by use a negative value px\r\n      // gutter should be 0 when manually disable scrollingX #14\r\n      if (vm.bar.vBar.state.size && vm.mergedOptions.scrollPanel.scrollingY) {\r\n        scrollPanelData.style.marginRight = `-${gutter}px`;\r\n      }\r\n      if (vm.bar.hBar.state.size && vm.mergedOptions.scrollPanel.scrollingX) {\r\n        scrollPanelData.style.height = `calc(100% + ${gutter}px)`;\r\n      }\r\n    }\r\n    // clear legency styles of slide mode...\r\n    scrollPanelData.style.transformOrigin = '';\r\n    scrollPanelData.style.transform = '';\r\n  } else if (vm.mode == 'slide') {\r\n    scrollPanelData.class.push('__slide');\r\n    let width = isSupportGivenStyle('width', 'fit-content');\r\n    if (width) {\r\n      scrollPanelData.style['width'] = width;\r\n    } /* istanbul ignore next */ else {\r\n      // fallback to inline block while\r\n      // doesn't support 'fit-content',\r\n      // this may cause some issues, but this\r\n      // can make `resize` event work...\r\n      scrollPanelData['display'] = 'inline-block';\r\n    }\r\n  } else if (vm.mode == 'pure-native') {\r\n    scrollPanelData.class.push('__pure-native');\r\n    if (vm.mergedOptions.scrollPanel.scrollingY) {\r\n      scrollPanelData.style['overflowY'] = 'auto';\r\n    } else {\r\n      scrollPanelData.style['overflowY'] = 'hidden';\r\n    }\r\n    if (vm.mergedOptions.scrollPanel.scrollingX) {\r\n      scrollPanelData.style['overflowX'] = 'auto';\r\n    } else {\r\n      scrollPanelData.style['overflowX'] = 'hidden';\r\n    }\r\n  }\r\n  return (\r\n    <scrollPanel {...scrollPanelData}>{createPanelChildren(vm, h)}</scrollPanel>\r\n  );\r\n}\r\n\r\nfunction createPanelChildren(vm, h) {\r\n  if (vm.mode == 'native') {\r\n    return [createContent(h, vm)];\r\n  } else if (vm.mode == 'slide') {\r\n    let renderChildren = [vm.$slots.default];\r\n    // handle refresh\r\n    if (vm.mergedOptions.vuescroll.pullRefresh.enable) {\r\n      let refreshDom = null;\r\n      refreshDom = createTipDom(h, vm, 'refresh');\r\n      renderChildren.unshift(\r\n        <div class=\"__refresh\" ref=\"refreshDom\" key=\"refshDom\">\r\n          {[refreshDom, vm.pullRefreshTip]}\r\n        </div>\r\n      );\r\n    }\r\n    // handle load\r\n    if (vm.mergedOptions.vuescroll.pushLoad.enable) {\r\n      let loadDom = null;\r\n      loadDom = createTipDom(h, vm, 'load');\r\n      const enableLoad = vm.isEnableLoad();\r\n      renderChildren.push(\r\n        <div\r\n          ref=\"loadDom\"\r\n          key=\"loadDom\"\r\n          class={{ __load: true, '__load-disabled': !enableLoad }}\r\n        >\r\n          {[loadDom, vm.pushLoadTip]}\r\n        </div>\r\n      );\r\n    }\r\n    return renderChildren;\r\n  } else if (vm.mode == 'pure-native') {\r\n    return [vm.$slots.default];\r\n  }\r\n}\r\n\r\n// Create load or refresh tip dom of each stages\r\n\r\nfunction createTipDom(h, vm, type) {\r\n  const stage = vm.vuescroll.state[`${type}Stage`];\r\n  let dom = null;\r\n  /* istanbul ignore if */\r\n  if ((dom = vm.$slots[`${type}-${stage}`])) {\r\n    return dom[0];\r\n  }\r\n  switch (stage) {\r\n  case 'deactive':\r\n    dom = (\r\n      <svg\r\n        version=\"1.1\"\r\n        xmlns=\"http://www.w3.org/2000/svg\"\r\n        xmlnsXlink=\"http://www.w3.org/1999/xlink\"\r\n        x=\"0px\"\r\n        y=\"0px\"\r\n        viewBox=\"0 0 1000 1000\"\r\n        enable-background=\"new 0 0 1000 1000\"\r\n        xmlSpace=\"preserve\"\r\n      >\r\n        <metadata> Svg Vector Icons : http://www.sfont.cn </metadata>\r\n        <g>\r\n          <g transform=\"matrix(1 0 0 -1 0 1008)\">\r\n            <path d=\"M10,543l490,455l490-455L885,438L570,735.5V18H430v717.5L115,438L10,543z\" />\r\n          </g>\r\n        </g>\r\n      </svg>\r\n    );\r\n    break;\r\n  case 'start':\r\n    // IE and edge seem not supporting  tag - `animateTransform`\r\n    // Just return null.\r\n    /* istanbul ignore if */\r\n    if (isIE()) {\r\n      dom = null;\r\n      break;\r\n    }\r\n    dom = (\r\n      <svg\r\n        version=\"1.1\"\r\n        id=\"loader-1\"\r\n        xmlns=\"http://www.w3.org/2000/svg\"\r\n        xmlnsXlink=\"http://www.w3.org/1999/xlink\"\r\n        x=\"0px\"\r\n        y=\"0px\"\r\n        viewBox=\"0 0 50 50\"\r\n        style=\"enable-background:new 0 0 50 50;\"\r\n        xmlSpace=\"preserve\"\r\n      >\r\n        <path\r\n          fill=\"#000\"\r\n          d=\"M43.935,25.145c0-10.318-8.364-18.683-18.683-18.683c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615c8.072,0,14.615,6.543,14.615,14.615H43.935z\"\r\n        >\r\n          <animateTransform\r\n            attributeType=\"xml\"\r\n            attributeName=\"transform\"\r\n            type=\"rotate\"\r\n            from=\"0 25 25\"\r\n            to=\"360 25 25\"\r\n            dur=\"0.6s\"\r\n            repeatCount=\"indefinite\"\r\n          />\r\n        </path>\r\n      </svg>\r\n    );\r\n    break;\r\n  case 'active':\r\n    dom = (\r\n      <svg\r\n        version=\"1.1\"\r\n        xmlns=\"http://www.w3.org/2000/svg\"\r\n        xmlnsXlink=\"http://www.w3.org/1999/xlink\"\r\n        x=\"0px\"\r\n        y=\"0px\"\r\n        viewBox=\"0 0 1000 1000\"\r\n        enable-background=\"new 0 0 1000 1000\"\r\n        xmlSpace=\"preserve\"\r\n      >\r\n        <metadata> Svg Vector Icons : http://www.sfont.cn </metadata>\r\n        <g>\r\n          <g transform=\"matrix(1 0 0 -1 0 1008)\">\r\n            <path d=\"M500,18L10,473l105,105l315-297.5V998h140V280.5L885,578l105-105L500,18z\" />\r\n          </g>\r\n        </g>\r\n      </svg>\r\n    );\r\n    break;\r\n  }\r\n  return dom;\r\n}\r\n","import {\r\n  deepMerge,\r\n  isSupportGivenStyle,\r\n  insertChildrenIntoSlot\r\n} from '../../util';\r\n// ScrollContent, stateless, treat as a functional component\r\nexport default {\r\n  name: 'scrollContent',\r\n  functional: true,\r\n  props: {\r\n    ops: { type: Object },\r\n    state: {\r\n      type: Object,\r\n      default() {\r\n        return {};\r\n      }\r\n    }\r\n  },\r\n  render(h, { props, slots, parent }) {\r\n    let style = deepMerge(props.state.style, {});\r\n    style.position = 'relative';\r\n    let width = isSupportGivenStyle('width', 'fit-content');\r\n    if (width) {\r\n      style.width = width;\r\n    } /* istanbul ignore next */ else {\r\n      // fallback to inline block while\r\n      // doesn't support 'fit-content',\r\n      // this may cause some issues, but this\r\n      // can make `resize` event work...\r\n      style['display'] = 'inline-block';\r\n    }\r\n    style.boxSizing = 'border-box';\r\n    if (props.ops.padding) {\r\n      style[props.ops.paddPos] = props.ops.paddValue;\r\n    }\r\n\r\n    const propsData = {\r\n      style: style,\r\n      ref: 'scrollContent',\r\n      class: '__view'\r\n    };\r\n    const customContent = parent.$slots['scroll-content'];\r\n    if (customContent) {\r\n      return insertChildrenIntoSlot(\r\n        h,\r\n        customContent,\r\n        slots().default,\r\n        propsData\r\n      );\r\n    }\r\n    return <div {...propsData}>{slots().default}</div>;\r\n  }\r\n};\r\n\r\n/**\r\n * create scroll content\r\n *\r\n * @param {any} size\r\n * @param {any} vm\r\n * @returns\r\n */\r\nexport function createContent(h, vm) {\r\n  const scrollContentData = {\r\n    props: {\r\n      ops: vm.mergedOptions.scrollContent\r\n    }\r\n  };\r\n  return (\r\n    <scrollContent {...scrollContentData}>{[vm.$slots.default]}</scrollContent>\r\n  );\r\n}\r\n","/* ------------------- Mix Start ---------------- */\r\n\r\n/**\r\n *  Mode mix\r\n */\r\nimport nativeMode from '../mixins/mode/native-mode';\r\nimport slideMode from '../mixins/mode/slide-mode';\r\n\r\n/**\r\n *  Lifecycle mix\r\n */\r\nimport hackLifecycle from '../mixins/hack-lifecycle';\r\n\r\n/**\r\n *  Init\r\n */\r\nimport init from '../mixins/init';\r\n\r\n/**\r\n *  Api\r\n */\r\nimport api from '../mixins/api';\r\n\r\n/**\r\n *  Computed\r\n */\r\nimport computed from '../mixins/computed';\r\n\r\n/**\r\n *  Event Hander\r\n */\r\nimport eventHelper from '../mixins/event-handler';\r\n\r\n/**\r\n *  Helper\r\n */\r\nimport helper from '../mixins/helper';\r\n\r\n/**\r\n *  Event Emitter\r\n */\r\nimport eventEmitter from '../mixins/event-emitter';\r\n\r\n/**\r\n *  Refresh Mechanism\r\n */\r\nimport refresh from '../mixins/refresh';\r\n\r\n/**\r\n *  Detect Resize Mechanism\r\n */\r\nimport resize from '../mixins/resize';\r\n\r\n/* ------------------- Mix End ---------------- */\r\n\r\n/**\r\n *  Components\r\n */\r\nimport bar, { createBar } from './child-components/vuescroll-bar';\r\nimport scrollContent from './child-components/vuescroll-content';\r\nimport scrollPanel, { createPanel } from './child-components/vuescroll-panel';\r\n\r\n/**\r\n *  Util\r\n */\r\nimport { isSupportTouch, insertChildrenIntoSlot } from '../util';\r\n\r\nconst vueScrollCore = {\r\n  name: 'vueScroll',\r\n  components: { bar, scrollContent, scrollPanel },\r\n  props: {\r\n    ops: { type: Object }\r\n  },\r\n  mixins: [\r\n    hackLifecycle,\r\n    api,\r\n    nativeMode,\r\n    slideMode,\r\n    computed,\r\n    eventEmitter,\r\n    eventHelper,\r\n    helper,\r\n    init,\r\n    refresh,\r\n    resize\r\n  ],\r\n  mounted() {\r\n    if (!this.renderError) {\r\n      this.initVariables();\r\n\r\n      this.initWatchOpsChange();\r\n\r\n      this.refreshInternalStatus();\r\n\r\n      this.$nextTick(() => {\r\n        if (!this._isDestroyed) {\r\n          // update again to ensure bar's size is correct.\r\n          this.updateBarStateAndEmitEvent();\r\n          // update scroller again since we get real dom.\r\n          if (this.mode == 'slide') {\r\n            this.updateScroller();\r\n          }\r\n          this.scrollToAnchor();\r\n        }\r\n      }, 0);\r\n    }\r\n  },\r\n  updated() {\r\n    this.vuescroll.updatedCbs.forEach(cb => {\r\n      cb.call(this);\r\n    });\r\n    // Clear\r\n    this.vuescroll.updatedCbs = [];\r\n  },\r\n  beforeDestroy() {\r\n    // remove registryed resize\r\n    if (this.destroyParentDomResize) {\r\n      this.destroyParentDomResize();\r\n      this.destroyParentDomResize = null;\r\n    }\r\n    if (this.destroyResize) {\r\n      this.destroyResize();\r\n      this.destroyResize = null;\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      /**\r\n       * @description\r\n       * In state props of each components, we store the states of each\r\n       * components, and in mergedOptions props, we store the options\r\n       * that are megred from user-defined options to default options.\r\n       * @author wangyi7099\r\n       * @returns\r\n       */\r\n      vuescroll: {\r\n        state: {\r\n          isDragging: false,\r\n          isClickingBar: false,\r\n          pointerLeave: true,\r\n          internalScrollTop: 0,\r\n          internalScrollLeft: 0,\r\n          posX: null,\r\n          posY: null,\r\n          refreshStage: 'deactive',\r\n          loadStage: 'deactive',\r\n          height: '100%',\r\n          width: '100%',\r\n          scrollingTimes: 0\r\n        },\r\n        updatedCbs: []\r\n      },\r\n      bar: {\r\n        vBar: {\r\n          state: {\r\n            posValue: 0,\r\n            size: 0,\r\n            opacity: 0\r\n          }\r\n        },\r\n        hBar: {\r\n          state: {\r\n            posValue: 0,\r\n            size: 0,\r\n            opacity: 0\r\n          }\r\n        },\r\n        renderError: false\r\n      }\r\n    };\r\n  },\r\n  render(h) {\r\n    let vm = this;\r\n    if (vm.renderError) {\r\n      return <div>{[vm.$slots['default']]}</div>;\r\n    }\r\n    // vuescroll data\r\n    const vuescrollData = {\r\n      style: {\r\n        height: vm.vuescroll.state.height,\r\n        width: vm.vuescroll.state.width,\r\n        padding: 0\r\n      },\r\n      class: '__vuescroll'\r\n    };\r\n    if (!isSupportTouch()) {\r\n      vuescrollData.on = {\r\n        mouseenter() {\r\n          vm.vuescroll.state.pointerLeave = false;\r\n          vm.updateBarStateAndEmitEvent();\r\n        },\r\n        mouseleave() {\r\n          vm.vuescroll.state.pointerLeave = true;\r\n          vm.hideBar();\r\n        },\r\n        mousemove() /* istanbul ignore next */ {\r\n          vm.vuescroll.state.pointerLeave = false;\r\n          vm.updateBarStateAndEmitEvent();\r\n        }\r\n      };\r\n    } /* istanbul ignore next */ else {\r\n      vuescrollData.on = {\r\n        touchstart() {\r\n          vm.vuescroll.state.pointerLeave = false;\r\n          vm.updateBarStateAndEmitEvent();\r\n        },\r\n        touchend() {\r\n          vm.vuescroll.state.pointerLeave = true;\r\n          vm.hideBar();\r\n        },\r\n        touchmove() /* istanbul ignore next */ {\r\n          vm.vuescroll.state.pointerLeave = false;\r\n          vm.updateBarStateAndEmitEvent();\r\n        }\r\n      };\r\n    }\r\n    const customContainer = this.$slots['scroll-container'];\r\n    const ch = [\r\n      createPanel(h, vm),\r\n      createBar(h, vm, 'vertical'),\r\n      createBar(h, vm, 'horizontal')\r\n    ];\r\n\r\n    if (customContainer) {\r\n      return insertChildrenIntoSlot(h, customContainer, ch, vuescrollData);\r\n    }\r\n    return <div {...vuescrollData}>{ch}</div>;\r\n  }\r\n};\r\n\r\nexport default vueScrollCore;\r\n","import {getPrefix} from '../../util';\r\n\r\n/* DOM-based rendering (Uses 3D when available, falls back on margin when transform not available) */\r\nexport function render(content, global, suffix, value) {\r\n  var x = null;\r\n  var y = null;\r\n\r\n  if (typeof content == 'string') {\r\n    y = content == 'vertical' ? (x = 0) || value : (x = value) && 0;\r\n  }\r\n\r\n  var vendorPrefix = getPrefix(global);\r\n\r\n  var helperElem = document.createElement('div');\r\n  var undef;\r\n\r\n  var perspectiveProperty = vendorPrefix + 'Perspective';\r\n  var transformProperty = 'transform'; //vendorPrefix + 'Transform';\r\n\r\n  if (helperElem.style[perspectiveProperty] !== undef) {\r\n    if (typeof content == 'string') {\r\n      return {\r\n        [transformProperty]:\r\n          'translate3d(' + x + suffix + ',' + y + suffix + ',0)'\r\n      };\r\n    }\r\n    return function(left, top, zoom) {\r\n      content.style[transformProperty] =\r\n        'translate3d(' +\r\n        -left +\r\n        suffix +\r\n        ',' +\r\n        -top +\r\n        suffix +\r\n        ',0) scale(' +\r\n        zoom +\r\n        ')';\r\n    };\r\n  } else if (helperElem.style[transformProperty] !== undef) {\r\n    if (typeof content == 'string') {\r\n      return {\r\n        [transformProperty]: 'translate(' + x + suffix + ',' + y + suffix + ')'\r\n      };\r\n    }\r\n    return function(left, top, zoom) {\r\n      content.style[transformProperty] =\r\n        'translate(' +\r\n        -left +\r\n        suffix +\r\n        ',' +\r\n        -top +\r\n        suffix +\r\n        ') scale(' +\r\n        zoom +\r\n        ')';\r\n    };\r\n  }\r\n}\r\n","export function listenContainer(\r\n  container,\r\n  scroller,\r\n  eventCallback,\r\n  zooming,\r\n  preventDefault\r\n) {\r\n  let destroy = null;\r\n  // for touch\r\n  function touchstart(e) {\r\n    // Don't react if initial down happens on a form element\r\n    if (\r\n      e.touches[0] &&\r\n      e.touches[0].target &&\r\n      e.touches[0].target.tagName.match(/input|textarea|select/i)\r\n    ) {\r\n      return;\r\n    }\r\n    eventCallback('mousedown');\r\n    scroller.doTouchStart(e.touches, e.timeStamp);\r\n    if (preventDefault) {\r\n      e.preventDefault();\r\n    }\r\n    // here , we want to manully prevent default, so we\r\n    // set passive to false\r\n    // see https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener\r\n    document.addEventListener('touchmove', touchmove, { passive: false });\r\n  }\r\n  function touchmove(e) {\r\n    eventCallback('mousemove');\r\n    scroller.doTouchMove(e.touches, e.timeStamp, e.scale);\r\n    e.preventDefault();\r\n  }\r\n  function touchend(e) {\r\n    eventCallback('mouseup');\r\n    scroller.doTouchEnd(e.timeStamp);\r\n    document.removeEventListener('touchmove', touchmove);\r\n  }\r\n  function touchcancel(e) {\r\n    scroller.doTouchEnd(e.timeStamp);\r\n  }\r\n\r\n  // for mouse\r\n  function mousedownEvent(e) {\r\n    if (e.target.tagName.match(/input|textarea|select/i)) {\r\n      return;\r\n    }\r\n    eventCallback('mousedown');\r\n    scroller.doTouchStart(\r\n      [\r\n        {\r\n          pageX: e.pageX,\r\n          pageY: e.pageY\r\n        }\r\n      ],\r\n      e.timeStamp\r\n    );\r\n\r\n    if (preventDefault) {\r\n      e.preventDefault();\r\n    }\r\n\r\n    mousedown = true;\r\n  }\r\n  function mousemove(e) {\r\n    if (!mousedown) {\r\n      return;\r\n    }\r\n    eventCallback('mousemove');\r\n    scroller.doTouchMove(\r\n      [\r\n        {\r\n          pageX: e.pageX,\r\n          pageY: e.pageY\r\n        }\r\n      ],\r\n      e.timeStamp\r\n    );\r\n\r\n    mousedown = true;\r\n  }\r\n  function mouseup(e) {\r\n    if (!mousedown) {\r\n      return;\r\n    }\r\n    eventCallback('mouseup');\r\n    scroller.doTouchEnd(e.timeStamp);\r\n\r\n    mousedown = false;\r\n  }\r\n  function zoomHandle(e) {\r\n    scroller.doMouseZoom(\r\n      e.detail ? e.detail * -120 : e.wheelDelta,\r\n      e.timeStamp,\r\n      e.pageX,\r\n      e.pageY\r\n    );\r\n  }\r\n  if ('ontouchstart' in window) {\r\n    container.addEventListener('touchstart', touchstart, false);\r\n\r\n    document.addEventListener('touchend', touchend, false);\r\n\r\n    document.addEventListener('touchcancel', touchcancel, false);\r\n\r\n    destroy = function() {\r\n      container.removeEventListener('touchstart', touchstart, false);\r\n\r\n      document.removeEventListener('touchend', touchend, false);\r\n\r\n      document.removeEventListener('touchcancel', touchcancel, false);\r\n    };\r\n  } else {\r\n    var mousedown = false;\r\n\r\n    container.addEventListener('mousedown', mousedownEvent, false);\r\n\r\n    document.addEventListener('mousemove', mousemove, false);\r\n\r\n    document.addEventListener('mouseup', mouseup, false);\r\n    if (zooming) {\r\n      container.addEventListener(\r\n        navigator.userAgent.indexOf('Firefox') > -1\r\n          ? 'DOMMouseScroll'\r\n          : 'mousewheel',\r\n        zoomHandle,\r\n        false\r\n      );\r\n    }\r\n    // container.addEventListener(navigator.userAgent.indexOf(\"Firefox\") > -1 ? \"DOMMouseScroll\" :  \"mousewheel\", function(e) {\r\n    //     scroller.doMouseZoom(e.detail ? (e.detail * -120) : e.wheelDelta, e.timeStamp, e.pageX, e.pageY);\r\n    // }, false);\r\n    destroy = function() {\r\n      container.removeEventListener('mousedown', mousedownEvent, false);\r\n      document.removeEventListener('mousemove', mousemove, false);\r\n      document.removeEventListener('mouseup', mouseup, false);\r\n      container.removeEventListener(\r\n        navigator.userAgent.indexOf('Firefox') > -1\r\n          ? 'DOMMouseScroll'\r\n          : 'mousewheel',\r\n        zoomHandle,\r\n        false\r\n      );\r\n    };\r\n  }\r\n  // handle __publish event\r\n  scroller.onScroll = () => {\r\n    eventCallback('onscroll');\r\n  };\r\n  return destroy;\r\n}\r\n","export default {\r\n  computed: {\r\n    scrollPanelElm() {\r\n      return this.$refs['scrollPanel']._isVue\r\n        ? this.$refs['scrollPanel'].$el\r\n        : this.$refs['scrollPanel'];\r\n    },\r\n    scrollContentElm() {\r\n      return this.$refs['scrollContent']._isVue\r\n        ? this.$refs['scrollContent'].$el\r\n        : this.$refs['scrollContent'];\r\n    },\r\n    mode() {\r\n      return this.mergedOptions.vuescroll.mode;\r\n    },\r\n    pullRefreshTip() {\r\n      return this.mergedOptions.vuescroll.pullRefresh.tips[\r\n        this.vuescroll.state.refreshStage\r\n      ];\r\n    },\r\n    pushLoadTip() {\r\n      return this.mergedOptions.vuescroll.pushLoad.tips[\r\n        this.vuescroll.state.loadStage\r\n      ];\r\n    },\r\n    refreshLoad() {\r\n      return (\r\n        this.mergedOptions.vuescroll.pullRefresh.enable ||\r\n        this.mergedOptions.vuescroll.pushLoad.enable\r\n      );\r\n    }\r\n  }\r\n};\r\n","export default {\r\n  methods: {\r\n    updateBarStateAndEmitEvent(eventType, nativeEvent = null) {\r\n      if (this.mode == 'native' || this.mode == 'pure-native') {\r\n        this.updateNativeModeBarState();\r\n      } else if (this.mode == 'slide') {\r\n        if (!this.scroller) {\r\n          return;\r\n        }\r\n        this.updateSlideModeBarState();\r\n      }\r\n      if (eventType) {\r\n        this.emitEvent(eventType, nativeEvent);\r\n      }\r\n      if (this.mergedOptions.bar.onlyShowBarOnScroll) {\r\n        if (\r\n          eventType == 'handle-scroll' ||\r\n          eventType == 'handle-resize' ||\r\n          eventType == 'refresh-status' ||\r\n          eventType == 'window-resize' ||\r\n          eventType == 'options-change'\r\n        ) {\r\n          this.showAndDefferedHideBar(true);\r\n        }\r\n      } else {\r\n        this.showAndDefferedHideBar();\r\n      }\r\n    },\r\n    /**\r\n     *  emit user registry event\r\n     */\r\n    emitEvent(eventType, nativeEvent = null) {\r\n      let {\r\n        scrollHeight,\r\n        scrollWidth,\r\n        clientHeight,\r\n        clientWidth,\r\n        scrollTop,\r\n        scrollLeft\r\n      } = this.scrollPanelElm;\r\n      const vertical = {\r\n        type: 'vertical'\r\n      };\r\n      const horizontal = {\r\n        type: 'horizontal'\r\n      };\r\n      if (this.mode == 'slide') {\r\n        scrollHeight = this.scroller.__contentHeight;\r\n        scrollWidth = this.scroller.__contentWidth;\r\n        scrollTop = this.scroller.__scrollTop;\r\n        scrollLeft = this.scroller.__scrollLeft;\r\n        clientHeight = this.$el.clientHeight;\r\n        clientWidth = this.$el.clientWidth;\r\n      }\r\n      vertical['process'] = Math.min(\r\n        scrollTop / (scrollHeight - clientHeight),\r\n        1\r\n      );\r\n      horizontal['process'] = Math.min(\r\n        scrollLeft / (scrollWidth - clientWidth),\r\n        1\r\n      );\r\n      vertical['barSize'] = this.bar.vBar.state.size;\r\n      horizontal['barSize'] = this.bar.hBar.state.size;\r\n      vertical['scrollTop'] = scrollTop;\r\n      horizontal['scrollLeft'] = scrollLeft;\r\n      vertical['directionY'] = this.vuescroll.state.posY;\r\n      horizontal['directionX'] = this.vuescroll.state.posX;\r\n      this.$emit(eventType, vertical, horizontal, nativeEvent);\r\n    }\r\n  }\r\n};\r\n","export default {\r\n  methods: {\r\n    handleScroll(nativeEvent) {\r\n      this.recordCurrentPos();\r\n      this.updateBarStateAndEmitEvent('handle-scroll', nativeEvent);\r\n    },\r\n    scrollingComplete() {\r\n      this.vuescroll.state.scrollingTimes++;\r\n      this.updateBarStateAndEmitEvent('handle-scroll-complete');\r\n    },\r\n    setBarClick(val) {\r\n      /* istanbul ignore next */\r\n      this.vuescroll.state.isClickingBar = val;\r\n    }\r\n  }\r\n};\r\n","function findValuesByMode(mode, vm) {\r\n  let axis = {};\r\n  switch (mode) {\r\n  case 'native':\r\n  case 'pure-native':\r\n    axis = {\r\n      x: vm.scrollPanelElm.scrollLeft,\r\n      y: vm.scrollPanelElm.scrollTop\r\n    };\r\n    break;\r\n  case 'slide':\r\n    axis = { x: vm.scroller.__scrollLeft, y: vm.scroller.__scrollTop };\r\n    break;\r\n  }\r\n  return axis;\r\n}\r\n\r\nexport default {\r\n  methods: {\r\n    isEnableLoad() {\r\n      // Enable load only when clientHeight <= scrollHeight\r\n      if (!this._isMounted) return false;\r\n      const panelElm = this.scrollPanelElm;\r\n      const containerElm = this.$el;\r\n\r\n      /* istanbul ignore if */\r\n      if (!this.mergedOptions.vuescroll.pushLoad.enable) {\r\n        return false;\r\n      }\r\n      let loadDom = null;\r\n      if (this.$refs['loadDom']) {\r\n        loadDom = this.$refs['loadDom'].elm || this.$refs['loadDom'];\r\n      }\r\n      const loadHeight = (loadDom && loadDom.offsetHeight) || 0;\r\n      /* istanbul ignore if */\r\n      if (panelElm.scrollHeight - loadHeight <= containerElm.clientHeight) {\r\n        return false;\r\n      }\r\n      return true;\r\n    },\r\n    showAndDefferedHideBar(forceHideBar) {\r\n      this.showBar();\r\n      if (this.timeoutId) {\r\n        clearTimeout(this.timeoutId);\r\n        this.timeoutId = 0;\r\n      }\r\n      this.timeoutId = setTimeout(() => {\r\n        this.timeoutId = 0;\r\n        this.hideBar(forceHideBar);\r\n      }, this.mergedOptions.bar.showDelay);\r\n    },\r\n    showBar() {\r\n      this.bar.vBar.state.opacity = this.mergedOptions.bar.vBar.opacity;\r\n      this.bar.hBar.state.opacity = this.mergedOptions.bar.hBar.opacity;\r\n    },\r\n    hideBar(forceHideBar) {\r\n      // when in non-native mode dragging content\r\n      // in slide mode, just return\r\n      /* istanbul ignore next */\r\n      if (this.vuescroll.state.isDragging) {\r\n        return;\r\n      }\r\n\r\n      if (forceHideBar && !this.mergedOptions.bar.hBar.keepShow) {\r\n        this.bar.hBar.state.opacity = 0;\r\n      }\r\n      if (forceHideBar && !this.mergedOptions.bar.vBar.keepShow) {\r\n        this.bar.vBar.state.opacity = 0;\r\n      }\r\n      // add isClickingBar condition\r\n      // to prevent from hiding bar while dragging the bar\r\n      if (\r\n        !this.mergedOptions.bar.vBar.keepShow &&\r\n        !this.vuescroll.state.isClickingBar &&\r\n        this.vuescroll.state.pointerLeave\r\n      ) {\r\n        this.bar.vBar.state.opacity = 0;\r\n      }\r\n      if (\r\n        !this.mergedOptions.bar.hBar.keepShow &&\r\n        !this.vuescroll.state.isClickingBar &&\r\n        this.vuescroll.state.pointerLeave\r\n      ) {\r\n        this.bar.hBar.state.opacity = 0;\r\n      }\r\n    },\r\n    recordCurrentPos() {\r\n      let mode = this.mode;\r\n      if (this.mode !== this.lastMode) {\r\n        mode = this.lastMode;\r\n        this.lastMode = this.mode;\r\n      }\r\n      const state = this.vuescroll.state;\r\n      let axis = findValuesByMode(mode, this);\r\n      const oldX = state.internalScrollLeft;\r\n      const oldY = state.internalScrollTop;\r\n      state.posX =\r\n        oldX - axis.x > 0 ? 'right' : oldX - axis.x < 0 ? 'left' : null;\r\n      state.posY = oldY - axis.y > 0 ? 'up' : oldY - axis.y < 0 ? 'down' : null;\r\n      state.internalScrollLeft = axis.x;\r\n      state.internalScrollTop = axis.y;\r\n    },\r\n    useNumbericSize() {\r\n      const parentElm = this.$el.parentNode;\r\n      const { position } = parentElm.style;\r\n      if (!position || position == 'static') {\r\n        this.$el.parentNode.style.position = 'relative';\r\n      }\r\n      this.vuescroll.state.height = parentElm.offsetHeight + 'px';\r\n      this.vuescroll.state.width = parentElm.offsetWidth + 'px';\r\n    },\r\n    usePercentSize() {\r\n      this.vuescroll.state.height = '100%';\r\n      this.vuescroll.state.width = '100%';\r\n    },\r\n    // set its size to be equal to its parentNode\r\n    setVsSize() {\r\n      if (this.mergedOptions.vuescroll.sizeStrategy == 'number') {\r\n        this.useNumbericSize();\r\n        this.registryParentResize();\r\n      } else if (this.mergedOptions.vuescroll.sizeStrategy == 'percent') {\r\n        if (this.destroyParentDomResize) {\r\n          this.destroyParentDomResize();\r\n          this.destroyParentDomResize = null;\r\n        }\r\n        this.usePercentSize();\r\n      }\r\n    }\r\n  }\r\n};\r\n","import { smallChangeArray } from '../shared/constants';\r\nimport { isChildInParent } from '../util';\r\n\r\nexport default {\r\n  methods: {\r\n    initWatchOpsChange() {\r\n      const watchOpts = {\r\n        deep: true,\r\n        sync: true\r\n      };\r\n      this.$watch(\r\n        'mergedOptions',\r\n        () => {\r\n          // record current position\r\n          this.recordCurrentPos();\r\n          setTimeout(() => {\r\n            if (this.isSmallChangeThisTick == true) {\r\n              this.isSmallChangeThisTick = false;\r\n              this.updateBarStateAndEmitEvent('options-change');\r\n              return;\r\n            }\r\n            this.refreshInternalStatus();\r\n          }, 0);\r\n        },\r\n        watchOpts\r\n      );\r\n\r\n      smallChangeArray.forEach(opts => {\r\n        this.$watch(\r\n          opts,\r\n          () => {\r\n            // when small changes changed,\r\n            // we need not to updateMode or registryResize\r\n            this.isSmallChangeThisTick = true;\r\n          },\r\n          watchOpts\r\n        );\r\n      });\r\n    },\r\n    // scrollTo hash-anchor while mounted\r\n    scrollToAnchor() /* istanbul ignore next */ {\r\n      const validateHashSelector = function(hash) {\r\n        return /^#[a-zA-Z_]\\d*$/.test(hash);\r\n      };\r\n      let hash = window.location.hash;\r\n      if (\r\n        !hash ||\r\n        ((hash = hash.slice(hash.lastIndexOf('#'))) &&\r\n          !validateHashSelector(hash))\r\n      ) {\r\n        return;\r\n      }\r\n      const elm = document.querySelector(hash);\r\n      if (\r\n        !isChildInParent(elm, this.$el) ||\r\n        this.mergedOptions.scrollPanel.initialScrollY ||\r\n        this.mergedOptions.scrollPanel.initialScrollX\r\n      ) {\r\n        return;\r\n      }\r\n      this.scrollIntoView(elm);\r\n    },\r\n    initVariables() {\r\n      this.lastMode = this.mode;\r\n      this.$el._isVuescroll = true;\r\n      this.clearScrollingTimes();\r\n    }\r\n  }\r\n};\r\n","export default {\r\n  methods: {\r\n    updateMode() {\r\n      const x = this.vuescroll.state.internalScrollLeft;\r\n      const y = this.vuescroll.state.internalScrollTop;\r\n      if (this.destroyScroller) {\r\n        this.scroller.stop();\r\n        this.destroyScroller();\r\n        this.destroyScroller = null;\r\n      }\r\n      if (this.mode == 'slide') {\r\n        this.destroyScroller = this.registryScroller();\r\n      } else if (this.mode == 'native' || this.mode == 'pure-native') {\r\n        // remove the legacy transform style attribute\r\n        this.scrollPanelElm.style.transform = '';\r\n        this.scrollPanelElm.style.transformOrigin = '';\r\n      }\r\n      // keep the last-mode's position.\r\n      this.scrollTo({ x, y }, false, true /* force */);\r\n    },\r\n    refreshInternalStatus() {\r\n      // 1.set vuescroll height or width according to\r\n      // sizeStrategy\r\n      this.setVsSize();\r\n      // 2. registry resize event\r\n      this.registryResize();\r\n      // 3. registry scroller if mode is 'slide'\r\n      // or remove 'transform origin' is the mode is not `slide`\r\n      this.updateMode();\r\n      // 4. update scrollbar's height/width\r\n      this.updateBarStateAndEmitEvent('refresh-status');\r\n    }\r\n  }\r\n};\r\n","import { listenResize } from '../third-party/resize-detector';\r\n\r\nexport default {\r\n  methods: {\r\n    registryResize() {\r\n      /* istanbul ignore next */\r\n      if (this.destroyResize) {\r\n        // when toggling the mode\r\n        // we should clean the flag-object.\r\n        this.destroyResize();\r\n      }\r\n      let contentElm = null;\r\n      if (this.mode == 'slide' || this.mode == 'pure-native') {\r\n        contentElm = this.scrollPanelElm;\r\n      } else if (this.mode == 'native') {\r\n        // scrollContent maybe a component or a pure-dom\r\n        contentElm = this.scrollContentElm;\r\n      }\r\n      const handleWindowResize = function() /* istanbul ignore next */ {\r\n        this.updateBarStateAndEmitEvent('window-resize');\r\n        if (this.mode == 'slide') {\r\n          this.vuescroll.updatedCbs.push(this.updateScroller);\r\n          this.$forceUpdate();\r\n        }\r\n      };\r\n      const handleDomResize = () => {\r\n        let currentSize = {};\r\n        if (this.mode == 'slide') {\r\n          currentSize['width'] = this.scroller.__contentWidth;\r\n          currentSize['height'] = this.scroller.__contentHeight;\r\n          this.updateBarStateAndEmitEvent('handle-resize', currentSize);\r\n          // update scroller should after rendering\r\n          this.vuescroll.updatedCbs.push(this.updateScroller);\r\n          this.$forceUpdate();\r\n        } else if (this.mode == 'native' || this.mode == 'pure-native') {\r\n          currentSize['width'] = this.scrollPanelElm.scrollWidth;\r\n          currentSize['height'] = this.scrollPanelElm.scrollHeight;\r\n          this.updateBarStateAndEmitEvent('handle-resize', currentSize);\r\n        }\r\n      };\r\n      window.addEventListener('resize', handleWindowResize.bind(this), false);\r\n      const destroyDomResize = listenResize(contentElm, handleDomResize);\r\n      const destroyWindowResize = () => {\r\n        window.removeEventListener('resize', handleWindowResize, false);\r\n      };\r\n\r\n      this.destroyResize = () => {\r\n        destroyWindowResize();\r\n        destroyDomResize();\r\n      };\r\n    },\r\n    registryParentResize() {\r\n      this.destroyParentDomResize = listenResize(\r\n        this.$el.parentNode,\r\n        this.useNumbericSize\r\n      );\r\n    }\r\n  }\r\n};\r\n","import Vue from 'vue';\r\nimport vuescroll from './components/vuescroll';\r\nimport GCF from './shared/global-config';\r\nimport { deepMerge } from './util';\r\nimport { refreshAll } from './mixins/api';\r\n\r\nimport './style/vuescroll.scss';\r\n\r\nconst Vuescroll = {\r\n  install(Vue) {\r\n    // registry vuescroll\r\n    Vue.component(vuescroll.name, vuescroll);\r\n    Vue.prototype.$vuescrollConfig = deepMerge(GCF, {});\r\n  },\r\n  version: '__version__',\r\n  refreshAll\r\n};\r\n\r\n/* istanbul ignore if */\r\nif (typeof window !== 'undefined' && window.Vue) {\r\n  Vue.use(Vuescroll);\r\n}\r\n\r\nexport default Vuescroll;\r\n"],"names":["deepCopy","source","target","key","_typeof","deepMerge","from","to","defineReactive","souceKey","getter","defineProperty","scrollBarWidth","eventCenter","dom","eventName","hander","capture","addEventListener","removeEventListener","error","msg","warn","isChildInParent","child","parent","flag","parentNode","nodeType","_isVuescroll","pxValueReg","extractNumberFromPx","value","_return","exec","isSupportTouch","window","getPrefix","global","engine","docStyle","document","documentElement","style","opera","Object","prototype","toString","call","navigator","cpuClass","isSupportGivenStyle","property","compatibleValue","testElm","createElement","isIE","agent","userAgent","toLowerCase","indexOf","insertChildrenIntoSlot","h","parentVnode","childVNode","data","tag","componentOptions","_data","nativeOn","on","props","propsData","getRealParent","ctx","$parent","_isVuescrollRoot","scrollPanel","this","scrollPanelElm","vuescroll","$el","isPercent","mergedOptions","sizeStrategy","clientWidth","state","width","clientHeight","height","heightPercentage","scrollHeight","widthPercentage","scrollWidth","bar","vBar","posValue","scrollTop","hBar","scrollLeft","size","createEasingFunction","easing","easingPattern","time","pattern","Date","now","running","counter","core","effect","Animate","requestFrame","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","isNative","test","callback","root","requests","rafHandle","intervalHandle","lastActive","callbackHandle","setInterval","currentRequests","hasOwnProperty","id","cleared","stepCallback","verifyCallback","completedCallback","duration","easingMethod","start","lastFrame","percent","dropCounter","body","newRunning","usedId","step","virtual","render","droppedFrames","Math","round","j","min","modes","NOOP","smallChangeArray","animatingMethod","noAnimatingMethod","Scroller","options","__callback","animatingEasing","noAnimatingEasing","members","contentWidth","contentHeight","animate","noScroll","self","__clientWidth","__clientHeight","__contentWidth","__contentHeight","__computeScrollMax","scrollTo","__scrollLeft","__scrollTop","left","top","__clientLeft","__clientTop","__snapWidth","__snapHeight","activateCallback","deactivateCallback","startCallback","beforeDeactivateCallback","__refreshHeight","__refreshActivate","__refreshBeforeDeactivate","__refreshDeactivate","__refreshStart","__loadHeight","__loadActivate","__loadBeforeDeactivate","__loadDeactivate","__loadStart","type","wasDecelerating","__isDecelerating","stop","__publish","__zoomLevel","__refreshActive","__maxScrollTop","__loadActive","__maxScrollLeft","level","originLeft","originTop","zooming","Error","__zoomComplete","oldLevel","max","maxZoom","minZoom","factor","zoomTo","zoom","force","scrollingX","paging","snapping","scrollingY","__isTracking","startLeft","__isAnimating","__scheduledLeft","startTop","__scheduledTop","__computePage","__currentPageX","__currentPageY","x","y","isNaN","wheelDelta","timeStamp","pageX","pageY","change","touches","length","valueOf","currentTouchLeft","currentTouchTop","__interruptedAnimation","isSingleTouch","abs","__initialTouchLeft","__initialTouchTop","__zoomLevelStart","__lastTouchLeft","__lastTouchTop","__lastTouchMove","__lastScale","__enableScrollX","__enableScrollY","__didDecelerationComplete","__isDragging","__isSingleTouch","__positions","scale","positions","moveX","moveY","currentTouchLeftRel","currentTouchTopRel","speedMultiplier","maxScrollLeft","bouncing","maxScrollTop","splice","push","minimumTrackingForScroll","locking","distanceX","distanceY","animating","endPos","startPos","i","timeOffset","movedLeft","movedTop","__decelerationVelocityX","__decelerationVelocityY","minVelocityToStartDeceleration","__startDeceleration","__scrollComplete","__disable","wasAnimating","__scheduledZoom","oldLeft","oldTop","oldZoom","diffLeft","diffTop","diffZoom","onScroll","renderedFramesPerSecond","animationId","wasFinished","animationDuration","zoomLevel","__totalXPage","ceil","__totalYPage","scrollingComplete","__minDecelerationScrollLeft","floor","__minDecelerationScrollTop","__maxDecelerationScrollLeft","__maxDecelerationScrollTop","minVelocityToKeepDecelerating","__stepThroughDeceleration","shouldContinue","scrollLeftFixed","scrollTopFixed","scrollOutsideX","scrollOutsideY","penetrationDeceleration","penetrationAcceleration","undefined","vm","$options","name","_gfc","$vuescrollConfig","ops","GCF","keys","forEach","scrollContent","rail","vRail","pos","renderError","shouldStopRender","mode","enable","pullRefresh","pushLoad","initialScrollY","initialScrollX","String","match","validateOptions","vsInstances","getNumericValue","distance","number","listenResize","element","hasResized","OBJECT_STYLE","objWrap","cssText","object","tabIndex","onload","contentDocument","defaultView","isResizeElm","appendChild","removeChild","injectObject","colorCache","rgbReg","extractRgbColor","createBar","axis","barType","charAt","railType","refreshLoad","setBarClick","createPanel","scrollPanelData","handleScroll","class","gutter","Vue","$isServer","outer","visibility","position","widthNoScroll","offsetWidth","overflow","inner","widthWithScroll","getGutter","marginRight","transformOrigin","transform","$slots","default","renderChildren","refreshDom","createTipDom","unshift","ref","pullRefreshTip","loadDom","enableLoad","isEnableLoad","__load","__load-disabled","pushLoadTip","createPanelChildren","stage","d","vueScrollCore","scrollMap","railBackgroundColor","color","opacity","div","background","computedColor","getComputedStyle","backgroundColor","getRgbAColor","hover","touchmove","e","axisStartPos","client","getBoundingClientRect","posName","offset","scrollSize","touchend","$emit","onselectstart","hideBar","stopImmediatePropagation","preventDefault","$refs","createTouchEvent","mousemove","mouseup","createMouseEvent","opsSize","barOffset","currentTarget","slots","boxSizing","padding","paddPos","paddValue","customContent","required","_this","_isDestroyed","updateInitialScroll","customPanel","hackLifecycle","_uid","internalScrollLeft","internalScrollTop","internalScrollTo","dx","dy","scroller","zoomBy","getCurrentPage","dest","goToPage","isRefresh","isLoad","triggerRefreshOrLoad","parentLeft","parentTop","parentHeight","parentWidth","children","scrollContentElm","domFragment","item","destX","destY","bind","elm","deltaX","deltaY","speed","startLocationY","startLocationX","positionX","positionY","percentage","parentElm","querySelector","diffX","diffY","scrollBy","refreshInternalStatus","scrollingTimes","nativeMode","updateDimesion","registryRefreshLoad","refreshHeight","offsetHeight","marginTop","setDimensions","registryEvent","content","suffix","vendorPrefix","helperElem","perspectiveProperty","transformProperty","undef","setSnapSize","rect","setPosition","clientLeft","clientTop","cb","container","eventCallback","destroy","touchstart","tagName","doTouchStart","passive","doTouchMove","doTouchEnd","touchcancel","mousedownEvent","mousedown","zoomHandle","doMouseZoom","detail","listenContainer","eventType","isDragging","updateScroller","outerLeft","outerTop","stageName","tipDom","listeners","domName","activateFunc","activatePullToRefresh","activatePushToLoad","cbs","$listeners","finishRefreshOrLoad","done","_isVue","tips","refreshStage","loadStage","nativeEvent","updateNativeModeBarState","updateSlideModeBarState","emitEvent","onlyShowBarOnScroll","showAndDefferedHideBar","vertical","horizontal","posY","posX","recordCurrentPos","updateBarStateAndEmitEvent","val","isClickingBar","_isMounted","panelElm","containerElm","loadHeight","forceHideBar","showBar","timeoutId","setTimeout","showDelay","keepShow","pointerLeave","lastMode","findValuesByMode","oldX","oldY","useNumbericSize","registryParentResize","destroyParentDomResize","usePercentSize","watchOpts","$watch","isSmallChangeThisTick","opts","hash","location","slice","lastIndexOf","scrollIntoView","clearScrollingTimes","destroyScroller","registryScroller","setVsSize","registryResize","updateMode","destroyResize","contentElm","handleWindowResize","updatedCbs","$forceUpdate","destroyDomResize","currentSize","initVariables","initWatchOpsChange","$nextTick","scrollToAnchor","vuescrollData","customContainer","ch","Vuescroll","component","vs","refresh","use"],"mappings":"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"}