{"version":3,"file":"vuescroll.min.js","sources":["../src/util/index.js","../src/third-party/resize-detector/index.js","../src/shared/constants.js","../src/shared/global-config.js","../src/mixins/hack-lifecycle.js","../src/third-party/easingPattern/index.js","../src/third-party/scroller/animate.js","../src/third-party/scroller/requestAnimationFrame.js","../src/mixins/api.js","../src/mixins/mode/native-mode.js","../src/third-party/scroller/index.js","../src/mixins/mode/slide-mode.js","../src/shared/scroll-map.js","../src/components/child-components/vuescroll-bar.js","../src/components/child-components/vuescroll-panel.js","../src/components/child-components/vuescroll-content.js","../src/components/vuescroll.js","../src/third-party/scroller/render.js","../src/third-party/scroller/listener.js","../src/index.js"],"sourcesContent":["import Vue from 'vue';\n\nexport function deepCopy(source, target) {\n  target = (typeof target === 'object' && target) || {};\n  for (var key in source) {\n    target[key] =\n      typeof source[key] === 'object'\n        ? deepCopy(source[key], (target[key] = {}))\n        : source[key];\n  }\n  return target;\n}\n\nexport function deepMerge(from, to) {\n  to = to || {};\n  for (var key in from) {\n    if (typeof from[key] === 'object') {\n      if (typeof to[key] === 'undefined') {\n        to[key] = {};\n        deepCopy(from[key], to[key]);\n      } else {\n        deepMerge(from[key], to[key]);\n      }\n    } else {\n      if (typeof to[key] === 'undefined') to[key] = from[key];\n    }\n  }\n  return to;\n}\n\nexport function defineReactive(target, key, source, souceKey) {\n  let getter = null;\n  /* istanbul ignore if */\n  if (!source[key] && typeof source !== 'function') {\n    return;\n  }\n  souceKey = souceKey || key;\n  if (typeof source === 'function') {\n    getter = source;\n  }\n  Object.defineProperty(target, key, {\n    get:\n      getter ||\n      function() {\n        return source[souceKey];\n      },\n    configurable: true\n  });\n}\n\nlet scrollBarWidth;\n\nexport function getGutter() {\n  /* istanbul ignore next */\n  if (Vue.prototype.$isServer) return 0;\n  if (scrollBarWidth !== undefined) return scrollBarWidth;\n  const outer = document.createElement('div');\n  outer.style.visibility = 'hidden';\n  outer.style.width = '100px';\n  outer.style.position = 'absolute';\n  outer.style.top = '-9999px';\n  document.body.appendChild(outer);\n\n  const widthNoScroll = outer.offsetWidth;\n  outer.style.overflow = 'scroll';\n  const inner = document.createElement('div');\n  inner.style.width = '100%';\n  outer.appendChild(inner);\n\n  const widthWithScroll = inner.offsetWidth;\n  outer.parentNode.removeChild(outer);\n  scrollBarWidth = widthNoScroll - widthWithScroll;\n  return scrollBarWidth;\n}\n\nexport function eventCenter(\n  dom,\n  eventName,\n  hander,\n  capture = false,\n  type = 'on'\n) {\n  type == 'on'\n    ? dom.addEventListener(eventName, hander, capture)\n    : dom.removeEventListener(eventName, hander, capture);\n}\n\nexport const error = msg => {\n  console.error(`[vuescroll] ${msg}`);\n};\nexport const warn = msg => {\n  console.warn(`[vuescroll] ${msg}`);\n};\n\nexport function isChildInParent(child, parent) {\n  let flag = false;\n  if (!child || !parent) {\n    return flag;\n  }\n  while (\n    child.parentNode !== parent &&\n    child.parentNode.nodeType !== 9 &&\n    !child.parentNode._isVuescroll\n  ) {\n    child = child.parentNode;\n  }\n  if (child.parentNode == parent) {\n    flag = true;\n  }\n  return flag;\n}\n\nconst pxValueReg = /(.*?)px/;\nexport function extractNumberFromPx(value) {\n  const _return = pxValueReg.exec(value);\n  return _return && _return[1];\n}\n\nexport function isSupportTouch() {\n  return 'ontouchstart' in window;\n}\n\nexport function getPrefix(global) {\n  var docStyle = document.documentElement.style;\n  var engine;\n  /* istanbul ignore if */\n  if (\n    global.opera &&\n    Object.prototype.toString.call(opera) === '[object Opera]'\n  ) {\n    engine = 'presto';\n  } /* istanbul ignore next */ else if ('MozAppearance' in docStyle) {\n    engine = 'gecko';\n  } else if ('WebkitAppearance' in docStyle) {\n    engine = 'webkit';\n  } /* istanbul ignore next */ else if (\n    typeof navigator.cpuClass === 'string'\n  ) {\n    engine = 'trident';\n  }\n  var vendorPrefix = {\n    trident: 'ms',\n    gecko: 'moz',\n    webkit: 'webkit',\n    presto: 'O'\n  }[engine];\n  return vendorPrefix;\n}\n\nexport function isSupportGivenStyle(property, value) {\n  const compatibleValue = `-${getPrefix(window)}-${value}`;\n  const testElm = document.createElement('div');\n  testElm.style[property] = compatibleValue;\n  if (testElm.style[property] == compatibleValue) {\n    return compatibleValue;\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nexport function isIE() /* istanbul ignore next */ {\n  var agent = navigator.userAgent.toLowerCase();\n  return (\n    agent.indexOf('msie') !== -1 ||\n    agent.indexOf('trident') !== -1 ||\n    agent.indexOf(' edge/') !== -1\n  );\n}\n\nexport function insertChildrenIntoSlot(h, parentVnode, childVNode, data) {\n  parentVnode = parentVnode[0] ? parentVnode[0] : parentVnode;\n  const tag =\n    (parentVnode.componentOptions && parentVnode.componentOptions.tag) ||\n    parentVnode.tag;\n  // if (!Array.isArray(childVNode)) {\n  //   childVNode = [childVNode];\n  // }\n\n  // // Remove null node\n  // for (let index = 0; index < childVNode.length; index++) {\n  //   const element = childVNode[index];\n  //   if (!element) {\n  //     childVNode.splice(index, 1);\n  //     index--;\n  //   }\n  // }\n  const _data = parentVnode.componentOptions || parentVnode.data || {};\n\n  // If component, use `nativeOn` intead.\n  if (parentVnode.componentOptions) {\n    data.nativeOn = data.on;\n    _data.props = _data.propsData;\n\n    delete data.on;\n    delete data.propsData;\n  }\n\n  return h(\n    tag,\n    {\n      ...data,\n      ..._data\n    },\n    childVNode\n  );\n}\n\nexport function getRealParent(ctx) {\n  let parent = ctx.$parent;\n\n  if (!parent._isVuescrollRoot && parent) {\n    parent = parent.$parent;\n  }\n\n  return parent;\n}\n","// detect content size change\nimport { eventCenter, isIE } from '../../util';\nexport function listenResize(element, callback) {\n  return injectObject(element, callback);\n}\n\nfunction injectObject(element, callback) {\n  if (element.hasResized) {\n    return;\n  }\n\n  var OBJECT_STYLE =\n    'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; padding: 0; margin: 0; opacity: 0; z-index: -1000; pointer-events: none;';\n  // define a wrap due to ie's zIndex bug\n  var objWrap = document.createElement('div');\n  objWrap.style.cssText = OBJECT_STYLE;\n  var object = document.createElement('object');\n  object.style.cssText = OBJECT_STYLE;\n  object.type = 'text/html';\n  object.tabIndex = -1;\n  object.onload = () => {\n    eventCenter(object.contentDocument.defaultView, 'resize', callback);\n  };\n  // https://github.com/wnr/element-resize-detector/blob/aafe9f7ea11d1eebdab722c7c5b86634e734b9b8/src/detection-strategy/object.js#L159\n  if (!isIE()) {\n    object.data = 'about:blank';\n  }\n  objWrap.isResizeElm = true;\n  objWrap.appendChild(object);\n  element.appendChild(objWrap);\n  if (isIE()) {\n    object.data = 'about:blank';\n  }\n  return function destroy() {\n    if (object.contentDocument) {\n      eventCenter(\n        object.contentDocument.defaultView,\n        'resize',\n        callback,\n        'off'\n      );\n    }\n    element.removeChild(objWrap);\n    element.hasResized = false;\n  };\n}\n","// all modes\nexport const modes = ['slide', 'native', 'pure-native'];\n// do nothing\nexport const NOOP = () => {};\n// some small changes.\nexport const smallChangeArray = [\n  'mergedOptions.vuescroll.pullRefresh.tips',\n  'mergedOptions.vuescroll.pushLoad.tips',\n  'mergedOptions.rail',\n  'mergedOptions.bar'\n];\n","import { modes } from './constants';\nimport { error } from '../util';\nexport default {\n  // vuescroll\n  vuescroll: {\n    mode: 'native',\n    // vuescroll's size(height/width) should be a percent(100%)\n    // or be a number that is equal to its parentNode's width or\n    // height ?\n    sizeStrategy: 'percent',\n    // pullRefresh or pushLoad is only for the slide mode...\n    pullRefresh: {\n      enable: false,\n      tips: {\n        deactive: 'Pull to Refresh',\n        active: 'Release to Refresh',\n        start: 'Refreshing...',\n        beforeDeactive: 'Refresh Successfully!'\n      }\n    },\n    pushLoad: {\n      enable: false,\n      tips: {\n        deactive: 'Push to Load',\n        active: 'Release to Load',\n        start: 'Loading...',\n        beforeDeactive: 'Load Successfully!'\n      }\n    },\n    paging: false,\n    zooming: true,\n    snapping: {\n      enable: false,\n      width: 100,\n      height: 100\n    },\n    // some scroller options\n    scroller: {\n      /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\n      bouncing: true,\n      /** Enable locking to the main axis if user moves only slightly on one of them at start */\n      locking: true,\n      /** Minimum zoom level */\n      minZoom: 0.5,\n      /** Maximum zoom level */\n      maxZoom: 3,\n      /** Multiply or decrease scrolling speed **/\n      speedMultiplier: 1,\n      /** This configures the amount of change applied to deceleration when reaching boundaries  **/\n      penetrationDeceleration: 0.03,\n      /** This configures the amount of change applied to acceleration when reaching boundaries  **/\n      penetrationAcceleration: 0.08,\n      /** Whether call e.preventDefault event when sliding the content or not */\n      preventDefault: true\n    }\n  },\n  scrollPanel: {\n    // when component mounted.. it will automatically scrolls.\n    initialScrollY: false,\n    initialScrollX: false,\n    // feat: #11\n    scrollingX: true,\n    scrollingY: true,\n    speed: 300,\n    easing: undefined\n  },\n  //\n  scrollContent: {\n    padding: false\n  },\n  //\n  rail: {\n    vRail: {\n      width: '6px',\n      pos: 'right',\n      background: '#01a99a',\n      opacity: 0\n    },\n    //\n    hRail: {\n      height: '6px',\n      pos: 'bottom',\n      background: '#01a99a',\n      opacity: 0\n    }\n  },\n  bar: {\n    showDelay: 500,\n    vBar: {\n      background: '#00a650',\n      keepShow: false,\n      opacity: 1,\n      hover: false\n    },\n    //\n    hBar: {\n      background: '#00a650',\n      keepShow: false,\n      opacity: 1,\n      hover: false\n    }\n  }\n};\n/**\n * validate the options\n *\n * @export\n * @param {any} ops\n */\nexport function validateOptions(ops) {\n  let shouldStopRender = false;\n  const { vuescroll, scrollPanel } = ops;\n\n  // validate vuescroll\n  if (!~modes.indexOf(vuescroll.mode)) {\n    error(`The vuescroll's option \"mode\" should be one of the ${modes}`);\n    shouldStopRender = true;\n  }\n\n  if (\n    vuescroll.paging == vuescroll.snapping.enable &&\n    vuescroll.paging &&\n    (vuescroll.pullRefresh || vuescroll.pushLoad)\n  ) {\n    error(\n      'paging, snapping, (pullRefresh with pushLoad) can only one of them to be true.'\n    );\n  }\n  // validate scrollPanel\n  const initialScrollY = scrollPanel['initialScrollY'];\n  const initialScrollX = scrollPanel['initialScrollX'];\n\n  if (initialScrollY && !String(initialScrollY).match(/^\\d+(\\.\\d+)?(%)?$/)) {\n    error(\n      'The prop `initialScrollY` should be a percent number like 10% or an exact number that greater than or equal to 0 like 100.'\n    );\n  }\n\n  if (initialScrollX && !String(initialScrollX).match(/^\\d+(\\.\\d+)?(%)?$/)) {\n    error(\n      'The prop `initialScrollX` should be a percent number like 10% or an exact number that greater than or equal to 0 like 100.'\n    );\n  }\n\n  return shouldStopRender;\n}\n","import GCF, { validateOptions } from '../shared/global-config';\nimport { deepMerge, defineReactive } from '../util';\n\n/**\n * hack the lifeCycle\n *\n * to merge the global data into user-define data\n */\nfunction hackPropsData() {\n  const vm = this;\n  if (vm.$options.name === 'vueScroll') {\n    const _gfc = deepMerge(vm.$vuescrollConfig, {});\n    const ops = deepMerge(GCF, _gfc);\n    vm.$options.propsData.ops = vm.$options.propsData.ops || {};\n    Object.keys(vm.$options.propsData.ops).forEach(key => {\n      {\n        defineReactive(vm.mergedOptions, key, vm.$options.propsData.ops);\n      }\n    });\n    // from ops to mergedOptions\n    deepMerge(ops, vm.mergedOptions);\n\n    const prefix = 'padding-';\n    defineReactive(vm.mergedOptions.scrollContent, 'paddPos', () => {\n      return prefix + vm.mergedOptions.rail.vRail.pos;\n    });\n    defineReactive(vm.mergedOptions.scrollContent, 'paddValue', () => {\n      return vm.mergedOptions.rail.vRail.width;\n    });\n  }\n}\nexport default {\n  data() {\n    return {\n      shouldStopRender: false,\n      mergedOptions: {\n        vuescroll: {},\n        scrollPanel: {},\n        scrollContent: {},\n        rail: {},\n        bar: {}\n      }\n    };\n  },\n  created() {\n    hackPropsData.call(this);\n\n    this._isVuescrollRoot = true;\n\n    this.renderError = validateOptions(this.mergedOptions);\n  }\n};\n","/**\n *  Compatible to scroller's animation function\n */\nexport function createEasingFunction(easing, easingPattern) {\n  return function(time) {\n    return easingPattern(easing, time);\n  };\n}\n\n/**\n * Calculate the easing pattern\n * @link https://github.com/cferdinandi/smooth-scroll/blob/master/src/js/smooth-scroll.js\n * modified by wangyi7099\n * @param {String} type Easing pattern\n * @param {Number} time Time animation should take to complete\n * @returns {Number}\n */\nexport function easingPattern(easing, time) {\n  let pattern = null;\n  /* istanbul ignore next */\n  {\n    // Default Easing Patterns\n    if (easing === 'easeInQuad') pattern = time * time; // accelerating from zero velocity\n    if (easing === 'easeOutQuad') pattern = time * (2 - time); // decelerating to zero velocity\n    if (easing === 'easeInOutQuad')\n      pattern = time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time; // acceleration until halfway, then deceleration\n    if (easing === 'easeInCubic') pattern = time * time * time; // accelerating from zero velocity\n    if (easing === 'easeOutCubic') pattern = --time * time * time + 1; // decelerating to zero velocity\n    if (easing === 'easeInOutCubic')\n      pattern =\n        time < 0.5\n          ? 4 * time * time * time\n          : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1; // acceleration until halfway, then deceleration\n    if (easing === 'easeInQuart') pattern = time * time * time * time; // accelerating from zero velocity\n    if (easing === 'easeOutQuart') pattern = 1 - --time * time * time * time; // decelerating to zero velocity\n    if (easing === 'easeInOutQuart')\n      pattern =\n        time < 0.5\n          ? 8 * time * time * time * time\n          : 1 - 8 * --time * time * time * time; // acceleration until halfway, then deceleration\n    if (easing === 'easeInQuint') pattern = time * time * time * time * time; // accelerating from zero velocity\n    if (easing === 'easeOutQuint')\n      pattern = 1 + --time * time * time * time * time; // decelerating to zero velocity\n    if (easing === 'easeInOutQuint')\n      pattern =\n        time < 0.5\n          ? 16 * time * time * time * time * time\n          : 1 + 16 * --time * time * time * time * time; // acceleration until halfway, then deceleration\n  }\n  return pattern || time; // no easing, no acceleration\n}\n","/*\n * Scroller\n * http://github.com/zynga/scroller\n *\n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n *\n * Based on the work of: Unify Project (unify-project.org)\n * http://unify-project.org\n * Copyright 2011, Deutsche Telekom AG\n * License: MIT + Apache (V2)\n */\n\n/**\n * Generic animation class with support for dropped frames both optional easing and duration.\n *\n * Optional duration is useful when the lifetime is defined by another condition than time\n * e.g. speed of an animating object, etc.\n *\n * Dropped frame logic allows to keep using the same updater logic independent from the actual\n * rendering. This eases a lot of cases where it might be pretty complex to break down a state\n * based on the pure time difference.\n */\nimport { requestAnimationFrame } from './requestAnimationFrame';\n\nvar time =\n  Date.now ||\n  function() {\n    return +new Date();\n  };\nvar desiredFrames = 60;\nvar millisecondsPerSecond = 1000;\nvar running = {};\nvar counter = 1;\n\nconst core = { effect: {} };\nlet global = null;\n\nif (typeof window !== 'undefined') {\n  global = window;\n} else {\n  global = {};\n}\n\ncore.effect.Animate = {\n  /**\n   * A requestAnimationFrame wrapper / polyfill.\n   *\n   * @param callback {Function} The callback to be invoked before the next repaint.\n   * @param root {HTMLElement} The root element for the repaint\n   */\n  requestAnimationFrame: requestAnimationFrame(global),\n  /**\n   * Stops the given animation.\n   *\n   * @param id {Integer} Unique animation ID\n   * @return {Boolean} Whether the animation was stopped (aka, was running before)\n   */\n  stop: function(id) {\n    var cleared = running[id] != null;\n    if (cleared) {\n      running[id] = null;\n    }\n\n    return cleared;\n  },\n\n  /**\n   * Whether the given animation is still running.\n   *\n   * @param id {Integer} Unique animation ID\n   * @return {Boolean} Whether the animation is still running\n   */\n  isRunning: function(id) {\n    return running[id] != null;\n  },\n\n  /**\n   * Start the animation.\n   *\n   * @param stepCallback {Function} Pointer to function which is executed on every step.\n   *   Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`\n   * @param verifyCallback {Function} Executed before every animation step.\n   *   Signature of the method should be `function() { return continueWithAnimation; }`\n   * @param completedCallback {Function}\n   *   Signature of the method should be `function(droppedFrames, finishedAnimation) {}`\n   * @param duration {Integer} Milliseconds to run the animation\n   * @param easingMethod {Function} Pointer to easing function\n   *   Signature of the method should be `function(percent) { return modifiedValue; }`\n   * @param root {Element ? document.body} Render root, when available. Used for internal\n   *   usage of requestAnimationFrame.\n   * @return {Integer} Identifier of animation. Can be used to stop it any time.\n   */\n  start: function(\n    stepCallback,\n    verifyCallback,\n    completedCallback,\n    duration,\n    easingMethod,\n    root\n  ) {\n    var start = time();\n    var lastFrame = start;\n    var percent = 0;\n    var dropCounter = 0;\n    var id = counter++;\n\n    if (!root) {\n      root = document.body;\n    }\n\n    // Compacting running db automatically every few new animations\n    if (id % 20 === 0) {\n      var newRunning = {};\n      for (var usedId in running) {\n        newRunning[usedId] = true;\n      }\n      running = newRunning;\n    }\n\n    // This is the internal step method which is called every few milliseconds\n    var step = function(virtual) {\n      // Normalize virtual value\n      var render = virtual !== true;\n\n      // Get current time\n      var now = time();\n\n      // Verification is executed before next animation step\n      if (!running[id] || (verifyCallback && !verifyCallback(id))) {\n        running[id] = null;\n        completedCallback &&\n          completedCallback(\n            desiredFrames -\n              dropCounter / ((now - start) / millisecondsPerSecond),\n            id,\n            false\n          );\n        return;\n      }\n\n      // For the current rendering to apply let's update omitted steps in memory.\n      // This is important to bring internal state variables up-to-date with progress in time.\n      if (render) {\n        var droppedFrames =\n          Math.round(\n            (now - lastFrame) / (millisecondsPerSecond / desiredFrames)\n          ) - 1;\n        for (var j = 0; j < Math.min(droppedFrames, 4); j++) {\n          step(true);\n          dropCounter++;\n        }\n      }\n\n      // Compute percent value\n      if (duration) {\n        percent = (now - start) / duration;\n        if (percent > 1) {\n          percent = 1;\n        }\n      }\n\n      // Execute step callback, then...\n      var value = easingMethod ? easingMethod(percent) : percent;\n      if (\n        (stepCallback(value, now, render) === false || percent === 1) &&\n        render\n      ) {\n        running[id] = null;\n        completedCallback &&\n          completedCallback(\n            desiredFrames -\n              dropCounter / ((now - start) / millisecondsPerSecond),\n            id,\n            percent === 1 || duration == null\n          );\n      } else if (render) {\n        lastFrame = now;\n        core.effect.Animate.requestAnimationFrame(step, root);\n      }\n    };\n\n    // Mark as running\n    running[id] = true;\n\n    // Init first step\n    core.effect.Animate.requestAnimationFrame(step, root);\n\n    // Return unique animation ID\n    return id;\n  }\n};\n\nexport { core };\n","export function requestAnimationFrame(global) {\n  // Check for request animation Frame support\n  var requestFrame =\n    global.requestAnimationFrame ||\n    global.webkitRequestAnimationFrame ||\n    global.mozRequestAnimationFrame ||\n    global.oRequestAnimationFrame;\n  var isNative = !!requestFrame;\n\n  if (\n    requestFrame &&\n    !/requestAnimationFrame\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}/i.test(\n      requestFrame.toString()\n    )\n  ) {\n    isNative = false;\n  }\n\n  if (isNative) {\n    return function(callback, root) {\n      requestFrame(callback, root);\n    };\n  }\n\n  var TARGET_FPS = 60;\n  var requests = {};\n  var rafHandle = 1;\n  var intervalHandle = null;\n  var lastActive = +new Date();\n\n  return function(callback) {\n    var callbackHandle = rafHandle++;\n\n    // Store callback\n    requests[callbackHandle] = callback;\n    requestCount++;\n\n    // Create timeout at first request\n    if (intervalHandle === null) {\n      intervalHandle = setInterval(function() {\n        var time = +new Date();\n        var currentRequests = requests;\n\n        // Reset data structure before executing callbacks\n        requests = {};\n        requestCount = 0;\n\n        for (var key in currentRequests) {\n          if (currentRequests.hasOwnProperty(key)) {\n            currentRequests[key](time);\n            lastActive = time;\n          }\n        }\n\n        // Disable the timeout when nothing happens for a certain\n        // period of time\n        if (time - lastActive > 2500) {\n          clearInterval(intervalHandle);\n          intervalHandle = null;\n        }\n      }, 1000 / TARGET_FPS);\n    }\n\n    return callbackHandle;\n  };\n}\n","import {\n  createEasingFunction,\n  easingPattern\n} from '../third-party/easingPattern';\nimport { core } from '../third-party/scroller/animate';\nimport { warn, isChildInParent } from '../util';\n\nconst vsInstances = {};\n\nexport function refreshAll() {\n  for (let vs in vsInstances) {\n    vsInstances[vs].refresh();\n  }\n}\n\nfunction getNumericValue(distance, size) {\n  let number;\n  if (!(number = /(-?\\d+(?:\\.\\d+?)?)%$/.exec(distance))) {\n    number = distance - 0;\n  } else {\n    number = number[1] - 0;\n    number = (size * number) / 100;\n  }\n  return number;\n}\n\nfunction goScrolling(elm, deltaX, deltaY, speed, easing, scrollingComplete) {\n  const startLocationY = elm['scrollTop'];\n  const startLocationX = elm['scrollLeft'];\n  let positionX = startLocationX;\n  let positionY = startLocationY;\n  /**\n   * keep the limit of scroll delta.\n   */\n  /* istanbul ignore next */\n  if (startLocationY + deltaY < 0) {\n    deltaY = -startLocationY;\n  }\n  const scrollHeight = elm['scrollHeight'];\n  if (startLocationY + deltaY > scrollHeight) {\n    deltaY = scrollHeight - startLocationY;\n  }\n  if (startLocationX + deltaX < 0) {\n    deltaX = -startLocationX;\n  }\n  if (startLocationX + deltaX > elm['scrollWidth']) {\n    deltaX = elm['scrollWidth'] - startLocationX;\n  }\n\n  const easingMethod = createEasingFunction(easing, easingPattern);\n\n  const stepCallback = percentage => {\n    positionX = startLocationX + deltaX * percentage;\n    positionY = startLocationY + deltaY * percentage;\n    elm['scrollTop'] = Math.floor(positionY);\n    elm['scrollLeft'] = Math.floor(positionX);\n  };\n\n  const verifyCallback = () => {\n    return (\n      Math.abs(positionY - startLocationY) <= Math.abs(deltaY) ||\n      Math.abs(positionX - startLocationX) <= Math.abs(deltaX)\n    );\n  };\n\n  core.effect.Animate.start(\n    stepCallback,\n    verifyCallback,\n    scrollingComplete,\n    speed,\n    easingMethod\n  );\n}\n\nexport default {\n  mounted() {\n    vsInstances[this._uid] = this;\n  },\n  beforeDestroy() {\n    delete vsInstances[this._uid];\n  },\n  methods: {\n    // public api\n    scrollTo({ x, y }, animate = true, force = false) {\n      if (typeof x === 'undefined') {\n        x = this.vuescroll.state.internalScrollLeft || 0;\n      } else {\n        x = getNumericValue(x, this.scrollPanelElm.scrollWidth);\n      }\n      if (typeof y === 'undefined') {\n        y = this.vuescroll.state.internalScrollTop || 0;\n      } else {\n        y = getNumericValue(y, this.scrollPanelElm.scrollHeight);\n      }\n      this.internalScrollTo(x, y, animate, force);\n    },\n    scrollBy({ dx = 0, dy = 0 }, animate = true) {\n      let {\n        internalScrollLeft = 0,\n        internalScrollTop = 0\n      } = this.vuescroll.state;\n      if (dx) {\n        internalScrollLeft += getNumericValue(\n          dx,\n          this.scrollPanelElm.scrollWidth\n        );\n      }\n      if (dy) {\n        internalScrollTop += getNumericValue(\n          dy,\n          this.scrollPanelElm.scrollHeight\n        );\n      }\n      this.internalScrollTo(internalScrollLeft, internalScrollTop, animate);\n    },\n    zoomBy(factor, animate, originLeft, originTop, callback) {\n      if (this.mode != 'slide') {\n        warn('zoomBy and zoomTo are only for slide mode!');\n        return;\n      }\n      this.scroller.zoomBy(factor, animate, originLeft, originTop, callback);\n    },\n    zoomTo(level, animate = false, originLeft, originTop, callback) {\n      if (this.mode != 'slide') {\n        warn('zoomBy and zoomTo are only for slide mode!');\n        return;\n      }\n      this.scroller.zoomTo(level, animate, originLeft, originTop, callback);\n    },\n    getCurrentPage() {\n      if (this.mode != 'slide' || !this.mergedOptions.vuescroll.paging) {\n        warn(\n          'getCurrentPage and goToPage are only for slide mode and paging is enble!'\n        );\n        return;\n      }\n      return this.scroller.getCurrentPage();\n    },\n    goToPage(dest, animate = false) {\n      if (this.mode != 'slide' || !this.mergedOptions.vuescroll.paging) {\n        warn(\n          'getCurrentPage and goToPage are only for slide mode and paging is enble!'\n        );\n        return;\n      }\n      this.scroller.goToPage(dest, animate);\n    },\n    triggerRefreshOrLoad(type) {\n      if (this.mode != 'slide') {\n        warn('You can only use triggerRefreshOrLoad in slide mode!');\n        return;\n      }\n      const isRefresh = this.mergedOptions.vuescroll.pullRefresh.enable;\n      const isLoad = this.mergedOptions.vuescroll.pushLoad.enable;\n      if (type == 'refresh' && !isRefresh) {\n        warn('refresh must be enabled!');\n        return;\n      } else if (type == 'load' && !isLoad) {\n        warn('load must be enabled!');\n        return;\n      } else if (type !== 'refresh' && type !== 'load') {\n        warn('param must be one of load and refresh!');\n        return;\n      }\n      /* istanbul ignore if */\n      if (this.vuescroll.state[`${type}Stage`] == 'start') {\n        return;\n      }\n      this.scroller.triggerRefreshOrLoad(type);\n      return true;\n    },\n    getCurrentviewDom() {\n      const parent =\n        this.mode == 'slide' || this.mode == 'pure-native'\n          ? this.scrollPanelElm\n          : this.scrollContentElm;\n      const children = parent.children;\n      const domFragment = [];\n      const isCurrentview = dom => {\n        const { left, top, width, height } = dom.getBoundingClientRect();\n        const {\n          left: parentLeft,\n          top: parentTop,\n          height: parentHeight,\n          width: parentWidth\n        } = this.$el.getBoundingClientRect();\n        if (\n          left - parentLeft + width > 0 &&\n          left - parentLeft < parentWidth &&\n          top - parentTop + height > 0 &&\n          top - parentTop < parentHeight\n        ) {\n          return true;\n        }\n        return false;\n      };\n\n      for (let i = 0; i < children.length; i++) {\n        const dom = children.item(i);\n        if (isCurrentview(dom) && !dom.isResizeElm) {\n          domFragment.push(dom);\n        }\n      }\n\n      return domFragment;\n    },\n    // private api\n    internalScrollTo(destX, destY, animate, force) {\n      if (this.mode == 'native' || this.mode == 'pure-native') {\n        if (animate) {\n          // hadnle for scroll complete\n          const scrollingComplete = () => {\n            this.updateBarStateAndEmitEvent('handle-scroll-complete');\n          };\n          goScrolling(\n            this.$refs['scrollPanel'].$el,\n            destX - this.$refs['scrollPanel'].$el.scrollLeft,\n            destY - this.$refs['scrollPanel'].$el.scrollTop,\n            this.mergedOptions.scrollPanel.speed,\n            this.mergedOptions.scrollPanel.easing,\n            scrollingComplete\n          );\n        } else {\n          this.$refs['scrollPanel'].$el.scrollTop = destY;\n          this.$refs['scrollPanel'].$el.scrollLeft = destX;\n        }\n      }\n      // for non-native we use scroller's scorllTo\n      else if (this.mode == 'slide') {\n        this.scroller.scrollTo(destX, destY, animate, undefined, force);\n      }\n    },\n    scrollIntoView(elm, animate = true) {\n      const parentElm = this.$el;\n      if (typeof elm === 'string') {\n        elm = parentElm.querySelector(elm);\n      }\n      if (!isChildInParent(elm, parentElm)) {\n        warn(\n          'The element or selector you passed is not the element of Vuescroll, please pass the element that is in Vuescroll to scrollIntoView API. '\n        );\n        return;\n      }\n      // parent elm left, top\n      const { left, top } = this.$el.getBoundingClientRect();\n      // child elm left, top\n      const { left: childLeft, top: childTop } = elm.getBoundingClientRect();\n\n      const diffX = left - childLeft;\n      const diffY = top - childTop;\n\n      this.scrollBy(\n        {\n          dx: -diffX,\n          dy: -diffY\n        },\n        animate\n      );\n    },\n    refresh() {\n      this.refreshInternalStatus();\n    }\n  }\n};\n","import { extractNumberFromPx } from '../../util';\nexport default {\n  methods: {\n    updateNativeModeBarState() {\n      const scrollPanel = this.scrollPanelElm;\n      const vuescroll = this.$el;\n      const isPercent = this.mergedOptions.vuescroll.sizeStrategy == 'percent';\n      const clientWidth = isPercent\n        ? vuescroll.clientWidth\n        : extractNumberFromPx(this.vuescroll.state.width);\n      const clientHeight = isPercent\n        ? vuescroll.clientHeight\n        : extractNumberFromPx(this.vuescroll.state.height);\n      let heightPercentage = (clientHeight * 100) / scrollPanel.scrollHeight;\n      let widthPercentage = (clientWidth * 100) / scrollPanel.scrollWidth;\n      this.bar.vBar.state.posValue =\n        (scrollPanel.scrollTop * 100) / clientHeight;\n      this.bar.hBar.state.posValue =\n        (scrollPanel.scrollLeft * 100) / clientWidth;\n      this.bar.vBar.state.size =\n        heightPercentage < 100 ? heightPercentage + '%' : 0;\n      this.bar.hBar.state.size =\n        widthPercentage < 100 ? widthPercentage + '%' : 0;\n    }\n  }\n};\n","/*\n * Scroller\n * http://github.com/zynga/scroller\n *\n * modified by wangyi7099\n * \n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n *\n * Based on the work of: Unify Project (unify-project.org)\n * http://unify-project.org\n * Copyright 2011, Deutsche Telekom AG\n * License: MIT + Apache (V2)\n */\nimport { easingPattern, createEasingFunction } from '../easingPattern';\nimport { core } from './animate';\nimport { NOOP } from '../../shared/constants';\n\nvar animatingMethod = null;\n\nvar noAnimatingMethod = null;\n\nexport default function Scroller(callback, options) {\n  this.__callback = callback;\n\n  this.options = {\n    /** Enable scrolling on x-axis */\n    scrollingX: true,\n\n    /** Enable scrolling on y-axis */\n    scrollingY: true,\n\n    /** Enable animations for deceleration, snap back, zooming and scrolling */\n    animating: true,\n\n    /** duration for animations triggered by scrollTo/zoomTo */\n    animationDuration: 250,\n\n    /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\n    bouncing: true,\n\n    /** Enable locking to the main axis if user moves only slightly on one of them at start */\n    locking: true,\n\n    /** Enable pagination mode (switching between full page content panes) */\n    paging: false,\n\n    /** Enable snapping of content to a configured pixel grid */\n    snapping: false,\n\n    /** Enable zooming of content via API, fingers and mouse wheel */\n    zooming: false,\n\n    /** Minimum zoom level */\n    minZoom: 0.5,\n\n    /** Maximum zoom level */\n    maxZoom: 3,\n\n    /** Multiply or decrease scrolling speed **/\n    speedMultiplier: 1,\n\n    /** Callback that is fired on the later of touch end or deceleration end,\n\t\t\t\tprovided that another scrolling action has not begun. Used to know\n\t\t\t\twhen to fade out a scrollbar. */\n    scrollingComplete: NOOP,\n\n    animatingEasing: 'easeOutCubic',\n\n    noAnimatingEasing: 'easeInOutCubic',\n\n    /** This configures the amount of change applied to deceleration when reaching boundaries  **/\n    penetrationDeceleration: 0.03,\n\n    /** This configures the amount of change applied to acceleration when reaching boundaries  **/\n    penetrationAcceleration: 0.08\n  };\n\n  for (var key in options) {\n    this.options[key] = options[key];\n  }\n\n  animatingMethod = createEasingFunction(\n    this.options.animatingEasing,\n    easingPattern\n  );\n  noAnimatingMethod = createEasingFunction(\n    this.options.noAnimatingEasing,\n    easingPattern\n  );\n}\n\nvar members = {\n  /*\n\t---------------------------------------------------------------------------\n\t\tINTERNAL FIELDS :: STATUS\n\t---------------------------------------------------------------------------\n\t*/\n\n  /** {Boolean} Whether only a single finger is used in touch handling */\n  __isSingleTouch: false,\n\n  /** {Boolean} Whether a touch event sequence is in progress */\n  __isTracking: false,\n\n  /** {Boolean} Whether a deceleration animation went to completion. */\n  __didDecelerationComplete: false,\n\n  /**\n   * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when\n   * a gesturestart event happens. This has higher priority than dragging.\n   */\n  __isGesturing: false,\n\n  /**\n   * {Boolean} Whether the user has moved by such a distance that we have enabled\n   * dragging mode. Hint: It's only enabled after some pixels of movement to\n   * not interrupt with clicks etc.\n   */\n  __isDragging: false,\n\n  /**\n   * {Boolean} Not touching and dragging anymore, and smoothly animating the\n   * touch sequence using deceleration.\n   */\n  __isDecelerating: false,\n\n  /**\n   * {Boolean} Smoothly animating the currently configured change\n   */\n  __isAnimating: false,\n\n  /*\n\t---------------------------------------------------------------------------\n\t\tINTERNAL FIELDS :: DIMENSIONS\n\t---------------------------------------------------------------------------\n\t*/\n\n  /** {Integer} Available outer left position (from document perspective) */\n  __clientLeft: 0,\n\n  /** {Integer} Available outer top position (from document perspective) */\n  __clientTop: 0,\n\n  /** {Integer} Available outer width */\n  __clientWidth: 0,\n\n  /** {Integer} Available outer height */\n  __clientHeight: 0,\n\n  /** {Integer} Outer width of content */\n  __contentWidth: 0,\n\n  /** {Integer} Outer height of content */\n  __contentHeight: 0,\n\n  /** {Integer} Snapping width for content */\n  __snapWidth: 100,\n\n  /** {Integer} Snapping height for content */\n  __snapHeight: 100,\n\n  /** {Integer} Height to assign to refresh area */\n  __refreshHeight: null,\n  /** {Integer} Height to assign to refresh area */\n  __loadHeight: null,\n  /** {Boolean} Whether the refresh process is enabled when the event is released now */\n  __refreshActive: false,\n\n  /** {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release */\n  __refreshActivate: null,\n\n  __refreshBeforeDeactivate: null,\n\n  /** {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled */\n  __refreshDeactivate: null,\n\n  /** {Function} Callback to execute to start the actual refresh. Call {@link #refreshFinish} when done */\n  __refreshStart: null,\n\n  __loadActive: null,\n\n  __loadActivate: null,\n\n  __loadBeforeDeactivate: null,\n\n  __loadDeactivate: null,\n\n  __loadStart: null,\n  /** {Number} Zoom level */\n  __zoomLevel: 1,\n\n  /** {Number} Scroll position on x-axis */\n  __scrollLeft: 0,\n\n  /** {Number} Scroll position on y-axis */\n  __scrollTop: 0,\n\n  /** {Integer} Maximum allowed scroll position on x-axis */\n  __maxScrollLeft: 0,\n\n  /** {Integer} Maximum allowed scroll position on y-axis */\n  __maxScrollTop: 0,\n\n  /* {Number} Scheduled left position (final position when animating) */\n  __scheduledLeft: 0,\n\n  /* {Number} Scheduled top position (final position when animating) */\n  __scheduledTop: 0,\n\n  /* {Number} Scheduled zoom level (final scale when animating) */\n  __scheduledZoom: 0,\n\n  /**\n   * current page\n   */\n  __currentPageX: null,\n\n  __currentPageY: null,\n\n  /**\n   * total page\n   */\n  __totalXPage: null,\n\n  __totalYPage: null,\n  /*\n\t---------------------------------------------------------------------------\n\t\tINTERNAL FIELDS :: LAST POSITIONS\n\t---------------------------------------------------------------------------\n\t*/\n  /** whether the scroller is disabled or not */\n  __disable: false,\n  /** {Number} Left position of finger at start */\n  __lastTouchLeft: null,\n\n  /** {Number} Top position of finger at start */\n  __lastTouchTop: null,\n\n  /** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */\n  __lastTouchMove: null,\n\n  /** {Array} List of positions, uses three indexes for each state: left, top, timestamp */\n  __positions: null,\n\n  /*\n\t---------------------------------------------------------------------------\n\t\tINTERNAL FIELDS :: DECELERATION SUPPORT\n\t---------------------------------------------------------------------------\n\t*/\n\n  /** {Integer} Minimum left scroll position during deceleration */\n  __minDecelerationScrollLeft: null,\n\n  /** {Integer} Minimum top scroll position during deceleration */\n  __minDecelerationScrollTop: null,\n\n  /** {Integer} Maximum left scroll position during deceleration */\n  __maxDecelerationScrollLeft: null,\n\n  /** {Integer} Maximum top scroll position during deceleration */\n  __maxDecelerationScrollTop: null,\n\n  /** {Number} Current factor to modify horizontal scroll position with on every step */\n  __decelerationVelocityX: null,\n\n  /** {Number} Current factor to modify vertical scroll position with on every step */\n  __decelerationVelocityY: null,\n\n  /*\n\t---------------------------------------------------------------------------\n\t\tPUBLIC API\n\t---------------------------------------------------------------------------\n\t*/\n\n  /**\n   * Configures the dimensions of the client (outer) and content (inner) elements.\n   * Requires the available space for the outer element and the outer size of the inner element.\n   * All values which are falsy (null or zero etc.) are ignored and the old value is kept.\n   *\n   * @param clientWidth {Integer ? null} Inner width of outer element\n   * @param clientHeight {Integer ? null} Inner height of outer element\n   * @param contentWidth {Integer ? null} Outer width of inner element\n   * @param contentHeight {Integer ? null} Outer height of inner element\n   */\n  setDimensions: function(\n    clientWidth,\n    clientHeight,\n    contentWidth,\n    contentHeight,\n    animate = trye\n  ) {\n    var self = this;\n\n    // Only update values which are defined\n    if (clientWidth === +clientWidth) {\n      self.__clientWidth = clientWidth;\n    }\n\n    if (clientHeight === +clientHeight) {\n      self.__clientHeight = clientHeight;\n    }\n\n    if (contentWidth === +contentWidth) {\n      self.__contentWidth = contentWidth;\n    }\n\n    if (contentHeight === +contentHeight) {\n      self.__contentHeight = contentHeight;\n    }\n\n    // Refresh maximums\n    self.__computeScrollMax();\n\n    // Refresh scroll position\n    self.scrollTo(self.__scrollLeft, self.__scrollTop, animate);\n  },\n\n  /**\n   * Sets the client coordinates in relation to the document.\n   *\n   * @param left {Integer ? 0} Left position of outer element\n   * @param top {Integer ? 0} Top position of outer element\n   */\n  setPosition: function(left, top) {\n    var self = this;\n\n    self.__clientLeft = left || 0;\n    self.__clientTop = top || 0;\n  },\n\n  /**\n   * Configures the snapping (when snapping is active)\n   *\n   * @param width {Integer} Snapping width\n   * @param height {Integer} Snapping height\n   */\n  setSnapSize: function(width, height) {\n    var self = this;\n\n    self.__snapWidth = width;\n    self.__snapHeight = height;\n  },\n\n  /**\n   * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever\n   * the user event is released during visibility of this zone. This was introduced by some apps on iOS like\n   * the official Twitter client.\n   *\n   * @param height {Integer} Height of pull-to-refresh zone on top of rendered list\n   * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.\n   * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.\n   * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.\n   */\n  activatePullToRefresh: function(\n    height,\n    {\n      activateCallback,\n      deactivateCallback,\n      startCallback,\n      beforeDeactivateCallback\n    }\n  ) {\n    var self = this;\n\n    self.__refreshHeight = height;\n    self.__refreshActivate = activateCallback;\n    self.__refreshBeforeDeactivate = beforeDeactivateCallback;\n    self.__refreshDeactivate = deactivateCallback;\n    self.__refreshStart = startCallback;\n  },\n  activatePushToLoad: function(\n    height,\n    {\n      activateCallback,\n      deactivateCallback,\n      startCallback,\n      beforeDeactivateCallback\n    }\n  ) {\n    var self = this;\n\n    self.__loadHeight = height;\n    self.__loadActivate = activateCallback;\n    self.__loadBeforeDeactivate = beforeDeactivateCallback;\n    self.__loadDeactivate = deactivateCallback;\n    self.__loadStart = startCallback;\n  },\n\n  /**\n   * Starts pull-to-refresh manually.\n   */\n  triggerRefreshOrLoad: function(type = 'refresh') {\n    var wasDecelerating = this.__isDecelerating;\n    if (wasDecelerating) {\n      core.effect.Animate.stop(wasDecelerating);\n      this.__isDecelerating = false;\n    }\n    // Use publish instead of scrollTo to allow scrolling to out of boundary position\n    // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n    if (type == 'refresh') {\n      this.__publish(\n        this.__scrollLeft,\n        -this.__refreshHeight,\n        this.__zoomLevel,\n        true\n      );\n      if (this.__refreshStart) {\n        this.__refreshStart();\n        this.__refreshActive = true;\n      }\n    } else {\n      this.__publish(\n        this.__scrollLeft,\n        this.__maxScrollTop + this.__loadHeight,\n        this.__zoomLevel,\n        true\n      );\n      if (this.__loadStart) {\n        this.__loadStart();\n        this.__loadActive = true;\n      }\n    }\n  },\n\n  /**\n   * Signalizes that pull-to-refresh is finished.\n   */\n  finishRefreshOrLoad: function() {\n    var self = this;\n\n    if (self.__refreshBeforeDeactivate && self.__refreshActive) {\n      self.__refreshActive = false;\n      self.__refreshBeforeDeactivate(function() {\n        if (self.__refreshDeactivate) {\n          self.__refreshDeactivate();\n        }\n        self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n      });\n    } else if (self.__refreshDeactivate && self.__refreshActive) {\n      self.__refreshActive = false;\n      self.__refreshDeactivate();\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n    }\n\n    if (self.__loadBeforeDeactivate && self.__loadActive) {\n      self.__loadActive = false;\n      self.__loadBeforeDeactivate(function() {\n        if (self.__loadDeactivate) {\n          self.__loadDeactivate();\n        }\n        self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n      });\n    } else if (self.__loadDeactivate && self.__loadActive) {\n      self.__loadActive = false;\n      self.__loadDeactivate();\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n    }\n  },\n\n  /**\n   * Returns the scroll position and zooming values\n   *\n   * @return {Map} `left` and `top` scroll position and `zoom` level\n   */\n  getValues: function() {\n    var self = this;\n\n    return {\n      left: self.__scrollLeft,\n      top: self.__scrollTop,\n      zoom: self.__zoomLevel\n    };\n  },\n\n  /**\n   * Returns the maximum scroll values\n   *\n   * @return {Map} `left` and `top` maximum scroll values\n   */\n  getScrollMax: function() {\n    var self = this;\n\n    return {\n      left: self.__maxScrollLeft,\n      top: self.__maxScrollTop\n    };\n  },\n\n  /**\n   * Zooms to the given level. Supports optional animation. Zooms\n   * the center when no coordinates are given.\n   *\n   * @param level {Number} Level to zoom to\n   * @param animate {Boolean ? false} Whether to use animation\n   * @param originLeft {Number ? null} Zoom in at given left coordinate\n   * @param originTop {Number ? null} Zoom in at given top coordinate\n   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n   */\n  zoomTo: function(level, animate, originLeft, originTop, callback) {\n    var self = this;\n\n    if (!self.options.zooming) {\n      throw new Error('Zooming is not enabled!');\n    }\n\n    // Add callback if exists\n    if (callback) {\n      self.__zoomComplete = callback;\n    }\n\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      core.effect.Animate.stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n    }\n\n    var oldLevel = self.__zoomLevel;\n\n    // Normalize input origin to center of viewport if not defined\n    if (originLeft == null) {\n      originLeft = self.__clientWidth / 2;\n    }\n\n    if (originTop == null) {\n      originTop = self.__clientHeight / 2;\n    }\n\n    // Limit level according to configuration\n    level = Math.max(\n      Math.min(level, self.options.maxZoom),\n      self.options.minZoom\n    );\n\n    // Recompute maximum values while temporary tweaking maximum scroll ranges\n    self.__computeScrollMax(level);\n\n    // Recompute left and top coordinates based on new zoom level\n    var left = (originLeft + self.__scrollLeft) * level / oldLevel - originLeft;\n    var top = (originTop + self.__scrollTop) * level / oldLevel - originTop;\n\n    // Limit x-axis\n    if (left > self.__maxScrollLeft) {\n      left = self.__maxScrollLeft;\n    } else if (left < 0) {\n      left = 0;\n    }\n\n    // Limit y-axis\n    if (top > self.__maxScrollTop) {\n      top = self.__maxScrollTop;\n    } else if (top < 0) {\n      top = 0;\n    }\n\n    // Push values out\n    self.__publish(left, top, level, animate);\n  },\n\n  /**\n   * Zooms the content by the given factor.\n   *\n   * @param factor {Number} Zoom by given factor\n   * @param animate {Boolean ? false} Whether to use animation\n   * @param originLeft {Number ? 0} Zoom in at given left coordinate\n   * @param originTop {Number ? 0} Zoom in at given top coordinate\n   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n   */\n  zoomBy: function(factor, animate, originLeft, originTop, callback) {\n    var self = this;\n\n    self.zoomTo(\n      self.__zoomLevel * factor,\n      animate,\n      originLeft,\n      originTop,\n      callback\n    );\n  },\n\n  /**\n   * Scrolls to the given position. Respect limitations and snapping automatically.\n   *\n   * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>\n   * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>\n   * @param animate {Boolean?false} Whether the scrolling should happen using an animation\n   * @param zoom {Number?null} Zoom level to go to\n   */\n  scrollTo: function(left, top, animate, zoom, force) {\n    var self = this;\n\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      core.effect.Animate.stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n    }\n\n    // Correct coordinates based on new zoom level\n    if (zoom != null && zoom !== self.__zoomLevel) {\n      if (!self.options.zooming) {\n        throw new Error('Zooming is not enabled!');\n      }\n\n      left *= zoom;\n      top *= zoom;\n\n      // Recompute maximum values while temporary tweaking maximum scroll ranges\n      self.__computeScrollMax(zoom);\n    } else {\n      // Keep zoom when not defined\n      zoom = self.__zoomLevel;\n    }\n\n    if (!self.options.scrollingX && !force) {\n      left = self.__scrollLeft;\n    } else {\n      if (self.options.paging) {\n        left = Math.round(left / self.__clientWidth) * self.__clientWidth;\n      } else if (self.options.snapping) {\n        left = Math.round(left / self.__snapWidth) * self.__snapWidth;\n      }\n    }\n\n    if (!self.options.scrollingY && !force) {\n      top = self.__scrollTop;\n    } else {\n      if (self.options.paging) {\n        top = Math.round(top / self.__clientHeight) * self.__clientHeight;\n      } else if (self.options.snapping) {\n        top = Math.round(top / self.__snapHeight) * self.__snapHeight;\n      }\n    }\n\n    // Limit for allowed ranges\n    left = Math.max(Math.min(self.__maxScrollLeft, left), 0);\n    top = Math.max(Math.min(self.__maxScrollTop, top), 0);\n    // Don't animate when no change detected, still call publish to make sure\n    // that rendered position is really in-sync with internal data\n    if (left === self.__scrollLeft && top === self.__scrollTop) {\n      animate = false;\n    }\n\n    // Publish new values\n    if (!self.__isTracking) {\n      self.__publish(left, top, zoom, animate);\n    }\n  },\n\n  /**\n   * Scroll by the given offset\n   *\n   * @param left {Number ? 0} Scroll x-axis by given offset\n   * @param top {Number ? 0} Scroll x-axis by given offset\n   * @param animate {Boolean ? false} Whether to animate the given change\n   */\n  scrollBy: function(left, top, animate) {\n    var self = this;\n\n    var startLeft = self.__isAnimating\n      ? self.__scheduledLeft\n      : self.__scrollLeft;\n    var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;\n\n    self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);\n  },\n  getCurrentPage() {\n    this.__computePage();\n    return {\n      x: this.__currentPageX,\n      y: this.__currentPageY\n    };\n  },\n\n  goToPage({ x, y }, animate) {\n    if (isNaN(x)) {\n      x = 1;\n    }\n    if (isNaN(y)) {\n      y = 1;\n    }\n    this.scrollTo(\n      (x - 1) * this.__clientWidth,\n      (y - 1) * this.__clientHeight,\n      animate\n    );\n  },\n\n  /*\n\t---------------------------------------------------------------------------\n\t\tEVENT CALLBACKS\n\t---------------------------------------------------------------------------\n\t*/\n\n  /**\n   * Mouse wheel handler for zooming support\n   */\n  doMouseZoom: function(wheelDelta, timeStamp, pageX, pageY) {\n    var self = this;\n    var change = wheelDelta > 0 ? 0.97 : 1.03;\n\n    return self.zoomTo(\n      self.__zoomLevel * change,\n      false,\n      pageX - self.__clientLeft,\n      pageY - self.__clientTop\n    );\n  },\n\n  /**\n   * Touch start handler for scrolling support\n   */\n  doTouchStart: function(touches, timeStamp) {\n    // Array-like check is enough here\n    if (touches.length == null) {\n      throw new Error('Invalid touch list: ' + touches);\n    }\n\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== 'number') {\n      throw new Error('Invalid timestamp value: ' + timeStamp);\n    }\n\n    var self = this;\n\n    // Reset interruptedAnimation flag\n    self.__interruptedAnimation = true;\n\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      core.effect.Animate.stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n      self.__interruptedAnimation = true;\n    }\n\n    // Stop animation\n    if (self.__isAnimating) {\n      core.effect.Animate.stop(self.__isAnimating);\n      self.__isAnimating = false;\n      self.__interruptedAnimation = true;\n    }\n\n    // Use center point when dealing with two fingers\n    var currentTouchLeft, currentTouchTop;\n    var isSingleTouch = touches.length === 1;\n    if (isSingleTouch) {\n      currentTouchLeft = touches[0].pageX;\n      currentTouchTop = touches[0].pageY;\n    } else {\n      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n    }\n\n    // Store initial positions\n    self.__initialTouchLeft = currentTouchLeft;\n    self.__initialTouchTop = currentTouchTop;\n\n    // Store current zoom level\n    self.__zoomLevelStart = self.__zoomLevel;\n\n    // Store initial touch positions\n    self.__lastTouchLeft = currentTouchLeft;\n    self.__lastTouchTop = currentTouchTop;\n\n    // Store initial move time stamp\n    self.__lastTouchMove = timeStamp;\n\n    // Reset initial scale\n    self.__lastScale = 1;\n\n    // Reset locking flags\n    self.__enableScrollX = !isSingleTouch && self.options.scrollingX;\n    self.__enableScrollY = !isSingleTouch && self.options.scrollingY;\n\n    // Reset tracking flag\n    self.__isTracking = true;\n\n    // Reset deceleration complete flag\n    self.__didDecelerationComplete = false;\n\n    // Dragging starts directly with two fingers, otherwise lazy with an offset\n    self.__isDragging = !isSingleTouch;\n\n    // Some features are  in multi touch scenarios\n    self.__isSingleTouch = isSingleTouch;\n\n    // Clearing data structure\n    self.__positions = [];\n  },\n\n  /**\n   * Touch move handler for scrolling support\n   */\n  doTouchMove: function(touches, timeStamp, scale) {\n    // Array-like check is enough here\n    if (touches.length == null) {\n      throw new Error('Invalid touch list: ' + touches);\n    }\n\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== 'number') {\n      throw new Error('Invalid timestamp value: ' + timeStamp);\n    }\n\n    var self = this;\n\n    // Ignore event when tracking is not enabled (event might be outside of element)\n    if (!self.__isTracking) {\n      return;\n    }\n\n    var currentTouchLeft, currentTouchTop;\n\n    // Compute move based around of center of fingers\n    if (touches.length === 2) {\n      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n    } else {\n      currentTouchLeft = touches[0].pageX;\n      currentTouchTop = touches[0].pageY;\n    }\n\n    var positions = self.__positions;\n\n    // Are we already is dragging mode?\n    if (self.__isDragging) {\n      // Compute move distance\n      var moveX = currentTouchLeft - self.__lastTouchLeft;\n      var moveY = currentTouchTop - self.__lastTouchTop;\n\n      // Read previous scroll position and zooming\n      var scrollLeft = self.__scrollLeft;\n      var scrollTop = self.__scrollTop;\n      var level = self.__zoomLevel;\n\n      // Work with scaling\n      if (scale != null && self.options.zooming) {\n        var oldLevel = level;\n\n        // Recompute level based on previous scale and new scale\n        level = level / self.__lastScale * scale;\n\n        // Limit level according to configuration\n        level = Math.max(\n          Math.min(level, self.options.maxZoom),\n          self.options.minZoom\n        );\n\n        // Only do further compution when change happened\n        if (oldLevel !== level) {\n          // Compute relative event position to container\n          var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;\n          var currentTouchTopRel = currentTouchTop - self.__clientTop;\n\n          // Recompute left and top coordinates based on new zoom level\n          scrollLeft =\n            (currentTouchLeftRel + scrollLeft) * level / oldLevel -\n            currentTouchLeftRel;\n          scrollTop =\n            (currentTouchTopRel + scrollTop) * level / oldLevel -\n            currentTouchTopRel;\n\n          // Recompute max scroll values\n          self.__computeScrollMax(level);\n        }\n      }\n\n      if (self.__enableScrollX) {\n        scrollLeft -= moveX * this.options.speedMultiplier;\n        var maxScrollLeft = self.__maxScrollLeft;\n\n        if (scrollLeft > maxScrollLeft || scrollLeft < 0) {\n          // Slow down on the edges\n          if (self.options.bouncing) {\n            scrollLeft += moveX / 2 * this.options.speedMultiplier;\n          } else if (scrollLeft > maxScrollLeft) {\n            scrollLeft = maxScrollLeft;\n          } else {\n            scrollLeft = 0;\n          }\n        }\n      }\n\n      // Compute new vertical scroll position\n      if (self.__enableScrollY) {\n        scrollTop -= moveY * this.options.speedMultiplier;\n        var maxScrollTop = self.__maxScrollTop;\n\n        if (scrollTop > maxScrollTop || scrollTop < 0) {\n          // Slow down on the edges\n          if (self.options.bouncing) {\n            scrollTop += moveY / 2 * this.options.speedMultiplier;\n\n            // Support pull-to-refresh (only when only y is scrollable)\n            if (\n              !self.__enableScrollX &&\n              (self.__refreshHeight != null || self.__loadHeight != null)\n            ) {\n              if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {\n                self.__refreshActive = true;\n                if (self.__refreshActivate) {\n                  self.__refreshActivate();\n                }\n              } else if (\n                self.__refreshActive &&\n                scrollTop > -self.__refreshHeight\n              ) {\n                self.__refreshActive = false;\n                if (self.__refreshDeactivate) {\n                  self.__refreshDeactivate();\n                }\n              }\n              // handle for push-load\n              else if (\n                !self.__loadActive &&\n                scrollTop >= self.__maxScrollTop + self.__loadHeight\n              ) {\n                self.__loadActive = true;\n                if (self.__loadActivate) {\n                  self.__loadActivate();\n                }\n              } else if (\n                self.__refreshActive &&\n                scrollTop < self.__maxScrollTop + self.__loadHeight\n              ) {\n                self.__loadActive = false;\n                if (self.__loadDeactivate) {\n                  self.__loadDeactivate();\n                }\n              }\n            }\n          } else if (scrollTop > maxScrollTop) {\n            scrollTop = maxScrollTop;\n          } else {\n            scrollTop = 0;\n          }\n        }\n      }\n\n      // Keep list from growing infinitely (holding min 10, max 20 measure points)\n      if (positions.length > 60) {\n        positions.splice(0, 30);\n      }\n\n      // Track scroll movement for decleration\n      positions.push(scrollLeft, scrollTop, timeStamp);\n\n      // Sync scroll position\n      self.__publish(scrollLeft, scrollTop, level);\n\n      // Otherwise figure out whether we are switching into dragging mode now.\n    } else {\n      var minimumTrackingForScroll = self.options.locking ? 3 : 0;\n      var minimumTrackingForDrag = 5;\n\n      var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);\n      var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);\n\n      self.__enableScrollX =\n        self.options.scrollingX && distanceX >= minimumTrackingForScroll;\n      self.__enableScrollY =\n        self.options.scrollingY && distanceY >= minimumTrackingForScroll;\n\n      positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);\n\n      self.__isDragging =\n        (self.__enableScrollX || self.__enableScrollY) &&\n        (distanceX >= minimumTrackingForDrag ||\n          distanceY >= minimumTrackingForDrag);\n      if (self.__isDragging) {\n        self.__interruptedAnimation = false;\n      }\n    }\n\n    // Update last touch positions and time stamp for next event\n    self.__lastTouchLeft = currentTouchLeft;\n    self.__lastTouchTop = currentTouchTop;\n    self.__lastTouchMove = timeStamp;\n    self.__lastScale = scale;\n  },\n\n  /**\n   * Touch end handler for scrolling support\n   */\n  doTouchEnd: function(timeStamp) {\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== 'number') {\n      throw new Error('Invalid timestamp value: ' + timeStamp);\n    }\n\n    var self = this;\n\n    // Ignore event when tracking is not enabled (no touchstart event on element)\n    // This is required as this listener ('touchmove') sits on the document and not on the element itself.\n    if (!self.__isTracking) {\n      return;\n    }\n\n    // Not touching anymore (when two finger hit the screen there are two touch end events)\n    self.__isTracking = false;\n\n    // Be sure to reset the dragging flag now. Here we also detect whether\n    // the finger has moved fast enough to switch into a deceleration animation.\n    if (self.__isDragging) {\n      // Reset dragging flag\n      self.__isDragging = false;\n\n      // Start deceleration\n      // Verify that the last move detected was in some relevant time frame\n      if (\n        self.__isSingleTouch &&\n        self.options.animating &&\n        timeStamp - self.__lastTouchMove <= 100\n      ) {\n        // Then figure out what the scroll position was about 100ms ago\n        var positions = self.__positions;\n        var endPos = positions.length - 1;\n        var startPos = endPos;\n\n        // Move pointer to position measured 100ms ago\n        for (\n          var i = endPos;\n          i > 0 && positions[i] > self.__lastTouchMove - 100;\n          i -= 3\n        ) {\n          startPos = i;\n        }\n\n        // If start and stop position is identical in a 100ms timeframe,\n        // we cannot compute any useful deceleration.\n        if (startPos !== endPos) {\n          // Compute relative movement between these two points\n          var timeOffset = positions[endPos] - positions[startPos];\n          var movedLeft = self.__scrollLeft - positions[startPos - 2];\n          var movedTop = self.__scrollTop - positions[startPos - 1];\n\n          // Based on 50ms compute the movement to apply for each render step\n          self.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);\n          self.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60);\n\n          // How much velocity is required to start the deceleration\n          var minVelocityToStartDeceleration =\n            self.options.paging || self.options.snapping ? 4 : 1;\n\n          // Verify that we have enough velocity to start deceleration\n          if (\n            Math.abs(self.__decelerationVelocityX) >\n              minVelocityToStartDeceleration ||\n            Math.abs(self.__decelerationVelocityY) >\n              minVelocityToStartDeceleration\n          ) {\n            // Deactivate pull-to-refresh when decelerating\n            if (!self.__refreshActive && !self.__loadActive) {\n              self.__startDeceleration(timeStamp);\n            }\n          } else {\n            self.__scrollComplete();\n          }\n        } else {\n          self.__scrollComplete();\n        }\n      } else if (timeStamp - self.__lastTouchMove > 100) {\n        self.__scrollComplete();\n      }\n    }\n\n    // If this was a slower move it is per default non decelerated, but this\n    // still means that we want snap back to the bounds which is done here.\n    // This is placed outside the condition above to improve edge case stability\n    // e.g. touchend fired without enabled dragging. This should normally do not\n    // have modified the scroll positions or even showed the scrollbars though.\n    if (!self.__isDecelerating) {\n      if (self.__refreshActive && self.__refreshStart) {\n        // Use publish instead of scrollTo to allow scrolling to out of boundary position\n        // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n        self.__publish(\n          self.__scrollLeft,\n          -self.__refreshHeight,\n          self.__zoomLevel,\n          true\n        );\n\n        if (self.__refreshStart) {\n          self.__refreshStart();\n        }\n      } else if (self.__loadActive && self.__loadStart) {\n        // Use publish instead of scrollTo to allow scrolling to out of boundary position\n        // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n        self.__publish(\n          self.__scrollLeft,\n          self.__maxScrollTop + self.__loadHeight,\n          self.__zoomLevel,\n          true\n        );\n\n        if (self.__loadStart) {\n          self.__loadStart();\n        }\n      } else {\n        if (self.__interruptedAnimation || self.__isDragging) {\n          self.__scrollComplete();\n        }\n        self.scrollTo(\n          self.__scrollLeft,\n          self.__scrollTop,\n          true,\n          self.__zoomLevel\n        );\n\n        // Directly signalize deactivation (nothing todo on refresh?)\n        if (self.__refreshActive) {\n          self.__refreshActive = false;\n          if (self.__refreshDeactivate) {\n            self.__refreshDeactivate();\n          }\n        } else if (self.__loadActive) {\n          self.__loadActive = false;\n          if (self.__loadDeactivate) {\n            self.__loadDeactivate();\n          }\n        }\n      }\n    }\n\n    // Fully cleanup list\n    self.__positions.length = 0;\n  },\n\n  /** Handle for scroll/publish */\n  onScroll: NOOP,\n\n  stop: function() {\n    var self = this;\n\n    self.__disable = true;\n  },\n  start: function() {\n    self.__disable = true;\n  },\n  /*\n\t---------------------------------------------------------------------------\n\t\tPRIVATE API\n\t---------------------------------------------------------------------------\n\t*/\n\n  /**\n   * Applies the scroll position to the content element\n   *\n   * @param left {Number} Left scroll position\n   * @param top {Number} Top scroll position\n   * @param animate {Boolean?false} Whether animation should be used to move to the new coordinates\n   */\n  __publish: function(left, top, zoom, animate) {\n    var self = this;\n    if (self.__disable) {\n      return;\n    }\n    if (isNaN(left)) {\n      left = this.__scrollLeft;\n    }\n    if (isNaN(top)) {\n      top = this.__scrollTop;\n    }\n    // Remember whether we had an animation, then we try to continue based on the current \"drive\" of the animation\n    var wasAnimating = self.__isAnimating;\n    if (wasAnimating) {\n      core.effect.Animate.stop(wasAnimating);\n      self.__isAnimating = false;\n    }\n\n    if (animate && self.options.animating) {\n      // Keep scheduled positions for scrollBy/zoomBy functionality\n      self.__scheduledLeft = left;\n      self.__scheduledTop = top;\n      self.__scheduledZoom = zoom;\n\n      var oldLeft = self.__scrollLeft;\n      var oldTop = self.__scrollTop;\n      var oldZoom = self.__zoomLevel;\n\n      var diffLeft = left - oldLeft;\n      var diffTop = top - oldTop;\n      var diffZoom = zoom - oldZoom;\n\n      var step = function(percent, now, render) {\n        if (render) {\n          self.__scrollLeft = oldLeft + diffLeft * percent;\n          self.__scrollTop = oldTop + diffTop * percent;\n          self.__zoomLevel = oldZoom + diffZoom * percent;\n\n          // Push values out\n          if (self.__callback) {\n            self.__callback(\n              self.__scrollLeft,\n              self.__scrollTop,\n              self.__zoomLevel\n            );\n            self.onScroll();\n          }\n        }\n      };\n\n      var verify = function(id) {\n        return self.__isAnimating === id;\n      };\n\n      var completed = function(\n        renderedFramesPerSecond,\n        animationId,\n        wasFinished\n      ) {\n        if (animationId === self.__isAnimating) {\n          self.__isAnimating = false;\n        }\n        if (self.__didDecelerationComplete || wasFinished) {\n          self.__scrollComplete();\n        }\n\n        if (self.options.zooming) {\n          self.__computeScrollMax();\n          if (self.__zoomComplete) {\n            self.__zoomComplete();\n            self.__zoomComplete = null;\n          }\n        }\n      };\n\n      // When continuing based on previous animation we choose an ease-out animation instead of ease-in-out\n      self.__isAnimating = core.effect.Animate.start(\n        step,\n        verify,\n        completed,\n        self.options.animationDuration,\n        wasAnimating ? animatingMethod : noAnimatingMethod\n      );\n    } else {\n      self.__scheduledLeft = self.__scrollLeft = left;\n      self.__scheduledTop = self.__scrollTop = top;\n      self.__scheduledZoom = self.__zoomLevel = zoom;\n\n      // Push values out\n      if (self.__callback) {\n        self.__callback(left, top, zoom);\n        self.onScroll();\n      }\n\n      // Fix max scroll ranges\n      if (self.options.zooming) {\n        self.__computeScrollMax();\n        if (self.__zoomComplete) {\n          self.__zoomComplete();\n          self.__zoomComplete = null;\n        }\n      }\n    }\n  },\n\n  /**\n   * Recomputes scroll minimum values based on client dimensions and content dimensions.\n   */\n  __computeScrollMax: function(zoomLevel) {\n    var self = this;\n\n    if (zoomLevel == null) {\n      zoomLevel = self.__zoomLevel;\n    }\n\n    self.__maxScrollLeft = Math.max(\n      self.__contentWidth * zoomLevel - self.__clientWidth,\n      0\n    );\n    self.__maxScrollTop = Math.max(\n      self.__contentHeight * zoomLevel - self.__clientHeight,\n      0\n    );\n  },\n  /** compute current page total page */\n  __computePage: function() {\n    var self = this;\n    var clientWidth = self.__clientWidth;\n    var clientHeight = self.__clientHeight;\n    var left = self.__scrollLeft;\n    var top = self.__scrollTop;\n    self.__totalXPage = Math.ceil(self.__contentWidth / clientWidth);\n    self.__currentPageX = Math.ceil(left / clientWidth + 1);\n    self.__totalYPage = Math.ceil(self.__contentHeight / clientHeight);\n    self.__currentPageY = Math.ceil(top / clientHeight + 1);\n  },\n  /** complete scroll*/\n  __scrollComplete: function() {\n    var self = this;\n    self.options.scrollingComplete();\n  },\n  /*\n\t---------------------------------------------------------------------------\n\t\tANIMATION (DECELERATION) SUPPORT\n\t---------------------------------------------------------------------------\n\t*/\n\n  /**\n   * Called when a touch sequence end and the speed of the finger was high enough\n   * to switch into deceleration mode.\n   */\n  __startDeceleration: function() {\n    var self = this;\n\n    if (self.options.paging) {\n      var scrollLeft = Math.max(\n        Math.min(self.__scrollLeft, self.__maxScrollLeft),\n        0\n      );\n      var scrollTop = Math.max(\n        Math.min(self.__scrollTop, self.__maxScrollTop),\n        0\n      );\n      var clientWidth = self.__clientWidth;\n      var clientHeight = self.__clientHeight;\n\n      // We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.\n      // Each page should have exactly the size of the client area.\n      self.__minDecelerationScrollLeft =\n        Math.floor(scrollLeft / clientWidth) * clientWidth;\n      self.__minDecelerationScrollTop =\n        Math.floor(scrollTop / clientHeight) * clientHeight;\n      self.__maxDecelerationScrollLeft =\n        Math.ceil(scrollLeft / clientWidth) * clientWidth;\n      self.__maxDecelerationScrollTop =\n        Math.ceil(scrollTop / clientHeight) * clientHeight;\n    } else {\n      self.__minDecelerationScrollLeft = 0;\n      self.__minDecelerationScrollTop = 0;\n      self.__maxDecelerationScrollLeft = self.__maxScrollLeft;\n      self.__maxDecelerationScrollTop = self.__maxScrollTop;\n    }\n\n    // Wrap class method\n    var step = function(percent, now, render) {\n      self.__stepThroughDeceleration(render);\n    };\n\n    // How much velocity is required to keep the deceleration running\n    var minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.001;\n\n    // Detect whether it's still worth to continue animating steps\n    // If we are already slow enough to not being user perceivable anymore, we stop the whole process here.\n    var verify = function() {\n      var shouldContinue =\n        Math.abs(self.__decelerationVelocityX) >=\n          minVelocityToKeepDecelerating ||\n        Math.abs(self.__decelerationVelocityY) >= minVelocityToKeepDecelerating;\n      if (!shouldContinue) {\n        self.__didDecelerationComplete = true;\n      }\n      return shouldContinue;\n    };\n\n    var completed = function() {\n      if (!self.__isDecelerating) {\n        return;\n      }\n      self.__isDecelerating = false;\n      if (self.__didDecelerationComplete) {\n        self.__scrollComplete();\n      }\n\n      // Animate to grid when snapping is active, otherwise just fix out-of-boundary positions\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);\n    };\n\n    // Start animation and switch on flag\n    self.__isDecelerating = core.effect.Animate.start(step, verify, completed);\n  },\n\n  /**\n   * Called on every step of the animation\n   *\n   * @param inMemory {Boolean?false} Whether to not render the current step, but keep it in memory only. Used internally only!\n   */\n  __stepThroughDeceleration: function(render) {\n    var self = this;\n\n    //\n    // COMPUTE NEXT SCROLL POSITION\n    //\n\n    // Add deceleration to scroll position\n    var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;\n    var scrollTop = self.__scrollTop + self.__decelerationVelocityY;\n\n    //\n    // HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE\n    //\n\n    if (!self.options.bouncing) {\n      var scrollLeftFixed = Math.max(\n        Math.min(self.__maxDecelerationScrollLeft, scrollLeft),\n        self.__minDecelerationScrollLeft\n      );\n      if (scrollLeftFixed !== scrollLeft) {\n        scrollLeft = scrollLeftFixed;\n        self.__decelerationVelocityX = 0;\n      }\n\n      var scrollTopFixed = Math.max(\n        Math.min(self.__maxDecelerationScrollTop, scrollTop),\n        self.__minDecelerationScrollTop\n      );\n      if (scrollTopFixed !== scrollTop) {\n        scrollTop = scrollTopFixed;\n        self.__decelerationVelocityY = 0;\n      }\n    }\n\n    //\n    // UPDATE SCROLL POSITION\n    //\n\n    if (render) {\n      self.__publish(scrollLeft, scrollTop, self.__zoomLevel);\n    } else {\n      self.__scrollLeft = scrollLeft;\n      self.__scrollTop = scrollTop;\n    }\n\n    //\n    // SLOW DOWN\n    //\n\n    // Slow down velocity on every iteration\n    if (!self.options.paging) {\n      // This is the factor applied to every iteration of the animation\n      // to slow down the process. This should emulate natural behavior where\n      // objects slow down when the initiator of the movement is removed\n      var frictionFactor = 0.95;\n\n      self.__decelerationVelocityX *= frictionFactor;\n      self.__decelerationVelocityY *= frictionFactor;\n    }\n\n    //\n    // BOUNCING SUPPORT\n    //\n\n    if (self.options.bouncing) {\n      var scrollOutsideX = 0;\n      var scrollOutsideY = 0;\n\n      // This configures the amount of change applied to deceleration/acceleration when reaching boundaries\n      var penetrationDeceleration = self.options.penetrationDeceleration;\n      var penetrationAcceleration = self.options.penetrationAcceleration;\n\n      // Check limits\n      if (scrollLeft < self.__minDecelerationScrollLeft) {\n        scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;\n      } else if (scrollLeft > self.__maxDecelerationScrollLeft) {\n        scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;\n      }\n\n      if (scrollTop < self.__minDecelerationScrollTop) {\n        scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;\n      } else if (scrollTop > self.__maxDecelerationScrollTop) {\n        scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;\n      }\n\n      // Slow down until slow enough, then flip back to snap position\n      if (scrollOutsideX !== 0) {\n        if (scrollOutsideX * self.__decelerationVelocityX <= 0) {\n          self.__decelerationVelocityX +=\n            scrollOutsideX * penetrationDeceleration;\n        } else {\n          self.__decelerationVelocityX =\n            scrollOutsideX * penetrationAcceleration;\n        }\n      }\n\n      if (scrollOutsideY !== 0) {\n        if (scrollOutsideY * self.__decelerationVelocityY <= 0) {\n          self.__decelerationVelocityY +=\n            scrollOutsideY * penetrationDeceleration;\n        } else {\n          self.__decelerationVelocityY =\n            scrollOutsideY * penetrationAcceleration;\n        }\n      }\n    }\n  }\n};\n\n// Copy over members to prototype\nfor (var key in members) {\n  Scroller.prototype[key] = members[key];\n}\n","import Scroller from '../../third-party/scroller';\nimport { render } from '../../third-party/scroller/render';\nimport { listenContainer } from '../../third-party/scroller/listener';\n\n/**\n * @description refresh and load callback\n */\nfunction createStateCallbacks(type, stageName, vm, tipDom) {\n  const listeners = vm.$listeners;\n\n  let activateCallback = () => {\n    vm.vuescroll.state[stageName] = 'active';\n  };\n\n  let deactivateCallback = () => {\n    vm.vuescroll.state[stageName] = 'deactive';\n  };\n\n  let startCallback = () => {\n    vm.vuescroll.state[stageName] = 'start';\n    setTimeout(() => {\n      vm.scroller.finishRefreshOrLoad();\n    }, 2000);\n  };\n\n  let beforeDeactivateCallback = done => {\n    vm.vuescroll.state[stageName] = 'beforeDeactive';\n    setTimeout(function() {\n      done();\n    }, 500);\n  };\n  /* istanbul ignore if */\n  if (listeners[type + '-activate']) {\n    activateCallback = () => {\n      vm.vuescroll.state[stageName] = 'active';\n      vm.$emit(type + '-activate', vm, tipDom);\n    };\n  }\n  /* istanbul ignore if */\n  if (listeners[type + '-before-deactivate']) {\n    beforeDeactivateCallback = done => {\n      vm.vuescroll.state[stageName] = 'beforeDeactive';\n      vm.$emit(type + '-before-deactivate', vm, tipDom, done.bind(vm.scroller));\n    };\n  }\n  /* istanbul ignore if */\n  if (listeners[type + '-deactivate']) {\n    deactivateCallback = () => {\n      vm.vuescroll.state[stageName] = 'deactive';\n      vm.$emit(type + '-deactivate', vm, tipDom);\n    };\n  }\n  /* istanbul ignore if */\n  if (listeners[type + '-start']) {\n    startCallback = () => {\n      vm.vuescroll.state[stageName] = 'start';\n      vm.$emit(\n        type + '-start',\n        vm,\n        tipDom,\n        vm.scroller.finishRefreshOrLoad.bind(vm.scroller)\n      );\n    };\n  }\n\n  return {\n    activateCallback,\n    deactivateCallback,\n    startCallback,\n    beforeDeactivateCallback\n  };\n}\n\nexport default {\n  methods: {\n    // update scrollbar's size and pos  while in slide mode.\n    updateScroller() {\n      const clientWidth = this.$el.clientWidth;\n      const clientHeight = this.$el.clientHeight;\n      let contentWidth = this.scrollPanelElm.scrollWidth;\n      let contentHeight = this.scrollPanelElm.scrollHeight;\n      let refreshHeight = 0;\n      let loadHeight = 0;\n      // If the refresh option is true,let's  give a \"margin-top\" style to\n      // the refresh-tip dom. let it to be invisible when doesn't trigger\n      // refresh.\n      if (this.mergedOptions.vuescroll.pullRefresh.enable) {\n        const refreshDom =\n          this.$refs['refreshDom'].elm || this.$refs['refreshDom'];\n        refreshHeight = refreshDom.offsetHeight;\n        if (!refreshDom.style.marginTop) {\n          refreshDom.style.marginTop = -refreshHeight + 'px';\n        }\n      }\n      if (this.mergedOptions.vuescroll.pushLoad.enable) {\n        const loadDom = this.$refs['loadDom'].elm || this.$refs['loadDom'];\n        loadHeight = loadDom.offsetHeight;\n        //  hide the trailing load dom..\n        contentHeight -= loadHeight;\n      }\n      this.scroller.setDimensions(\n        clientWidth,\n        clientHeight,\n        contentWidth,\n        contentHeight,\n        false\n      );\n    },\n    registryScroller() {\n      const preventDefault = this.mergedOptions.vuescroll.scroller\n        .preventDefault;\n      const paging = this.mergedOptions.vuescroll.paging;\n      const snapping = this.mergedOptions.vuescroll.snapping.enable;\n      // disale zooming when refresh or load enabled\n      let zooming =\n        !this.refreshLoad &&\n        !paging &&\n        !snapping &&\n        this.mergedOptions.vuescroll.zooming;\n      const { scrollingY, scrollingX } = this.mergedOptions.scrollPanel;\n      // hadnle for scroll complete\n      const scrollingComplete = () => {\n        this.updateBarStateAndEmitEvent('handle-scroll-complete');\n      };\n      // Initialize Scroller\n      this.scroller = new Scroller(render(this.scrollPanelElm, window, 'px'), {\n        ...this.mergedOptions.vuescroll.scroller,\n        zooming,\n        scrollingY,\n        scrollingX: scrollingX && !this.refreshLoad,\n        animationDuration: this.mergedOptions.scrollPanel.speed,\n        paging,\n        snapping,\n        scrollingComplete\n      });\n      // if snapping enabled\n      // we should set snap size\n      if (snapping) {\n        this.scroller.setSnapSize(\n          this.mergedOptions.vuescroll.snapping.width,\n          this.mergedOptions.vuescroll.snapping.height\n        );\n      }\n      var rect = this.$el.getBoundingClientRect();\n      this.scroller.setPosition(\n        rect.left + this.$el.clientLeft,\n        rect.top + this.$el.clientTop\n      );\n      const cb = listenContainer(\n        this.$el,\n        this.scroller,\n        eventType => {\n          // Thie is to dispatch the event from the scroller.\n          // to let vuescroll refresh the dom\n          switch (eventType) {\n          case 'mousedown':\n            this.vuescroll.state.isDragging = true;\n            break;\n          case 'onscroll':\n            this.handleScroll(false);\n            break;\n          case 'mouseup':\n            this.vuescroll.state.isDragging = false;\n            break;\n          }\n        },\n        zooming,\n        preventDefault\n      );\n      // registry refresh\n      if (this.mergedOptions.vuescroll.pullRefresh.enable) {\n        this.registryEvent('refresh');\n      }\n      // registry load\n      if (this.mergedOptions.vuescroll.pushLoad.enable) {\n        this.registryEvent('load');\n      }\n      this.updateScroller();\n      return cb;\n    },\n    updateSlideModeBarState() {\n      // update slide mode scrollbars' state\n      let heightPercentage, widthPercentage;\n      const vuescroll = this.$el;\n      const scroller = this.scroller;\n      let outerLeft = 0;\n      let outerTop = 0;\n      const clientWidth = this.$el.clientHeight;\n      const clientHeight = this.$el.clientHeight;\n      const contentWidth = clientWidth + this.scroller.__maxScrollLeft;\n      const contentHeight = clientHeight + this.scroller.__maxScrollTop;\n      const __enableScrollX =\n        clientWidth < contentWidth && this.mergedOptions.scrollPanel.scrollingX;\n      const __enableScrollY =\n        clientHeight < contentHeight &&\n        this.mergedOptions.scrollPanel.scrollingY;\n      // out of horizontal bountry\n      if (__enableScrollX) {\n        /* istanbul ignore if */\n        if (scroller.__scrollLeft < 0) {\n          outerLeft = -scroller.__scrollLeft;\n        } /* istanbul ignore next */ else if (\n          scroller.__scrollLeft > scroller.__maxScrollLeft\n        ) {\n          outerLeft = scroller.__scrollLeft - scroller.__maxScrollLeft;\n        }\n      }\n      // out of vertical bountry\n      if (__enableScrollY) {\n        if (scroller.__scrollTop < 0) {\n          outerTop = -scroller.__scrollTop;\n        } else if (scroller.__scrollTop > scroller.__maxScrollTop) {\n          outerTop = scroller.__scrollTop - scroller.__maxScrollTop;\n        }\n      }\n      heightPercentage = (clientHeight * 100) / (contentHeight + outerTop);\n      widthPercentage = (clientWidth * 100) / (contentWidth + outerLeft);\n      const scrollTop = Math.min(\n        Math.max(0, scroller.__scrollTop),\n        scroller.__maxScrollTop\n      );\n      const scrollLeft = Math.min(\n        Math.max(0, scroller.__scrollLeft),\n        scroller.__maxScrollLeft\n      );\n      this.bar.vBar.state.posValue =\n        ((scrollTop + outerTop) * 100) / vuescroll.clientHeight;\n      this.bar.hBar.state.posValue =\n        ((scrollLeft + outerLeft) * 100) / vuescroll.clientWidth;\n      /* istanbul ignore if */\n      if (scroller.__scrollLeft < 0) {\n        this.bar.hBar.state.posValue = 0;\n      }\n      if (scroller.__scrollTop < 0) {\n        this.bar.vBar.state.posValue = 0;\n      }\n      this.bar.vBar.state.size =\n        heightPercentage < 100 ? heightPercentage + '%' : 0;\n      this.bar.hBar.state.size =\n        widthPercentage < 100 ? widthPercentage + '%' : 0;\n    },\n    registryEvent(type) {\n      const domName = type == 'refresh' ? 'refreshDom' : 'loadDom';\n      const activateFunc =\n        type == 'refresh'\n          ? this.scroller.activatePullToRefresh\n          : this.scroller.activatePushToLoad;\n      const stageName = type == 'refresh' ? 'refreshStage' : 'loadStage';\n      const tipDom = this.$refs[domName].elm || this.$refs[domName];\n      const cbs = createStateCallbacks(type, stageName, this, tipDom);\n      const height = tipDom.offsetHeight;\n      activateFunc.bind(this.scroller)(height, cbs);\n    }\n  }\n};\n","export default {\n  vertical: {\n    size: 'height',\n    opsSize: 'width',\n    posName: 'top',\n    opposName: 'bottom',\n    page: 'pageY',\n    scroll: 'scrollTop',\n    scrollSize: 'scrollHeight',\n    offset: 'offsetHeight',\n    client: 'clientY',\n    axis: 'Y'\n  },\n  horizontal: {\n    size: 'width',\n    opsSize: 'height',\n    posName: 'left',\n    opposName: 'right',\n    page: 'pageX',\n    scroll: 'scrollLeft',\n    scrollSize: 'scrollWidth',\n    offset: 'offsetWidth',\n    client: 'clientX',\n    axis: 'X'\n  }\n};\n","import scrollMap from '../../shared/scroll-map';\nimport { eventCenter, isSupportTouch, getRealParent } from '../../util';\n\nconst colorCache = {};\nconst rgbReg = /rgb\\(/;\nconst extractRgbColor = /rgb\\((.*)\\)/;\n\n/* istanbul ignore next */\nfunction createMouseEvent(ctx) {\n  const parent = getRealParent(ctx);\n\n  function mousedown(e) {\n    e.stopImmediatePropagation();\n    document.onselectstart = () => false;\n    ctx.axisStartPos =\n      e[ctx.bar.client] -\n      ctx.$refs['inner'].getBoundingClientRect()[ctx.bar.posName];\n    // tell parent that the mouse has been down.\n    ctx.$emit('setBarClick', true);\n    eventCenter(document, 'mousemove', mousemove);\n    eventCenter(document, 'mouseup', mouseup);\n  }\n  function mousemove(e) {\n    if (!ctx.axisStartPos) {\n      return;\n    }\n    const delta =\n      e[ctx.bar.client] - ctx.$el.getBoundingClientRect()[ctx.bar.posName];\n    const percent = (delta - ctx.axisStartPos) / ctx.$el[ctx.bar.offset];\n    parent.scrollTo(\n      {\n        [ctx.bar.axis.toLowerCase()]:\n          parent.$refs['scrollPanel'].$el[ctx.bar.scrollSize] * percent\n      },\n      false\n    );\n  }\n  function mouseup() {\n    ctx.$emit('setBarClick', false);\n    document.onselectstart = null;\n    parent.hideBar();\n    ctx.axisStartPos = 0;\n    eventCenter(document, 'mousemove', mousemove, false, 'off');\n    eventCenter(document, 'mouseup', mouseup, false, 'off');\n  }\n\n  return mousedown;\n}\n\n/* istanbul ignore next */\nfunction createTouchEvent(ctx) {\n  function touchstart(e) {\n    e.stopImmediatePropagation();\n    e.preventDefault();\n    document.onselectstart = () => false;\n    ctx.axisStartPos =\n      e.touches[0][ctx.bar.client] -\n      ctx.$refs['inner'].getBoundingClientRect()[ctx.bar.posName];\n    // tell parent that the mouse has been down.\n    ctx.$emit('setBarClick', true);\n    eventCenter(document, 'touchmove', touchmove);\n    eventCenter(document, 'touchend', touchend);\n  }\n  function touchmove(e) {\n    if (!ctx.axisStartPos) {\n      return;\n    }\n    const delta =\n      e.touches[0][ctx.bar.client] -\n      ctx.$el.getBoundingClientRect()[ctx.bar.posName];\n    const percent = (delta - ctx.axisStartPos) / ctx.$el[ctx.bar.offset];\n    parent.scrollTo(\n      {\n        [ctx.bar.axis.toLowerCase()]:\n          parent.$refs['scrollPanel'].$el[ctx.bar.scrollSize] * percent\n      },\n      false\n    );\n  }\n  function touchend() {\n    ctx.$emit('setBarClick', false);\n    document.onselectstart = null;\n    ctx.$parent.hideBar();\n    ctx.axisStartPos = 0;\n    eventCenter(document, 'touchmove', touchmove, false, 'off');\n    eventCenter(document, 'touchend', touchend, false, 'off');\n  }\n  return touchstart;\n}\n\nfunction getRgbAColor(color, opacity) {\n  const id = color + '&' + opacity;\n  if (colorCache[id]) {\n    return colorCache[id];\n  }\n\n  const div = document.createElement('div');\n  div.style.background = color;\n  document.body.appendChild(div);\n  const computedColor = window.getComputedStyle(div).backgroundColor;\n  document.body.removeChild(div);\n\n  /* istanbul ignore if */\n  if (!rgbReg.test(computedColor)) {\n    return color;\n  }\n\n  return (colorCache[id] = `rgba(${\n    extractRgbColor.exec(computedColor)[1]\n  }, ${opacity})`);\n}\n\n/* istanbul ignore next */\nfunction handleClickTrack(e) {\n  const ctx = this;\n  const parent = getRealParent(this);\n  const { client, offset, posName, axis } = ctx.bar;\n  const inner = ctx.$refs['inner'];\n  const barOffset = inner[offset];\n  const percent =\n    (e[client] -\n      e.currentTarget.getBoundingClientRect()[posName] -\n      barOffset / 2) /\n    e.currentTarget[offset];\n\n  parent.scrollTo({\n    [axis.toLowerCase()]: percent * 100 + '%'\n  });\n}\n\nexport default {\n  name: 'bar',\n  props: {\n    ops: {\n      type: Object,\n      required: true\n    },\n    state: {\n      type: Object,\n      required: true\n    },\n    type: {\n      type: String,\n      required: true\n    }\n  },\n  computed: {\n    bar() {\n      return scrollMap[this.type];\n    }\n  },\n  render(h) {\n    const vm = this;\n    const railBackgroundColor = getRgbAColor(\n      vm.ops.rail.background,\n      vm.ops.rail.opacity\n    );\n    let style = {\n      [vm.bar.size]: vm.state.size,\n      background: vm.ops.bar.background,\n      opacity: vm.state.opacity,\n      transform: `translate${scrollMap[vm.type].axis}(${vm.state.posValue}%)`\n    };\n    const bar = {\n      style: style,\n      class: `vuescroll-${vm.type}-bar`,\n      ref: 'inner',\n      on: {}\n    };\n\n    /* istanbul ignore if */\n    if (vm.ops.bar.hover) {\n      bar.on['mouseenter'] = () => {\n        vm.$el.style.background = vm.ops.hover;\n      };\n      bar.on['mouseleave'] = () => {\n        vm.$el.style.background = vm.ops.background;\n      };\n    }\n    /* istanbul ignore if */\n    if (isSupportTouch()) {\n      bar.on['touchstart'] = createTouchEvent(this);\n    } else {\n      bar.on['mousedown'] = createMouseEvent(this);\n    }\n\n    const rail = {\n      class: `vuescroll-${vm.type}-rail`,\n      style: {\n        borderRadius: vm.ops.rail[vm.bar.opsSize],\n        background: railBackgroundColor,\n        [vm.bar.opsSize]: vm.ops.rail[vm.bar.opsSize],\n        [vm.ops.rail.pos]: '2px'\n      },\n      on: {\n        click(e) /* istanbul ignore next */ {\n          handleClickTrack.call(vm, e);\n        }\n      }\n    };\n\n    return (\n      <div {...rail}>\n        <div {...bar} />\n      </div>\n    );\n  }\n};\n\n/**\n * create bars\n *\n * @param {any} size\n * @param {any} type\n */\nexport function createBar(h, vm, type) {\n  const axis = type === 'vertical' ? 'Y' : 'X';\n  const barType = `${type.charAt(0)}Bar`;\n  const railType = `${type.charAt(0)}Rail`;\n\n  if (\n    !vm.bar[barType].state.size ||\n    !vm.mergedOptions.scrollPanel['scrolling' + axis] ||\n    vm.mode == 'pure-native' ||\n    (vm.refreshLoad && type !== 'vertical' && vm.mode === 'slide')\n  ) {\n    return null;\n  }\n\n  const barData = {\n    props: {\n      type: type,\n      ops: {\n        bar: vm.mergedOptions.bar[barType],\n        rail: vm.mergedOptions.rail[railType]\n      },\n      state: vm.bar[barType].state\n    },\n    on: {\n      setBarClick: vm.setBarClick\n    },\n    ref: `${type}Bar`\n  };\n\n  return <bar {...barData} />;\n}\n","// begin importing\nimport {\n  getGutter,\n  isSupportGivenStyle,\n  isIE,\n  insertChildrenIntoSlot,\n  getRealParent\n} from '../../util';\nimport { createContent } from './vuescroll-content';\n// vueScrollPanel\nexport default {\n  name: 'scrollPanel',\n  props: { ops: { type: Object, required: true } },\n  methods: {\n    // trigger scrollPanel options initialScrollX,\n    // initialScrollY\n    updateInitialScroll() {\n      let x = 0;\n      let y = 0;\n      const parent = getRealParent(this);\n      if (this.ops.initialScrollX) {\n        x = this.ops.initialScrollX;\n      }\n      if (this.ops.initialScrollY) {\n        y = this.ops.initialScrollY;\n      }\n      if (x || y) {\n        parent.scrollTo({ x, y });\n      }\n    }\n  },\n  mounted() {\n    setTimeout(() => {\n      if (!this._isDestroyed) {\n        this.updateInitialScroll();\n      }\n    }, 0);\n  },\n  render(h) {\n    // eslint-disable-line\n    let data = {\n      class: ['vuescroll-panel']\n    };\n    const parent = getRealParent(this);\n    const customPanel = parent.$slots['scroll-panel'];\n    if (customPanel) {\n      return insertChildrenIntoSlot(h, customPanel, this.$slots.default, data);\n    }\n    return <div {...data}>{[this.$slots.default]}</div>;\n  }\n};\n\n/**\n * create a scrollPanel\n *\n * @param {any} size\n * @param {any} vm\n * @returns\n */\nexport function createPanel(h, vm) {\n  // scrollPanel data start\n  const scrollPanelData = {\n    ref: 'scrollPanel',\n    style: {},\n    class: [],\n    nativeOn: {\n      scroll: vm.handleScroll\n    },\n    props: {\n      ops: vm.mergedOptions.scrollPanel\n    }\n  };\n  // set overflow only if the in native mode\n  if (vm.mode == 'native') {\n    // dynamic set overflow scroll\n    // feat: #11\n    if (vm.mergedOptions.scrollPanel.scrollingY) {\n      scrollPanelData.style['overflowY'] = vm.bar.vBar.state.size\n        ? 'scroll'\n        : '';\n    } else {\n      scrollPanelData.style['overflowY'] = 'hidden';\n    }\n    if (vm.mergedOptions.scrollPanel.scrollingX) {\n      scrollPanelData.style['overflowX'] = vm.bar.hBar.state.size\n        ? 'scroll'\n        : '';\n    } else {\n      scrollPanelData.style['overflowX'] = 'hidden';\n    }\n    let gutter = getGutter();\n    /* istanbul ignore if */\n    if (!gutter && vm.mergedOptions.vuescroll.mode != 'pure-native') {\n      scrollPanelData.class.push('__hidebar');\n    } else {\n      // hide system bar by use a negative value px\n      // gutter should be 0 when manually disable scrollingX #14\n      if (vm.bar.vBar.state.size && vm.mergedOptions.scrollPanel.scrollingY) {\n        scrollPanelData.style.marginRight = `-${gutter}px`;\n      }\n      if (vm.bar.hBar.state.size && vm.mergedOptions.scrollPanel.scrollingX) {\n        scrollPanelData.style.height = `calc(100% + ${gutter}px)`;\n      }\n    }\n    // clear legency styles of slide mode...\n    scrollPanelData.style.transformOrigin = '';\n    scrollPanelData.style.transform = '';\n  } else if (vm.mode == 'slide') {\n    scrollPanelData.class.push('__slide');\n    let width = isSupportGivenStyle('width', 'fit-content');\n    if (width) {\n      scrollPanelData.style['width'] = width;\n    } /* istanbul ignore next */ else {\n      // fallback to inline block while\n      // doesn't support 'fit-content',\n      // this may cause some issues, but this\n      // can make `resize` event work...\n      scrollPanelData['display'] = 'inline-block';\n    }\n  } else if (vm.mode == 'pure-native') {\n    scrollPanelData.style['width'] = '100%';\n    if (vm.mergedOptions.scrollPanel.scrollingY) {\n      scrollPanelData.style['overflowY'] = 'auto';\n    } else {\n      scrollPanelData.style['overflowY'] = 'hidden';\n    }\n    if (vm.mergedOptions.scrollPanel.scrollingX) {\n      scrollPanelData.style['overflowX'] = 'auto';\n    } else {\n      scrollPanelData.style['overflowX'] = 'hidden';\n    }\n  }\n  return (\n    <scrollPanel {...scrollPanelData}>{createPanelChildren(vm, h)}</scrollPanel>\n  );\n}\n\nfunction createPanelChildren(vm, h) {\n  if (vm.mode == 'native') {\n    return [createContent(h, vm)];\n  } else if (vm.mode == 'slide') {\n    let renderChildren = [vm.$slots.default];\n    // handle for refresh\n    if (vm.mergedOptions.vuescroll.pullRefresh.enable) {\n      // use default refresh dom\n      let refreshDom = null;\n      refreshDom = createTipDom(h, vm, 'refresh');\n      renderChildren.unshift(\n        <div class=\"vuescroll-refresh\" ref=\"refreshDom\" key=\"refshDom\">\n          {[refreshDom, vm.pullRefreshTip]}\n        </div>\n      );\n    }\n    // handle for load\n    if (vm.mergedOptions.vuescroll.pushLoad.enable) {\n      let loadDom = null;\n      loadDom = createTipDom(h, vm, 'load');\n      // no slot load elm, use default\n      renderChildren.push(\n        <div class=\"vuescroll-load\" ref=\"loadDom\" key=\"loadDom\">\n          {[loadDom, vm.pushLoadTip]}\n        </div>\n      );\n    }\n    return renderChildren;\n  } else if (vm.mode == 'pure-native') {\n    return [vm.$slots.default];\n  }\n}\n// create load or refresh tip dom\nfunction createTipDom(h, vm, type) {\n  const stage = vm.vuescroll.state[`${type}Stage`];\n  let dom = null;\n  /* istanbul ignore if */\n  if ((dom = vm.$slots[`${type}-${stage}`])) {\n    return dom[0];\n  }\n  switch (stage) {\n    case 'deactive':\n      dom = (\n        <svg\n          version=\"1.1\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n          x=\"0px\"\n          y=\"0px\"\n          viewBox=\"0 0 1000 1000\"\n          enable-background=\"new 0 0 1000 1000\"\n          xmlSpace=\"preserve\"\n        >\n          <metadata> Svg Vector Icons : http://www.sfont.cn </metadata>\n          <g>\n            <g transform=\"matrix(1 0 0 -1 0 1008)\">\n              <path d=\"M10,543l490,455l490-455L885,438L570,735.5V18H430v717.5L115,438L10,543z\" />\n            </g>\n          </g>\n        </svg>\n      );\n      break;\n    case 'start':\n      // IE seems not supporting animateTransform\n      /* istanbul ignore if */\n      if (isIE()) {\n        dom = null;\n        break;\n      }\n      dom = (\n        <svg\n          version=\"1.1\"\n          id=\"loader-1\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n          x=\"0px\"\n          y=\"0px\"\n          viewBox=\"0 0 50 50\"\n          style=\"enable-background:new 0 0 50 50;\"\n          xmlSpace=\"preserve\"\n        >\n          <path\n            fill=\"#000\"\n            d=\"M43.935,25.145c0-10.318-8.364-18.683-18.683-18.683c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615c8.072,0,14.615,6.543,14.615,14.615H43.935z\"\n          >\n            <animateTransform\n              attributeType=\"xml\"\n              attributeName=\"transform\"\n              type=\"rotate\"\n              from=\"0 25 25\"\n              to=\"360 25 25\"\n              dur=\"0.6s\"\n              repeatCount=\"indefinite\"\n            />\n          </path>\n        </svg>\n      );\n      break;\n    case 'active':\n      dom = (\n        <svg\n          version=\"1.1\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n          xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n          x=\"0px\"\n          y=\"0px\"\n          viewBox=\"0 0 1000 1000\"\n          enable-background=\"new 0 0 1000 1000\"\n          xmlSpace=\"preserve\"\n        >\n          <metadata> Svg Vector Icons : http://www.sfont.cn </metadata>\n          <g>\n            <g transform=\"matrix(1 0 0 -1 0 1008)\">\n              <path d=\"M500,18L10,473l105,105l315-297.5V998h140V280.5L885,578l105-105L500,18z\" />\n            </g>\n          </g>\n        </svg>\n      );\n      break;\n  }\n  return dom;\n}\n","import {\n  deepMerge,\n  isSupportGivenStyle,\n  insertChildrenIntoSlot\n} from '../../util';\n// scrollContent\nexport default {\n  name: 'scrollContent',\n  functional: true,\n  props: {\n    ops: { type: Object },\n    state: {\n      type: Object,\n      default() {\n        return {};\n      }\n    }\n  },\n  render(h, { props, slots, parent }) {\n    let style = deepMerge(props.state.style, {});\n    style.position = 'relative';\n    let width = isSupportGivenStyle('width', 'fit-content');\n    if (width) {\n      style.width = width;\n    } /* istanbul ignore next */ else {\n      // fallback to inline block while\n      // doesn't support 'fit-content',\n      // this may cause some issues, but this\n      // can make `resize` event work...\n      style['display'] = 'inline-block';\n    }\n    style.boxSizing = 'border-box';\n    if (props.ops.padding) {\n      style[props.ops.paddPos] = props.ops.paddValue;\n    }\n\n    const propsData = {\n      style: style,\n      ref: 'scrollContent',\n      class: 'vuescroll-content'\n    };\n    const customContent = parent.$slots['scroll-content'];\n    if (customContent) {\n      return insertChildrenIntoSlot(\n        h,\n        customContent,\n        slots().default,\n        propsData\n      );\n    }\n    return <div {...propsData}>{slots().default}</div>;\n  }\n};\n\n/**\n * create scroll content\n *\n * @param {any} size\n * @param {any} vm\n * @returns\n */\nexport function createContent(h, vm) {\n  // scrollContent data\n  const scrollContentData = {\n    props: {\n      ops: vm.mergedOptions.scrollContent\n    }\n  };\n  return (\n    <scrollContent {...scrollContentData}>{[vm.$slots.default]}</scrollContent>\n  );\n}\n","import { listenResize } from '../third-party/resize-detector';\nimport hackLifecycle from '../mixins/hack-lifecycle';\nimport api from '../mixins/api';\nimport nativeMode from '../mixins/mode/native-mode';\nimport slideMode from '../mixins/mode/slide-mode';\n\nimport bar, { createBar } from './child-components/vuescroll-bar';\nimport scrollContent from './child-components/vuescroll-content';\nimport scrollPanel, { createPanel } from './child-components/vuescroll-panel';\n\nimport { smallChangeArray } from '../shared/constants';\nimport {\n  isChildInParent,\n  isSupportTouch,\n  insertChildrenIntoSlot\n} from '../util';\n\nfunction findValuesByMode(mode, vm) {\n  let axis = {};\n  switch (mode) {\n    case 'native':\n    case 'pure-native':\n      axis = {\n        x: vm.scrollPanelElm.scrollLeft,\n        y: vm.scrollPanelElm.scrollTop\n      };\n      break;\n    case 'slide':\n      axis = { x: vm.scroller.__scrollLeft, y: vm.scroller.__scrollTop };\n      break;\n  }\n  return axis;\n}\n\nconst vueScrollCore = {\n  name: 'vueScroll',\n  components: { bar, scrollContent, scrollPanel },\n  props: {\n    ops: { type: Object }\n  },\n  mixins: [hackLifecycle, api, nativeMode, slideMode],\n  mounted() {\n    if (!this.renderError) {\n      this.initVariables();\n\n      this.initWatchOpsChange();\n\n      this.refreshInternalStatus();\n\n      this.$nextTick(() => {\n        if (!this._isDestroyed) {\n          // update again to make sure bar's size is correct.\n          this.updateBarStateAndEmitEvent();\n          this.scrollToAnchor();\n        }\n      }, 0);\n    }\n  },\n  beforeDestroy() {\n    // remove registryed resize\n    if (this.destroyParentDomResize) {\n      this.destroyParentDomResize();\n      this.destroyParentDomResize = null;\n    }\n    if (this.destroyResize) {\n      this.destroyResize();\n      this.destroyResize = null;\n    }\n  },\n  data() {\n    return {\n      /**\n       * @description\n       * In state props of each components, we store the states of each\n       * components, and in mergedOptions props, we store the options\n       * that are megred from user-defined options to default options.\n       * @author wangyi7099\n       * @returns\n       */\n      vuescroll: {\n        state: {\n          isDragging: false,\n          isClickingBar: false,\n          pointerLeave: true,\n          internalScrollTop: 0,\n          internalScrollLeft: 0,\n          posX: null,\n          posY: null,\n          refreshStage: 'deactive',\n          loadStage: 'deactive',\n          height: '100%',\n          width: '100%'\n        }\n      },\n      bar: {\n        vBar: {\n          state: {\n            posValue: 0,\n            size: 0,\n            opacity: 0\n          }\n        },\n        hBar: {\n          state: {\n            posValue: 0,\n            size: 0,\n            opacity: 0\n          }\n        },\n        renderError: false\n      }\n    };\n  },\n  render(h) {\n    let vm = this;\n    if (vm.renderError) {\n      return <div>{[vm.$slots['default']]}</div>;\n    }\n    // vuescroll data\n    const vuescrollData = {\n      style: {\n        height: vm.vuescroll.state.height,\n        width: vm.vuescroll.state.width,\n        padding: 0\n      },\n      class: 'vuescroll'\n    };\n    if (!isSupportTouch()) {\n      vuescrollData.on = {\n        mouseenter() {\n          vm.vuescroll.state.pointerLeave = false;\n          vm.updateBarStateAndEmitEvent();\n        },\n        mouseleave() {\n          vm.vuescroll.state.pointerLeave = true;\n          vm.hideBar();\n        },\n        mousemove() /* istanbul ignore next */ {\n          vm.vuescroll.state.pointerLeave = false;\n          vm.updateBarStateAndEmitEvent();\n        }\n      };\n    } /* istanbul ignore next */ else {\n      vuescrollData.on = {\n        touchstart() {\n          vm.vuescroll.state.pointerLeave = false;\n          vm.updateBarStateAndEmitEvent();\n        },\n        touchend() {\n          vm.vuescroll.state.pointerLeave = true;\n          vm.hideBar();\n        },\n        touchmove() /* istanbul ignore next */ {\n          vm.vuescroll.state.pointerLeave = false;\n          vm.updateBarStateAndEmitEvent();\n        }\n      };\n    }\n    const customContainer = this.$slots['scroll-container'];\n    const ch = [\n      createPanel(h, vm),\n      createBar(h, vm, 'vertical'),\n      createBar(h, vm, 'horizontal')\n    ];\n\n    if (customContainer) {\n      return insertChildrenIntoSlot(h, customContainer, ch, vuescrollData);\n    }\n    return <div {...vuescrollData}>{ch}</div>;\n  },\n  computed: {\n    scrollPanelElm() {\n      return this.$refs['scrollPanel']._isVue\n        ? this.$refs['scrollPanel'].$el\n        : this.$refs['scrollPanel'];\n    },\n    scrollContentElm() {\n      return this.$refs['scrollContent']._isVue\n        ? this.$refs['scrollContent'].$el\n        : this.$refs['scrollContent'];\n    },\n    mode() {\n      return this.mergedOptions.vuescroll.mode;\n    },\n    pullRefreshTip() {\n      return this.mergedOptions.vuescroll.pullRefresh.tips[\n        this.vuescroll.state.refreshStage\n      ];\n    },\n    pushLoadTip() {\n      return this.mergedOptions.vuescroll.pushLoad.tips[\n        this.vuescroll.state.loadStage\n      ];\n    },\n    refreshLoad() {\n      return (\n        this.mergedOptions.vuescroll.pullRefresh.enable ||\n        this.mergedOptions.vuescroll.pushLoad.enable\n      );\n    }\n  },\n  methods: {\n    updateBarStateAndEmitEvent(eventType, nativeEvent = null) {\n      if (this.mode == 'native' || this.mode == 'pure-native') {\n        this.updateNativeModeBarState();\n      } else if (this.mode == 'slide') {\n        if (!this.scroller) {\n          return;\n        }\n        this.updateSlideModeBarState();\n      }\n      if (eventType) {\n        this.emitEvent(eventType, nativeEvent);\n      }\n      this.showAndDefferedHideBar();\n    },\n    updateMode() {\n      const x = this.vuescroll.state.internalScrollLeft;\n      const y = this.vuescroll.state.internalScrollTop;\n      if (this.destroyScroller) {\n        this.scroller.stop();\n        this.destroyScroller();\n        this.destroyScroller = null;\n      }\n      if (this.mode == 'slide') {\n        this.destroyScroller = this.registryScroller();\n      } else if (this.mode == 'native' || this.mode == 'pure-native') {\n        // remove the legacy transform style attribute\n        this.scrollPanelElm.style.transform = '';\n        this.scrollPanelElm.style.transformOrigin = '';\n      }\n      // keep the last-mode's position.\n      this.scrollTo({ x, y }, false, true /* force */);\n    },\n    handleScroll(nativeEvent) {\n      this.recordCurrentPos();\n      this.updateBarStateAndEmitEvent('handle-scroll', nativeEvent);\n    },\n    setBarClick(val) {\n      /* istanbul ignore next */\n      this.vuescroll.state.isClickingBar = val;\n    },\n    showAndDefferedHideBar() {\n      this.showBar();\n      if (this.timeoutId) {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = 0;\n      }\n      this.timeoutId = setTimeout(() => {\n        this.timeoutId = 0;\n        this.hideBar();\n      }, this.mergedOptions.bar.showDelay);\n    },\n    /**\n     *  emit user registry event\n     */\n    emitEvent(eventType, nativeEvent = null) {\n      let {\n        scrollHeight,\n        scrollWidth,\n        clientHeight,\n        clientWidth,\n        scrollTop,\n        scrollLeft\n      } = this.scrollPanelElm;\n      const vertical = {\n        type: 'vertical'\n      };\n      const horizontal = {\n        type: 'horizontal'\n      };\n      if (this.mode == 'slide') {\n        scrollHeight = this.scroller.__contentHeight;\n        scrollWidth = this.scroller.__contentWidth;\n        scrollTop = this.scroller.__scrollTop;\n        scrollLeft = this.scroller.__scrollLeft;\n        clientHeight = this.$el.clientHeight;\n        clientWidth = this.$el.clientWidth;\n      }\n      vertical['process'] = Math.min(\n        scrollTop / (scrollHeight - clientHeight),\n        1\n      );\n      horizontal['process'] = Math.min(\n        scrollLeft / (scrollWidth - clientWidth),\n        1\n      );\n      vertical['barSize'] = this.bar.vBar.state.size;\n      horizontal['barSize'] = this.bar.hBar.state.size;\n      vertical['scrollTop'] = scrollTop;\n      horizontal['scrollLeft'] = scrollLeft;\n      vertical['directionY'] = this.vuescroll.state.posY;\n      horizontal['directionX'] = this.vuescroll.state.posX;\n      this.$emit(eventType, vertical, horizontal, nativeEvent);\n    },\n    showBar() {\n      this.bar.vBar.state.opacity = this.mergedOptions.bar.vBar.opacity;\n      this.bar.hBar.state.opacity = this.mergedOptions.bar.hBar.opacity;\n    },\n    hideBar() {\n      // when in non-native mode dragging content\n      // in slide mode, just return\n      /* istanbul ignore next */\n      if (this.vuescroll.state.isDragging) {\n        return;\n      }\n      // add isClickingBar condition\n      // to prevent from hiding bar while dragging the bar\n      if (\n        !this.mergedOptions.bar.vBar.keepShow &&\n        !this.vuescroll.state.isClickingBar &&\n        this.vuescroll.state.pointerLeave\n      ) {\n        this.bar.vBar.state.opacity = 0;\n      }\n      if (\n        !this.mergedOptions.bar.hBar.keepShow &&\n        !this.vuescroll.state.isClickingBar &&\n        this.vuescroll.state.pointerLeave\n      ) {\n        this.bar.hBar.state.opacity = 0;\n      }\n    },\n    registryResize() {\n      /* istanbul ignore next */\n      if (this.destroyResize) {\n        // when toggling the mode\n        // we should clean the flag-object.\n        this.destroyResize();\n      }\n      let contentElm = null;\n      if (this.mode == 'slide' || this.mode == 'pure-native') {\n        contentElm = this.scrollPanelElm;\n      } else if (this.mode == 'native') {\n        // scrollContent maybe a component or a pure-dom\n        contentElm = this.scrollContentElm;\n      }\n      const handleWindowResize = () => /* istanbul ignore next */ {\n        this.updateBarStateAndEmitEvent();\n        if (this.mode == 'slide') {\n          this.updateScroller();\n        }\n      };\n      const handleDomResize = () => {\n        let currentSize = {};\n        if (this.mode == 'slide') {\n          this.updateScroller();\n          currentSize['width'] = this.scroller.__contentWidth;\n          currentSize['height'] = this.scroller.__contentHeight;\n        } else if (this.mode == 'native' || this.mode == 'pure-native') {\n          currentSize['width'] = this.scrollPanelElm.scrollWidth;\n          currentSize['height'] = this.scrollPanelElm.scrollHeight;\n        }\n        this.updateBarStateAndEmitEvent('handle-resize', currentSize);\n      };\n      window.addEventListener('resize', handleWindowResize, false);\n      const destroyDomResize = listenResize(contentElm, handleDomResize);\n      const destroyWindowResize = () => {\n        window.removeEventListener('resize', handleWindowResize, false);\n      };\n\n      this.destroyResize = () => {\n        destroyWindowResize();\n        destroyDomResize();\n      };\n    },\n    registryParentResize() {\n      this.destroyParentDomResize = listenResize(\n        this.$el.parentNode,\n        this.useNumbericSize\n      );\n    },\n    useNumbericSize() {\n      const parentElm = this.$el.parentNode;\n      const { position } = parentElm.style;\n      if (!position || position == 'static') {\n        this.$el.parentNode.style.position = 'relative';\n      }\n      this.vuescroll.state.height = parentElm.offsetHeight + 'px';\n      this.vuescroll.state.width = parentElm.offsetWidth + 'px';\n    },\n    usePercentSize() {\n      this.vuescroll.state.height = '100%';\n      this.vuescroll.state.width = '100%';\n    },\n    // set its size to be equal to its parentNode\n    setVsSize() {\n      if (this.mergedOptions.vuescroll.sizeStrategy == 'number') {\n        this.useNumbericSize();\n        this.registryParentResize();\n      } else if (this.mergedOptions.vuescroll.sizeStrategy == 'percent') {\n        if (this.destroyParentDomResize) {\n          this.destroyParentDomResize();\n          this.destroyParentDomResize = null;\n        }\n        this.usePercentSize();\n      }\n    },\n    recordCurrentPos() {\n      let mode = this.mode;\n      if (this.mode !== this.lastMode) {\n        mode = this.lastMode;\n        this.lastMode = this.mode;\n      }\n      const state = this.vuescroll.state;\n      let axis = findValuesByMode(mode, this);\n      const oldX = state.internalScrollLeft;\n      const oldY = state.internalScrollTop;\n      state.posX =\n        oldX - axis.x > 0 ? 'right' : oldX - axis.x < 0 ? 'left' : null;\n      state.posY = oldY - axis.y > 0 ? 'up' : oldY - axis.y < 0 ? 'down' : null;\n      state.internalScrollLeft = axis.x;\n      state.internalScrollTop = axis.y;\n    },\n    refreshInternalStatus() {\n      // 1.set vuescroll height or width according to\n      // sizeStrategy\n      this.setVsSize();\n      // 2. registry resize event\n      this.registryResize();\n      // 3. registry scroller if mode is 'slide'\n      // or remove 'transform origin' is the mode is not `slide`\n      this.updateMode();\n      // 4. update scrollbar's height/width\n      this.updateBarStateAndEmitEvent();\n    },\n    initWatchOpsChange() {\n      const watchOpts = {\n        deep: true,\n        sync: true\n      };\n      this.$watch(\n        'mergedOptions',\n        () => {\n          // record current position\n          this.recordCurrentPos();\n          setTimeout(() => {\n            if (this.isSmallChangeThisTick == true) {\n              this.isSmallChangeThisTick = false;\n              this.updateBarStateAndEmitEvent();\n              return;\n            }\n            this.refreshInternalStatus();\n          }, 0);\n        },\n        watchOpts\n      );\n\n      smallChangeArray.forEach(opts => {\n        this.$watch(\n          opts,\n          () => {\n            // when small changes changed,\n            // we need not to updateMode or registryResize\n            this.isSmallChangeThisTick = true;\n          },\n          watchOpts\n        );\n      });\n    },\n    // scrollTo hash-anchor while mounted\n    scrollToAnchor() /* istanbul ignore next */ {\n      const validateHashSelector = function(hash) {\n        return /^#[a-zA-Z_]\\d*$/.test(hash);\n      };\n      let hash = window.location.hash;\n      if (\n        !hash ||\n        ((hash = hash.slice(hash.lastIndexOf('#'))) &&\n          !validateHashSelector(hash))\n      ) {\n        return;\n      }\n      const elm = document.querySelector(hash);\n      if (\n        !isChildInParent(elm, this.$el) ||\n        this.mergedOptions.scrollPanel.initialScrollY ||\n        this.mergedOptions.scrollPanel.initialScrollX\n      ) {\n        return;\n      }\n      this.scrollIntoView(elm);\n    },\n    initVariables() {\n      this.lastMode = this.mode;\n      this.$el._isVuescroll = true;\n    }\n  }\n};\n\nexport default vueScrollCore;\n","import {getPrefix} from '../../util';\n\n/* DOM-based rendering (Uses 3D when available, falls back on margin when transform not available) */\nexport function render(content, global, suffix, value) {\n  var x = null;\n  var y = null;\n\n  if (typeof content == 'string') {\n    y = content == 'vertical' ? (x = 0) || value : (x = value) && 0;\n  }\n\n  var vendorPrefix = getPrefix(global);\n\n  var helperElem = document.createElement('div');\n  var undef;\n\n  var perspectiveProperty = vendorPrefix + 'Perspective';\n  var transformProperty = 'transform'; //vendorPrefix + 'Transform';\n\n  if (helperElem.style[perspectiveProperty] !== undef) {\n    if (typeof content == 'string') {\n      return {\n        [transformProperty]:\n          'translate3d(' + x + suffix + ',' + y + suffix + ',0)'\n      };\n    }\n    return function(left, top, zoom) {\n      content.style[transformProperty] =\n        'translate3d(' +\n        -left +\n        suffix +\n        ',' +\n        -top +\n        suffix +\n        ',0) scale(' +\n        zoom +\n        ')';\n    };\n  } else if (helperElem.style[transformProperty] !== undef) {\n    if (typeof content == 'string') {\n      return {\n        [transformProperty]: 'translate(' + x + suffix + ',' + y + suffix + ')'\n      };\n    }\n    return function(left, top, zoom) {\n      content.style[transformProperty] =\n        'translate(' +\n        -left +\n        suffix +\n        ',' +\n        -top +\n        suffix +\n        ') scale(' +\n        zoom +\n        ')';\n    };\n  }\n}\n","export function listenContainer(\n  container,\n  scroller,\n  eventCallback,\n  zooming,\n  preventDefault\n) {\n  let destroy = null;\n  // for touch\n  function touchstart(e) {\n    // Don't react if initial down happens on a form element\n    if (\n      e.touches[0] &&\n      e.touches[0].target &&\n      e.touches[0].target.tagName.match(/input|textarea|select/i)\n    ) {\n      return;\n    }\n    eventCallback('mousedown');\n    scroller.doTouchStart(e.touches, e.timeStamp);\n    if (preventDefault) {\n      e.preventDefault();\n    }\n    // here , we want to manully prevent default, so we\n    // set passive to false\n    // see https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener\n    document.addEventListener('touchmove', touchmove, { passive: false });\n  }\n  function touchmove(e) {\n    eventCallback('mousemove');\n    scroller.doTouchMove(e.touches, e.timeStamp, e.scale);\n    e.preventDefault();\n  }\n  function touchend(e) {\n    eventCallback('mouseup');\n    scroller.doTouchEnd(e.timeStamp);\n    document.removeEventListener('touchmove', touchmove);\n  }\n  function touchcancel(e) {\n    scroller.doTouchEnd(e.timeStamp);\n  }\n\n  // for mouse\n  function mousedownEvent(e) {\n    if (e.target.tagName.match(/input|textarea|select/i)) {\n      return;\n    }\n    eventCallback('mousedown');\n    scroller.doTouchStart(\n      [\n        {\n          pageX: e.pageX,\n          pageY: e.pageY\n        }\n      ],\n      e.timeStamp\n    );\n\n    if (preventDefault) {\n      e.preventDefault();\n    }\n\n    mousedown = true;\n  }\n  function mousemove(e) {\n    if (!mousedown) {\n      return;\n    }\n    eventCallback('mousemove');\n    scroller.doTouchMove(\n      [\n        {\n          pageX: e.pageX,\n          pageY: e.pageY\n        }\n      ],\n      e.timeStamp\n    );\n\n    mousedown = true;\n  }\n  function mouseup(e) {\n    if (!mousedown) {\n      return;\n    }\n    eventCallback('mouseup');\n    scroller.doTouchEnd(e.timeStamp);\n\n    mousedown = false;\n  }\n  function zoomHandle(e) {\n    scroller.doMouseZoom(\n      e.detail ? e.detail * -120 : e.wheelDelta,\n      e.timeStamp,\n      e.pageX,\n      e.pageY\n    );\n  }\n  if ('ontouchstart' in window) {\n    container.addEventListener('touchstart', touchstart, false);\n\n    document.addEventListener('touchend', touchend, false);\n\n    document.addEventListener('touchcancel', touchcancel, false);\n\n    destroy = function() {\n      container.removeEventListener('touchstart', touchstart, false);\n\n      document.removeEventListener('touchend', touchend, false);\n\n      document.removeEventListener('touchcancel', touchcancel, false);\n    };\n  } else {\n    var mousedown = false;\n\n    container.addEventListener('mousedown', mousedownEvent, false);\n\n    document.addEventListener('mousemove', mousemove, false);\n\n    document.addEventListener('mouseup', mouseup, false);\n    if (zooming) {\n      container.addEventListener(\n        navigator.userAgent.indexOf('Firefox') > -1\n          ? 'DOMMouseScroll'\n          : 'mousewheel',\n        zoomHandle,\n        false\n      );\n    }\n    // container.addEventListener(navigator.userAgent.indexOf(\"Firefox\") > -1 ? \"DOMMouseScroll\" :  \"mousewheel\", function(e) {\n    //     scroller.doMouseZoom(e.detail ? (e.detail * -120) : e.wheelDelta, e.timeStamp, e.pageX, e.pageY);\n    // }, false);\n    destroy = function() {\n      container.removeEventListener('mousedown', mousedownEvent, false);\n      document.removeEventListener('mousemove', mousemove, false);\n      document.removeEventListener('mouseup', mouseup, false);\n      container.removeEventListener(\n        navigator.userAgent.indexOf('Firefox') > -1\n          ? 'DOMMouseScroll'\n          : 'mousewheel',\n        zoomHandle,\n        false\n      );\n    };\n  }\n  // handle __publish event\n  scroller.onScroll = () => {\n    eventCallback('onscroll');\n  };\n  return destroy;\n}\n","import Vue from 'vue';\nimport vuescroll from './components/vuescroll';\nimport GCF from './shared/global-config';\nimport { deepMerge } from './util';\nimport { refreshAll } from './mixins/api';\n\nimport './style/vuescroll.scss';\n\nconst Vuescroll = {\n  install(Vue) {\n    // registry vuescroll\n    Vue.component(vuescroll.name, vuescroll);\n    Vue.prototype.$vuescrollConfig = deepMerge(GCF, {});\n  },\n  version: '__version__',\n  refreshAll\n};\n\n/* istanbul ignore if */\nif (typeof window !== 'undefined' && window.Vue) {\n  Vue.use(Vuescroll);\n}\n\nexport default Vuescroll;\n"],"names":["deepCopy","source","target","key","_typeof","deepMerge","from","to","defineReactive","souceKey","getter","defineProperty","scrollBarWidth","eventCenter","dom","eventName","hander","capture","addEventListener","removeEventListener","error","msg","warn","isChildInParent","child","parent","flag","parentNode","nodeType","_isVuescroll","pxValueReg","extractNumberFromPx","value","_return","exec","isSupportTouch","window","getPrefix","global","engine","docStyle","document","documentElement","style","opera","Object","prototype","toString","call","navigator","cpuClass","isSupportGivenStyle","property","compatibleValue","testElm","createElement","isIE","agent","userAgent","toLowerCase","indexOf","insertChildrenIntoSlot","h","parentVnode","childVNode","data","tag","componentOptions","_data","nativeOn","on","props","propsData","getRealParent","ctx","$parent","_isVuescrollRoot","listenResize","element","callback","hasResized","OBJECT_STYLE","objWrap","cssText","object","type","tabIndex","onload","contentDocument","defaultView","isResizeElm","appendChild","removeChild","injectObject","modes","NOOP","smallChangeArray","undefined","vm","this","$options","name","_gfc","$vuescrollConfig","ops","GCF","keys","forEach","mergedOptions","scrollContent","rail","vRail","pos","width","renderError","shouldStopRender","vuescroll","scrollPanel","mode","paging","snapping","enable","pullRefresh","pushLoad","initialScrollY","initialScrollX","String","match","validateOptions","createEasingFunction","easing","easingPattern","time","pattern","Date","now","running","counter","core","effect","Animate","requestFrame","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","isNative","test","root","requests","rafHandle","intervalHandle","lastActive","callbackHandle","setInterval","currentRequests","hasOwnProperty","id","cleared","stepCallback","verifyCallback","completedCallback","duration","easingMethod","start","lastFrame","percent","dropCounter","body","newRunning","usedId","step","virtual","render","droppedFrames","Math","round","j","min","vsInstances","getNumericValue","distance","size","number","_uid","x","y","animate","force","state","internalScrollLeft","scrollPanelElm","scrollWidth","internalScrollTop","scrollHeight","internalScrollTo","dx","dy","factor","originLeft","originTop","scroller","zoomBy","level","zoomTo","getCurrentPage","dest","goToPage","isRefresh","isLoad","triggerRefreshOrLoad","left","top","height","parentLeft","parentTop","parentHeight","parentWidth","children","scrollContentElm","domFragment","i","length","item","getBoundingClientRect","_this","$el","push","destX","destY","elm","deltaX","deltaY","speed","scrollingComplete","startLocationY","startLocationX","positionX","positionY","percentage","floor","abs","$refs","scrollLeft","scrollTop","updateBarStateAndEmitEvent","scrollTo","parentElm","querySelector","diffX","diffY","scrollBy","refreshInternalStatus","isPercent","sizeStrategy","clientWidth","clientHeight","heightPercentage","widthPercentage","bar","vBar","posValue","hBar","animatingMethod","noAnimatingMethod","Scroller","options","__callback","animatingEasing","noAnimatingEasing","members","contentWidth","contentHeight","trye","self","__clientWidth","__clientHeight","__contentWidth","__contentHeight","__computeScrollMax","__scrollLeft","__scrollTop","__clientLeft","__clientTop","__snapWidth","__snapHeight","activateCallback","deactivateCallback","startCallback","beforeDeactivateCallback","__refreshHeight","__refreshActivate","__refreshBeforeDeactivate","__refreshDeactivate","__refreshStart","__loadHeight","__loadActivate","__loadBeforeDeactivate","__loadDeactivate","__loadStart","wasDecelerating","__isDecelerating","stop","__publish","__zoomLevel","__refreshActive","__maxScrollTop","__loadActive","__maxScrollLeft","zooming","Error","__zoomComplete","oldLevel","max","maxZoom","minZoom","zoom","scrollingX","scrollingY","__isTracking","startLeft","__isAnimating","__scheduledLeft","startTop","__scheduledTop","__computePage","__currentPageX","__currentPageY","isNaN","wheelDelta","timeStamp","pageX","pageY","change","touches","valueOf","currentTouchLeft","currentTouchTop","__interruptedAnimation","isSingleTouch","__initialTouchLeft","__initialTouchTop","__zoomLevelStart","__lastTouchLeft","__lastTouchTop","__lastTouchMove","__lastScale","__enableScrollX","__enableScrollY","__didDecelerationComplete","__isDragging","__isSingleTouch","__positions","scale","positions","moveX","moveY","currentTouchLeftRel","currentTouchTopRel","speedMultiplier","maxScrollLeft","bouncing","maxScrollTop","splice","minimumTrackingForScroll","locking","distanceX","distanceY","animating","endPos","startPos","timeOffset","movedLeft","movedTop","__decelerationVelocityX","__decelerationVelocityY","minVelocityToStartDeceleration","__startDeceleration","__scrollComplete","__disable","wasAnimating","__scheduledZoom","oldLeft","oldTop","oldZoom","diffLeft","diffTop","diffZoom","onScroll","renderedFramesPerSecond","animationId","wasFinished","animationDuration","zoomLevel","__totalXPage","ceil","__totalYPage","__minDecelerationScrollLeft","__minDecelerationScrollTop","__maxDecelerationScrollLeft","__maxDecelerationScrollTop","minVelocityToKeepDecelerating","__stepThroughDeceleration","shouldContinue","scrollLeftFixed","scrollTopFixed","scrollOutsideX","scrollOutsideY","penetrationDeceleration","penetrationAcceleration","colorCache","rgbReg","extractRgbColor","createBar","axis","barType","charAt","railType","refreshLoad","setBarClick","createPanel","scrollPanelData","handleScroll","gutter","Vue","$isServer","outer","visibility","position","widthNoScroll","offsetWidth","overflow","inner","widthWithScroll","getGutter","marginRight","class","transformOrigin","transform","$slots","default","renderChildren","refreshDom","createTipDom","unshift","ref","pullRefreshTip","loadDom","pushLoadTip","createPanelChildren","stage","d","vueScrollCore","scrollMap","railBackgroundColor","color","opacity","div","background","computedColor","getComputedStyle","backgroundColor","getRgbAColor","hover","touchmove","e","axisStartPos","client","posName","offset","scrollSize","touchend","$emit","onselectstart","hideBar","stopImmediatePropagation","preventDefault","createTouchEvent","mousemove","mouseup","createMouseEvent","opsSize","barOffset","currentTarget","slots","boxSizing","padding","paddPos","paddValue","customContent","required","_isDestroyed","updateInitialScroll","customPanel","hackLifecycle","api","nativeMode","refreshHeight","offsetHeight","marginTop","setDimensions","content","suffix","vendorPrefix","helperElem","perspectiveProperty","transformProperty","undef","setSnapSize","rect","setPosition","clientLeft","clientTop","cb","container","eventCallback","destroy","touchstart","tagName","doTouchStart","passive","doTouchMove","doTouchEnd","touchcancel","mousedownEvent","mousedown","zoomHandle","doMouseZoom","detail","listenContainer","eventType","isDragging","registryEvent","updateScroller","outerLeft","outerTop","stageName","tipDom","listeners","domName","activateFunc","activatePullToRefresh","activatePushToLoad","cbs","$listeners","finishRefreshOrLoad","done","bind","initVariables","initWatchOpsChange","$nextTick","scrollToAnchor","destroyParentDomResize","destroyResize","vuescrollData","pointerLeave","customContainer","ch","_isVue","tips","refreshStage","loadStage","nativeEvent","updateNativeModeBarState","updateSlideModeBarState","emitEvent","showAndDefferedHideBar","destroyScroller","registryScroller","recordCurrentPos","val","isClickingBar","showBar","timeoutId","setTimeout","showDelay","vertical","horizontal","posY","posX","keepShow","contentElm","handleWindowResize","_this3","destroyDomResize","currentSize","useNumbericSize","registryParentResize","usePercentSize","lastMode","findValuesByMode","oldX","oldY","setVsSize","registryResize","updateMode","watchOpts","$watch","_this4","isSmallChangeThisTick","opts","hash","location","slice","lastIndexOf","scrollIntoView","Vuescroll","component","vs","refresh","use"],"mappings":"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"}