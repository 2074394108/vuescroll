{"version":3,"file":"vuescroll.min.js","sources":["../src/util/index.js","../src/mixins/mode/native-mode.js","../src/third-party/easingPattern/index.js","../src/third-party/scroller/animate.js","../src/third-party/scroller/requestAnimationFrame.js","../src/shared/constants.js","../src/third-party/scroller/index.js","../src/mixins/mode/slide-mode.js","../src/shared/global-config.js","../src/mixins/hack-lifecycle.js","../src/mixins/api.js","../src/third-party/resize-detector/index.js","../src/shared/scroll-map.js","../src/components/child-components/vuescroll-bar.js","../src/components/child-components/vuescroll-panel.js","../src/components/child-components/vuescroll-content.js","../src/components/vuescroll.js","../src/third-party/scroller/render.js","../src/third-party/scroller/listener.js","../src/mixins/computed.js","../src/mixins/event-emitter.js","../src/mixins/event-handler.js","../src/mixins/helper.js","../src/mixins/init.js","../src/mixins/refresh.js","../src/mixins/resize.js","../src/index.js"],"sourcesContent":["import Vue from 'vue';\n\nexport function deepCopy(source, target) {\n  target = (typeof target === 'object' && target) || {};\n  for (var key in source) {\n    target[key] =\n      typeof source[key] === 'object'\n        ? deepCopy(source[key], (target[key] = {}))\n        : source[key];\n  }\n  return target;\n}\n\nexport function deepMerge(from, to) {\n  to = to || {};\n  for (var key in from) {\n    if (typeof from[key] === 'object') {\n      if (typeof to[key] === 'undefined') {\n        to[key] = {};\n        deepCopy(from[key], to[key]);\n      } else {\n        deepMerge(from[key], to[key]);\n      }\n    } else {\n      if (typeof to[key] === 'undefined') to[key] = from[key];\n    }\n  }\n  return to;\n}\n\nexport function defineReactive(target, key, source, souceKey) {\n  let getter = null;\n  /* istanbul ignore if */\n  if (!source[key] && typeof source !== 'function') {\n    return;\n  }\n  souceKey = souceKey || key;\n  if (typeof source === 'function') {\n    getter = source;\n  }\n  Object.defineProperty(target, key, {\n    get:\n      getter ||\n      function() {\n        return source[souceKey];\n      },\n    configurable: true\n  });\n}\n\nlet scrollBarWidth;\n\nexport function getGutter() {\n  /* istanbul ignore next */\n  if (Vue.prototype.$isServer) return 0;\n  if (scrollBarWidth !== undefined) return scrollBarWidth;\n  const outer = document.createElement('div');\n  outer.style.visibility = 'hidden';\n  outer.style.width = '100px';\n  outer.style.position = 'absolute';\n  outer.style.top = '-9999px';\n  document.body.appendChild(outer);\n\n  const widthNoScroll = outer.offsetWidth;\n  outer.style.overflow = 'scroll';\n  const inner = document.createElement('div');\n  inner.style.width = '100%';\n  outer.appendChild(inner);\n\n  const widthWithScroll = inner.offsetWidth;\n  outer.parentNode.removeChild(outer);\n  scrollBarWidth = widthNoScroll - widthWithScroll;\n  return scrollBarWidth;\n}\n\nexport function eventCenter(\n  dom,\n  eventName,\n  hander,\n  capture = false,\n  type = 'on'\n) {\n  type == 'on'\n    ? dom.addEventListener(eventName, hander, capture)\n    : dom.removeEventListener(eventName, hander, capture);\n}\n\nexport const error = msg => {\n  console.error(`[vuescroll] ${msg}`);\n};\nexport const warn = msg => {\n  console.warn(`[vuescroll] ${msg}`);\n};\n\nexport function isChildInParent(child, parent) {\n  let flag = false;\n  if (!child || !parent) {\n    return flag;\n  }\n  while (\n    child.parentNode !== parent &&\n    child.parentNode.nodeType !== 9 &&\n    !child.parentNode._isVuescroll\n  ) {\n    child = child.parentNode;\n  }\n  if (child.parentNode == parent) {\n    flag = true;\n  }\n  return flag;\n}\n\nconst pxValueReg = /(.*?)px/;\nexport function extractNumberFromPx(value) {\n  const _return = pxValueReg.exec(value);\n  return _return && _return[1];\n}\n\nexport function isSupportTouch() {\n  return 'ontouchstart' in window;\n}\n\nexport function getPrefix(global) {\n  var docStyle = document.documentElement.style;\n  var engine;\n  /* istanbul ignore if */\n  if (\n    global.opera &&\n    Object.prototype.toString.call(opera) === '[object Opera]'\n  ) {\n    engine = 'presto';\n  } /* istanbul ignore next */ else if ('MozAppearance' in docStyle) {\n    engine = 'gecko';\n  } else if ('WebkitAppearance' in docStyle) {\n    engine = 'webkit';\n  } /* istanbul ignore next */ else if (\n    typeof navigator.cpuClass === 'string'\n  ) {\n    engine = 'trident';\n  }\n  var vendorPrefix = {\n    trident: 'ms',\n    gecko: 'moz',\n    webkit: 'webkit',\n    presto: 'O'\n  }[engine];\n  return vendorPrefix;\n}\n\nexport function isSupportGivenStyle(property, value) {\n  const compatibleValue = `-${getPrefix(window)}-${value}`;\n  const testElm = document.createElement('div');\n  testElm.style[property] = compatibleValue;\n  if (testElm.style[property] == compatibleValue) {\n    return compatibleValue;\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nexport function isIE() /* istanbul ignore next */ {\n  var agent = navigator.userAgent.toLowerCase();\n  return (\n    agent.indexOf('msie') !== -1 ||\n    agent.indexOf('trident') !== -1 ||\n    agent.indexOf(' edge/') !== -1\n  );\n}\n\nexport function insertChildrenIntoSlot(h, parentVnode, childVNode, data) {\n  parentVnode = parentVnode[0] ? parentVnode[0] : parentVnode;\n\n  const isComponent = !!parentVnode.componentOptions;\n\n  const tag = isComponent ? parentVnode.componentOptions.tag : parentVnode.tag;\n\n  const _data = parentVnode.componentOptions || parentVnode.data || {};\n\n  if (isComponent) {\n    data.nativeOn = data.on;\n    _data.props = _data.propsData;\n\n    delete data.on;\n    delete data.propsData;\n  }\n\n  return h(\n    tag,\n    {\n      ...data,\n      ..._data\n    },\n    childVNode\n  );\n}\n\nexport function getRealParent(ctx) {\n  let parent = ctx.$parent;\n\n  if (!parent._isVuescrollRoot && parent) {\n    parent = parent.$parent;\n  }\n\n  return parent;\n}\n","import { extractNumberFromPx } from '../../util';\nexport default {\n  methods: {\n    updateNativeModeBarState() {\n      const scrollPanel = this.scrollPanelElm;\n      const vuescroll = this.$el;\n      const isPercent = this.mergedOptions.vuescroll.sizeStrategy == 'percent';\n      const clientWidth = isPercent\n        ? vuescroll.clientWidth\n        : extractNumberFromPx(this.vuescroll.state.width);\n      const clientHeight = isPercent\n        ? vuescroll.clientHeight\n        : extractNumberFromPx(this.vuescroll.state.height);\n      let heightPercentage = (clientHeight * 100) / scrollPanel.scrollHeight;\n      let widthPercentage = (clientWidth * 100) / scrollPanel.scrollWidth;\n      this.bar.vBar.state.posValue =\n        (scrollPanel.scrollTop * 100) / clientHeight;\n      this.bar.hBar.state.posValue =\n        (scrollPanel.scrollLeft * 100) / clientWidth;\n      this.bar.vBar.state.size =\n        heightPercentage < 100 ? heightPercentage + '%' : 0;\n      this.bar.hBar.state.size =\n        widthPercentage < 100 ? widthPercentage + '%' : 0;\n    }\n  }\n};\n","/**\n *  Compatible to scroller's animation function\n */\nexport function createEasingFunction(easing, easingPattern) {\n  return function(time) {\n    return easingPattern(easing, time);\n  };\n}\n\n/**\n * Calculate the easing pattern\n * @link https://github.com/cferdinandi/smooth-scroll/blob/master/src/js/smooth-scroll.js\n * modified by wangyi7099\n * @param {String} type Easing pattern\n * @param {Number} time Time animation should take to complete\n * @returns {Number}\n */\nexport function easingPattern(easing, time) {\n  let pattern = null;\n  /* istanbul ignore next */\n  {\n    // Default Easing Patterns\n    if (easing === 'easeInQuad') pattern = time * time; // accelerating from zero velocity\n    if (easing === 'easeOutQuad') pattern = time * (2 - time); // decelerating to zero velocity\n    if (easing === 'easeInOutQuad')\n      pattern = time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time; // acceleration until halfway, then deceleration\n    if (easing === 'easeInCubic') pattern = time * time * time; // accelerating from zero velocity\n    if (easing === 'easeOutCubic') pattern = --time * time * time + 1; // decelerating to zero velocity\n    if (easing === 'easeInOutCubic')\n      pattern =\n        time < 0.5\n          ? 4 * time * time * time\n          : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1; // acceleration until halfway, then deceleration\n    if (easing === 'easeInQuart') pattern = time * time * time * time; // accelerating from zero velocity\n    if (easing === 'easeOutQuart') pattern = 1 - --time * time * time * time; // decelerating to zero velocity\n    if (easing === 'easeInOutQuart')\n      pattern =\n        time < 0.5\n          ? 8 * time * time * time * time\n          : 1 - 8 * --time * time * time * time; // acceleration until halfway, then deceleration\n    if (easing === 'easeInQuint') pattern = time * time * time * time * time; // accelerating from zero velocity\n    if (easing === 'easeOutQuint')\n      pattern = 1 + --time * time * time * time * time; // decelerating to zero velocity\n    if (easing === 'easeInOutQuint')\n      pattern =\n        time < 0.5\n          ? 16 * time * time * time * time * time\n          : 1 + 16 * --time * time * time * time * time; // acceleration until halfway, then deceleration\n  }\n  return pattern || time; // no easing, no acceleration\n}\n","/*\n * Scroller\n * http://github.com/zynga/scroller\n *\n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n *\n * Based on the work of: Unify Project (unify-project.org)\n * http://unify-project.org\n * Copyright 2011, Deutsche Telekom AG\n * License: MIT + Apache (V2)\n */\n\n/**\n * Generic animation class with support for dropped frames both optional easing and duration.\n *\n * Optional duration is useful when the lifetime is defined by another condition than time\n * e.g. speed of an animating object, etc.\n *\n * Dropped frame logic allows to keep using the same updater logic independent from the actual\n * rendering. This eases a lot of cases where it might be pretty complex to break down a state\n * based on the pure time difference.\n */\nimport { requestAnimationFrame } from './requestAnimationFrame';\n\nvar time =\n  Date.now ||\n  function() {\n    return +new Date();\n  };\nvar desiredFrames = 60;\nvar millisecondsPerSecond = 1000;\nvar running = {};\nvar counter = 1;\n\nconst core = { effect: {} };\nlet global = null;\n\nif (typeof window !== 'undefined') {\n  global = window;\n} else {\n  global = {};\n}\n\ncore.effect.Animate = {\n  /**\n   * A requestAnimationFrame wrapper / polyfill.\n   *\n   * @param callback {Function} The callback to be invoked before the next repaint.\n   * @param root {HTMLElement} The root element for the repaint\n   */\n  requestAnimationFrame: requestAnimationFrame(global),\n  /**\n   * Stops the given animation.\n   *\n   * @param id {Integer} Unique animation ID\n   * @return {Boolean} Whether the animation was stopped (aka, was running before)\n   */\n  stop: function(id) {\n    var cleared = running[id] != null;\n    if (cleared) {\n      running[id] = null;\n    }\n\n    return cleared;\n  },\n\n  /**\n   * Whether the given animation is still running.\n   *\n   * @param id {Integer} Unique animation ID\n   * @return {Boolean} Whether the animation is still running\n   */\n  isRunning: function(id) {\n    return running[id] != null;\n  },\n\n  /**\n   * Start the animation.\n   *\n   * @param stepCallback {Function} Pointer to function which is executed on every step.\n   *   Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`\n   * @param verifyCallback {Function} Executed before every animation step.\n   *   Signature of the method should be `function() { return continueWithAnimation; }`\n   * @param completedCallback {Function}\n   *   Signature of the method should be `function(droppedFrames, finishedAnimation) {}`\n   * @param duration {Integer} Milliseconds to run the animation\n   * @param easingMethod {Function} Pointer to easing function\n   *   Signature of the method should be `function(percent) { return modifiedValue; }`\n   * @param root {Element ? document.body} Render root, when available. Used for internal\n   *   usage of requestAnimationFrame.\n   * @return {Integer} Identifier of animation. Can be used to stop it any time.\n   */\n  start: function(\n    stepCallback,\n    verifyCallback,\n    completedCallback,\n    duration,\n    easingMethod,\n    root\n  ) {\n    var start = time();\n    var lastFrame = start;\n    var percent = 0;\n    var dropCounter = 0;\n    var id = counter++;\n\n    if (!root) {\n      root = document.body;\n    }\n\n    // Compacting running db automatically every few new animations\n    if (id % 20 === 0) {\n      var newRunning = {};\n      for (var usedId in running) {\n        newRunning[usedId] = true;\n      }\n      running = newRunning;\n    }\n\n    // This is the internal step method which is called every few milliseconds\n    var step = function(virtual) {\n      // Normalize virtual value\n      var render = virtual !== true;\n\n      // Get current time\n      var now = time();\n\n      // Verification is executed before next animation step\n      if (!running[id] || (verifyCallback && !verifyCallback(id))) {\n        running[id] = null;\n        completedCallback &&\n          completedCallback(\n            desiredFrames -\n              dropCounter / ((now - start) / millisecondsPerSecond),\n            id,\n            false\n          );\n        return;\n      }\n\n      // For the current rendering to apply let's update omitted steps in memory.\n      // This is important to bring internal state variables up-to-date with progress in time.\n      if (render) {\n        var droppedFrames =\n          Math.round(\n            (now - lastFrame) / (millisecondsPerSecond / desiredFrames)\n          ) - 1;\n        for (var j = 0; j < Math.min(droppedFrames, 4); j++) {\n          step(true);\n          dropCounter++;\n        }\n      }\n\n      // Compute percent value\n      if (duration) {\n        percent = (now - start) / duration;\n        if (percent > 1) {\n          percent = 1;\n        }\n      }\n\n      // Execute step callback, then...\n      var value = easingMethod ? easingMethod(percent) : percent;\n      if (\n        (stepCallback(value, now, render) === false || percent === 1) &&\n        render\n      ) {\n        running[id] = null;\n        completedCallback &&\n          completedCallback(\n            desiredFrames -\n              dropCounter / ((now - start) / millisecondsPerSecond),\n            id,\n            percent === 1 || duration == null\n          );\n      } else if (render) {\n        lastFrame = now;\n        core.effect.Animate.requestAnimationFrame(step, root);\n      }\n    };\n\n    // Mark as running\n    running[id] = true;\n\n    // Init first step\n    core.effect.Animate.requestAnimationFrame(step, root);\n\n    // Return unique animation ID\n    return id;\n  }\n};\n\nexport { core };\n","export function requestAnimationFrame(global) {\n  // Check for request animation Frame support\n  var requestFrame =\n    global.requestAnimationFrame ||\n    global.webkitRequestAnimationFrame ||\n    global.mozRequestAnimationFrame ||\n    global.oRequestAnimationFrame;\n  var isNative = !!requestFrame;\n\n  if (\n    requestFrame &&\n    !/requestAnimationFrame\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}/i.test(\n      requestFrame.toString()\n    )\n  ) {\n    isNative = false;\n  }\n\n  if (isNative) {\n    return function(callback, root) {\n      requestFrame(callback, root);\n    };\n  }\n\n  var TARGET_FPS = 60;\n  var requests = {};\n  var rafHandle = 1;\n  var intervalHandle = null;\n  var lastActive = +new Date();\n\n  return function(callback) {\n    var callbackHandle = rafHandle++;\n\n    // Store callback\n    requests[callbackHandle] = callback;\n    requestCount++;\n\n    // Create timeout at first request\n    if (intervalHandle === null) {\n      intervalHandle = setInterval(function() {\n        var time = +new Date();\n        var currentRequests = requests;\n\n        // Reset data structure before executing callbacks\n        requests = {};\n        requestCount = 0;\n\n        for (var key in currentRequests) {\n          if (currentRequests.hasOwnProperty(key)) {\n            currentRequests[key](time);\n            lastActive = time;\n          }\n        }\n\n        // Disable the timeout when nothing happens for a certain\n        // period of time\n        if (time - lastActive > 2500) {\n          clearInterval(intervalHandle);\n          intervalHandle = null;\n        }\n      }, 1000 / TARGET_FPS);\n    }\n\n    return callbackHandle;\n  };\n}\n","// all modes\nexport const modes = ['slide', 'native', 'pure-native'];\n// do nothing\nexport const NOOP = () => {};\n// some small changes.\nexport const smallChangeArray = [\n  'mergedOptions.vuescroll.pullRefresh.tips',\n  'mergedOptions.vuescroll.pushLoad.tips',\n  'mergedOptions.rail',\n  'mergedOptions.bar'\n];\n","/*\n * Scroller\n * http://github.com/zynga/scroller\n *\n * modified by wangyi7099\n * \n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n *\n * Based on the work of: Unify Project (unify-project.org)\n * http://unify-project.org\n * Copyright 2011, Deutsche Telekom AG\n * License: MIT + Apache (V2)\n */\nimport { easingPattern, createEasingFunction } from '../easingPattern';\nimport { core } from './animate';\nimport { NOOP } from '../../shared/constants';\n\nvar animatingMethod = null;\n\nvar noAnimatingMethod = null;\n\nexport default function Scroller(callback, options) {\n  this.__callback = callback;\n\n  this.options = {\n    /** Enable scrolling on x-axis */\n    scrollingX: true,\n\n    /** Enable scrolling on y-axis */\n    scrollingY: true,\n\n    /** Enable animations for deceleration, snap back, zooming and scrolling */\n    animating: true,\n\n    /** duration for animations triggered by scrollTo/zoomTo */\n    animationDuration: 250,\n\n    /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\n    bouncing: true,\n\n    /** Enable locking to the main axis if user moves only slightly on one of them at start */\n    locking: true,\n\n    /** Enable pagination mode (switching between full page content panes) */\n    paging: false,\n\n    /** Enable snapping of content to a configured pixel grid */\n    snapping: false,\n\n    /** Enable zooming of content via API, fingers and mouse wheel */\n    zooming: false,\n\n    /** Minimum zoom level */\n    minZoom: 0.5,\n\n    /** Maximum zoom level */\n    maxZoom: 3,\n\n    /** Multiply or decrease scrolling speed **/\n    speedMultiplier: 1,\n\n    /** Callback that is fired on the later of touch end or deceleration end,\n\t\t\t\tprovided that another scrolling action has not begun. Used to know\n\t\t\t\twhen to fade out a scrollbar. */\n    scrollingComplete: NOOP,\n\n    animatingEasing: 'easeOutCubic',\n\n    noAnimatingEasing: 'easeInOutCubic',\n\n    /** This configures the amount of change applied to deceleration when reaching boundaries  **/\n    penetrationDeceleration: 0.03,\n\n    /** This configures the amount of change applied to acceleration when reaching boundaries  **/\n    penetrationAcceleration: 0.08\n  };\n\n  for (var key in options) {\n    this.options[key] = options[key];\n  }\n\n  animatingMethod = createEasingFunction(\n    this.options.animatingEasing,\n    easingPattern\n  );\n  noAnimatingMethod = createEasingFunction(\n    this.options.noAnimatingEasing,\n    easingPattern\n  );\n}\n\nvar members = {\n  /*\n\t---------------------------------------------------------------------------\n\t\tINTERNAL FIELDS :: STATUS\n\t---------------------------------------------------------------------------\n\t*/\n\n  /** {Boolean} Whether only a single finger is used in touch handling */\n  __isSingleTouch: false,\n\n  /** {Boolean} Whether a touch event sequence is in progress */\n  __isTracking: false,\n\n  /** {Boolean} Whether a deceleration animation went to completion. */\n  __didDecelerationComplete: false,\n\n  /**\n   * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when\n   * a gesturestart event happens. This has higher priority than dragging.\n   */\n  __isGesturing: false,\n\n  /**\n   * {Boolean} Whether the user has moved by such a distance that we have enabled\n   * dragging mode. Hint: It's only enabled after some pixels of movement to\n   * not interrupt with clicks etc.\n   */\n  __isDragging: false,\n\n  /**\n   * {Boolean} Not touching and dragging anymore, and smoothly animating the\n   * touch sequence using deceleration.\n   */\n  __isDecelerating: false,\n\n  /**\n   * {Boolean} Smoothly animating the currently configured change\n   */\n  __isAnimating: false,\n\n  /*\n\t---------------------------------------------------------------------------\n\t\tINTERNAL FIELDS :: DIMENSIONS\n\t---------------------------------------------------------------------------\n\t*/\n\n  /** {Integer} Available outer left position (from document perspective) */\n  __clientLeft: 0,\n\n  /** {Integer} Available outer top position (from document perspective) */\n  __clientTop: 0,\n\n  /** {Integer} Available outer width */\n  __clientWidth: 0,\n\n  /** {Integer} Available outer height */\n  __clientHeight: 0,\n\n  /** {Integer} Outer width of content */\n  __contentWidth: 0,\n\n  /** {Integer} Outer height of content */\n  __contentHeight: 0,\n\n  /** {Integer} Snapping width for content */\n  __snapWidth: 100,\n\n  /** {Integer} Snapping height for content */\n  __snapHeight: 100,\n\n  /** {Integer} Height to assign to refresh area */\n  __refreshHeight: null,\n  /** {Integer} Height to assign to refresh area */\n  __loadHeight: null,\n  /** {Boolean} Whether the refresh process is enabled when the event is released now */\n  __refreshActive: false,\n\n  /** {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release */\n  __refreshActivate: null,\n\n  __refreshBeforeDeactivate: null,\n\n  /** {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled */\n  __refreshDeactivate: null,\n\n  /** {Function} Callback to execute to start the actual refresh. Call {@link #refreshFinish} when done */\n  __refreshStart: null,\n\n  __loadActive: null,\n\n  __loadActivate: null,\n\n  __loadBeforeDeactivate: null,\n\n  __loadDeactivate: null,\n\n  __loadStart: null,\n  /** {Number} Zoom level */\n  __zoomLevel: 1,\n\n  /** {Number} Scroll position on x-axis */\n  __scrollLeft: 0,\n\n  /** {Number} Scroll position on y-axis */\n  __scrollTop: 0,\n\n  /** {Integer} Maximum allowed scroll position on x-axis */\n  __maxScrollLeft: 0,\n\n  /** {Integer} Maximum allowed scroll position on y-axis */\n  __maxScrollTop: 0,\n\n  /* {Number} Scheduled left position (final position when animating) */\n  __scheduledLeft: 0,\n\n  /* {Number} Scheduled top position (final position when animating) */\n  __scheduledTop: 0,\n\n  /* {Number} Scheduled zoom level (final scale when animating) */\n  __scheduledZoom: 0,\n\n  /**\n   * current page\n   */\n  __currentPageX: null,\n\n  __currentPageY: null,\n\n  /**\n   * total page\n   */\n  __totalXPage: null,\n\n  __totalYPage: null,\n  /*\n\t---------------------------------------------------------------------------\n\t\tINTERNAL FIELDS :: LAST POSITIONS\n\t---------------------------------------------------------------------------\n\t*/\n  /** whether the scroller is disabled or not */\n  __disable: false,\n  /** {Number} Left position of finger at start */\n  __lastTouchLeft: null,\n\n  /** {Number} Top position of finger at start */\n  __lastTouchTop: null,\n\n  /** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */\n  __lastTouchMove: null,\n\n  /** {Array} List of positions, uses three indexes for each state: left, top, timestamp */\n  __positions: null,\n\n  /*\n\t---------------------------------------------------------------------------\n\t\tINTERNAL FIELDS :: DECELERATION SUPPORT\n\t---------------------------------------------------------------------------\n\t*/\n\n  /** {Integer} Minimum left scroll position during deceleration */\n  __minDecelerationScrollLeft: null,\n\n  /** {Integer} Minimum top scroll position during deceleration */\n  __minDecelerationScrollTop: null,\n\n  /** {Integer} Maximum left scroll position during deceleration */\n  __maxDecelerationScrollLeft: null,\n\n  /** {Integer} Maximum top scroll position during deceleration */\n  __maxDecelerationScrollTop: null,\n\n  /** {Number} Current factor to modify horizontal scroll position with on every step */\n  __decelerationVelocityX: null,\n\n  /** {Number} Current factor to modify vertical scroll position with on every step */\n  __decelerationVelocityY: null,\n\n  /*\n\t---------------------------------------------------------------------------\n\t\tPUBLIC API\n\t---------------------------------------------------------------------------\n\t*/\n\n  /**\n   * Configures the dimensions of the client (outer) and content (inner) elements.\n   * Requires the available space for the outer element and the outer size of the inner element.\n   * All values which are falsy (null or zero etc.) are ignored and the old value is kept.\n   *\n   * @param clientWidth {Integer ? null} Inner width of outer element\n   * @param clientHeight {Integer ? null} Inner height of outer element\n   * @param contentWidth {Integer ? null} Outer width of inner element\n   * @param contentHeight {Integer ? null} Outer height of inner element\n   */\n  setDimensions: function(\n    clientWidth,\n    clientHeight,\n    contentWidth,\n    contentHeight,\n    animate,\n    noScroll = false\n  ) {\n    var self = this;\n\n    // Only update values which are defined\n    if (clientWidth === +clientWidth) {\n      self.__clientWidth = clientWidth;\n    }\n\n    if (clientHeight === +clientHeight) {\n      self.__clientHeight = clientHeight;\n    }\n\n    if (contentWidth === +contentWidth) {\n      self.__contentWidth = contentWidth;\n    }\n\n    if (contentHeight === +contentHeight) {\n      self.__contentHeight = contentHeight;\n    }\n\n    // Refresh maximums\n    self.__computeScrollMax();\n\n    if (!noScroll) {\n      // Refresh scroll position\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, animate);\n    }\n  },\n\n  /**\n   * Sets the client coordinates in relation to the document.\n   *\n   * @param left {Integer ? 0} Left position of outer element\n   * @param top {Integer ? 0} Top position of outer element\n   */\n  setPosition: function(left, top) {\n    var self = this;\n\n    self.__clientLeft = left || 0;\n    self.__clientTop = top || 0;\n  },\n\n  /**\n   * Configures the snapping (when snapping is active)\n   *\n   * @param width {Integer} Snapping width\n   * @param height {Integer} Snapping height\n   */\n  setSnapSize: function(width, height) {\n    var self = this;\n\n    self.__snapWidth = width;\n    self.__snapHeight = height;\n  },\n\n  /**\n   * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever\n   * the user event is released during visibility of this zone. This was introduced by some apps on iOS like\n   * the official Twitter client.\n   *\n   * @param height {Integer} Height of pull-to-refresh zone on top of rendered list\n   * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.\n   * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.\n   * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.\n   */\n  activatePullToRefresh: function(\n    height,\n    {\n      activateCallback,\n      deactivateCallback,\n      startCallback,\n      beforeDeactivateCallback\n    }\n  ) {\n    var self = this;\n\n    self.__refreshHeight = height;\n    self.__refreshActivate = activateCallback;\n    self.__refreshBeforeDeactivate = beforeDeactivateCallback;\n    self.__refreshDeactivate = deactivateCallback;\n    self.__refreshStart = startCallback;\n  },\n  activatePushToLoad: function(\n    height,\n    {\n      activateCallback,\n      deactivateCallback,\n      startCallback,\n      beforeDeactivateCallback\n    }\n  ) {\n    var self = this;\n\n    self.__loadHeight = height;\n    self.__loadActivate = activateCallback;\n    self.__loadBeforeDeactivate = beforeDeactivateCallback;\n    self.__loadDeactivate = deactivateCallback;\n    self.__loadStart = startCallback;\n  },\n\n  /**\n   * Starts pull-to-refresh manually.\n   */\n  triggerRefreshOrLoad: function(type = 'refresh') {\n    var wasDecelerating = this.__isDecelerating;\n    if (wasDecelerating) {\n      core.effect.Animate.stop(wasDecelerating);\n      this.__isDecelerating = false;\n    }\n    // Use publish instead of scrollTo to allow scrolling to out of boundary position\n    // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n    if (type == 'refresh') {\n      this.__publish(\n        this.__scrollLeft,\n        -this.__refreshHeight,\n        this.__zoomLevel,\n        true\n      );\n      if (this.__refreshStart) {\n        this.__refreshStart();\n        this.__refreshActive = true;\n      }\n    } else {\n      this.__publish(\n        this.__scrollLeft,\n        this.__maxScrollTop + this.__loadHeight,\n        this.__zoomLevel,\n        true\n      );\n      if (this.__loadStart) {\n        this.__loadStart();\n        this.__loadActive = true;\n      }\n    }\n  },\n\n  /**\n   * Signalizes that pull-to-refresh is finished.\n   */\n  finishRefreshOrLoad: function() {\n    var self = this;\n\n    if (self.__refreshBeforeDeactivate && self.__refreshActive) {\n      self.__refreshActive = false;\n      self.__refreshBeforeDeactivate(function() {\n        if (self.__refreshDeactivate) {\n          self.__refreshDeactivate();\n        }\n        self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n      });\n    } else if (self.__refreshDeactivate && self.__refreshActive) {\n      self.__refreshActive = false;\n      self.__refreshDeactivate();\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n    }\n\n    if (self.__loadBeforeDeactivate && self.__loadActive) {\n      self.__loadActive = false;\n      self.__loadBeforeDeactivate(function() {\n        if (self.__loadDeactivate) {\n          self.__loadDeactivate();\n        }\n        self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n      });\n    } else if (self.__loadDeactivate && self.__loadActive) {\n      self.__loadActive = false;\n      self.__loadDeactivate();\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n    }\n  },\n\n  /**\n   * Returns the scroll position and zooming values\n   *\n   * @return {Map} `left` and `top` scroll position and `zoom` level\n   */\n  getValues: function() {\n    var self = this;\n\n    return {\n      left: self.__scrollLeft,\n      top: self.__scrollTop,\n      zoom: self.__zoomLevel\n    };\n  },\n\n  /**\n   * Returns the maximum scroll values\n   *\n   * @return {Map} `left` and `top` maximum scroll values\n   */\n  getScrollMax: function() {\n    var self = this;\n\n    return {\n      left: self.__maxScrollLeft,\n      top: self.__maxScrollTop\n    };\n  },\n\n  /**\n   * Zooms to the given level. Supports optional animation. Zooms\n   * the center when no coordinates are given.\n   *\n   * @param level {Number} Level to zoom to\n   * @param animate {Boolean ? false} Whether to use animation\n   * @param originLeft {Number ? null} Zoom in at given left coordinate\n   * @param originTop {Number ? null} Zoom in at given top coordinate\n   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n   */\n  zoomTo: function(level, animate, originLeft, originTop, callback) {\n    var self = this;\n\n    if (!self.options.zooming) {\n      throw new Error('Zooming is not enabled!');\n    }\n\n    // Add callback if exists\n    if (callback) {\n      self.__zoomComplete = callback;\n    }\n\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      core.effect.Animate.stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n    }\n\n    var oldLevel = self.__zoomLevel;\n\n    // Normalize input origin to center of viewport if not defined\n    if (originLeft == null) {\n      originLeft = self.__clientWidth / 2;\n    }\n\n    if (originTop == null) {\n      originTop = self.__clientHeight / 2;\n    }\n\n    // Limit level according to configuration\n    level = Math.max(\n      Math.min(level, self.options.maxZoom),\n      self.options.minZoom\n    );\n\n    // Recompute maximum values while temporary tweaking maximum scroll ranges\n    self.__computeScrollMax(level);\n\n    // Recompute left and top coordinates based on new zoom level\n    var left =\n      ((originLeft + self.__scrollLeft) * level) / oldLevel - originLeft;\n    var top = ((originTop + self.__scrollTop) * level) / oldLevel - originTop;\n\n    // Limit x-axis\n    if (left > self.__maxScrollLeft) {\n      left = self.__maxScrollLeft;\n    } else if (left < 0) {\n      left = 0;\n    }\n\n    // Limit y-axis\n    if (top > self.__maxScrollTop) {\n      top = self.__maxScrollTop;\n    } else if (top < 0) {\n      top = 0;\n    }\n\n    // Push values out\n    self.__publish(left, top, level, animate);\n  },\n\n  /**\n   * Zooms the content by the given factor.\n   *\n   * @param factor {Number} Zoom by given factor\n   * @param animate {Boolean ? false} Whether to use animation\n   * @param originLeft {Number ? 0} Zoom in at given left coordinate\n   * @param originTop {Number ? 0} Zoom in at given top coordinate\n   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n   */\n  zoomBy: function(factor, animate, originLeft, originTop, callback) {\n    var self = this;\n\n    self.zoomTo(\n      self.__zoomLevel * factor,\n      animate,\n      originLeft,\n      originTop,\n      callback\n    );\n  },\n\n  /**\n   * Scrolls to the given position. Respect limitations and snapping automatically.\n   *\n   * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>\n   * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>\n   * @param animate {Boolean?false} Whether the scrolling should happen using an animation\n   * @param zoom {Number?null} Zoom level to go to\n   */\n  scrollTo: function(left, top, animate, zoom, force) {\n    var self = this;\n\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      core.effect.Animate.stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n    }\n\n    // Correct coordinates based on new zoom level\n    if (zoom != null && zoom !== self.__zoomLevel) {\n      if (!self.options.zooming) {\n        throw new Error('Zooming is not enabled!');\n      }\n\n      left *= zoom;\n      top *= zoom;\n\n      // Recompute maximum values while temporary tweaking maximum scroll ranges\n      self.__computeScrollMax(zoom);\n    } else {\n      // Keep zoom when not defined\n      zoom = self.__zoomLevel;\n    }\n\n    if (!self.options.scrollingX && !force) {\n      left = self.__scrollLeft;\n    } else {\n      if (self.options.paging) {\n        left = Math.round(left / self.__clientWidth) * self.__clientWidth;\n      } else if (self.options.snapping) {\n        left = Math.round(left / self.__snapWidth) * self.__snapWidth;\n      }\n    }\n\n    if (!self.options.scrollingY && !force) {\n      top = self.__scrollTop;\n    } else {\n      if (self.options.paging) {\n        top = Math.round(top / self.__clientHeight) * self.__clientHeight;\n      } else if (self.options.snapping) {\n        top = Math.round(top / self.__snapHeight) * self.__snapHeight;\n      }\n    }\n\n    // Limit for allowed ranges\n    left = Math.max(Math.min(self.__maxScrollLeft, left), 0);\n    top = Math.max(Math.min(self.__maxScrollTop, top), 0);\n    // Don't animate when no change detected, still call publish to make sure\n    // that rendered position is really in-sync with internal data\n    if (left === self.__scrollLeft && top === self.__scrollTop) {\n      animate = false;\n    }\n\n    // Publish new values\n    if (!self.__isTracking) {\n      self.__publish(left, top, zoom, animate);\n    }\n  },\n\n  /**\n   * Scroll by the given offset\n   *\n   * @param left {Number ? 0} Scroll x-axis by given offset\n   * @param top {Number ? 0} Scroll x-axis by given offset\n   * @param animate {Boolean ? false} Whether to animate the given change\n   */\n  scrollBy: function(left, top, animate) {\n    var self = this;\n\n    var startLeft = self.__isAnimating\n      ? self.__scheduledLeft\n      : self.__scrollLeft;\n    var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;\n\n    self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);\n  },\n  getCurrentPage() {\n    this.__computePage();\n    return {\n      x: this.__currentPageX,\n      y: this.__currentPageY\n    };\n  },\n\n  goToPage({ x, y }, animate) {\n    if (isNaN(x)) {\n      x = 1;\n    }\n    if (isNaN(y)) {\n      y = 1;\n    }\n    this.scrollTo(\n      (x - 1) * this.__clientWidth,\n      (y - 1) * this.__clientHeight,\n      animate\n    );\n  },\n\n  /*\n\t---------------------------------------------------------------------------\n\t\tEVENT CALLBACKS\n\t---------------------------------------------------------------------------\n\t*/\n\n  /**\n   * Mouse wheel handler for zooming support\n   */\n  doMouseZoom: function(wheelDelta, timeStamp, pageX, pageY) {\n    var self = this;\n    var change = wheelDelta > 0 ? 0.97 : 1.03;\n\n    return self.zoomTo(\n      self.__zoomLevel * change,\n      false,\n      pageX - self.__clientLeft,\n      pageY - self.__clientTop\n    );\n  },\n\n  /**\n   * Touch start handler for scrolling support\n   */\n  doTouchStart: function(touches, timeStamp) {\n    // Array-like check is enough here\n    if (touches.length == null) {\n      throw new Error('Invalid touch list: ' + touches);\n    }\n\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== 'number') {\n      throw new Error('Invalid timestamp value: ' + timeStamp);\n    }\n\n    var self = this;\n\n    // Reset interruptedAnimation flag\n    self.__interruptedAnimation = true;\n\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      core.effect.Animate.stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n      self.__interruptedAnimation = true;\n    }\n\n    // Stop animation\n    if (self.__isAnimating) {\n      core.effect.Animate.stop(self.__isAnimating);\n      self.__isAnimating = false;\n      self.__interruptedAnimation = true;\n    }\n\n    // Use center point when dealing with two fingers\n    var currentTouchLeft, currentTouchTop;\n    var isSingleTouch = touches.length === 1;\n    if (isSingleTouch) {\n      currentTouchLeft = touches[0].pageX;\n      currentTouchTop = touches[0].pageY;\n    } else {\n      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n    }\n\n    // Store initial positions\n    self.__initialTouchLeft = currentTouchLeft;\n    self.__initialTouchTop = currentTouchTop;\n\n    // Store current zoom level\n    self.__zoomLevelStart = self.__zoomLevel;\n\n    // Store initial touch positions\n    self.__lastTouchLeft = currentTouchLeft;\n    self.__lastTouchTop = currentTouchTop;\n\n    // Store initial move time stamp\n    self.__lastTouchMove = timeStamp;\n\n    // Reset initial scale\n    self.__lastScale = 1;\n\n    // Reset locking flags\n    self.__enableScrollX = !isSingleTouch && self.options.scrollingX;\n    self.__enableScrollY = !isSingleTouch && self.options.scrollingY;\n\n    // Reset tracking flag\n    self.__isTracking = true;\n\n    // Reset deceleration complete flag\n    self.__didDecelerationComplete = false;\n\n    // Dragging starts directly with two fingers, otherwise lazy with an offset\n    self.__isDragging = !isSingleTouch;\n\n    // Some features are  in multi touch scenarios\n    self.__isSingleTouch = isSingleTouch;\n\n    // Clearing data structure\n    self.__positions = [];\n  },\n\n  /**\n   * Touch move handler for scrolling support\n   */\n  doTouchMove: function(touches, timeStamp, scale) {\n    // Array-like check is enough here\n    if (touches.length == null) {\n      throw new Error('Invalid touch list: ' + touches);\n    }\n\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== 'number') {\n      throw new Error('Invalid timestamp value: ' + timeStamp);\n    }\n\n    var self = this;\n\n    // Ignore event when tracking is not enabled (event might be outside of element)\n    if (!self.__isTracking) {\n      return;\n    }\n\n    var currentTouchLeft, currentTouchTop;\n\n    // Compute move based around of center of fingers\n    if (touches.length === 2) {\n      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n    } else {\n      currentTouchLeft = touches[0].pageX;\n      currentTouchTop = touches[0].pageY;\n    }\n\n    var positions = self.__positions;\n\n    // Are we already is dragging mode?\n    if (self.__isDragging) {\n      // Compute move distance\n      var moveX = currentTouchLeft - self.__lastTouchLeft;\n      var moveY = currentTouchTop - self.__lastTouchTop;\n\n      // Read previous scroll position and zooming\n      var scrollLeft = self.__scrollLeft;\n      var scrollTop = self.__scrollTop;\n      var level = self.__zoomLevel;\n\n      // Work with scaling\n      if (scale != null && self.options.zooming) {\n        var oldLevel = level;\n\n        // Recompute level based on previous scale and new scale\n        level = (level / self.__lastScale) * scale;\n\n        // Limit level according to configuration\n        level = Math.max(\n          Math.min(level, self.options.maxZoom),\n          self.options.minZoom\n        );\n\n        // Only do further compution when change happened\n        if (oldLevel !== level) {\n          // Compute relative event position to container\n          var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;\n          var currentTouchTopRel = currentTouchTop - self.__clientTop;\n\n          // Recompute left and top coordinates based on new zoom level\n          scrollLeft =\n            ((currentTouchLeftRel + scrollLeft) * level) / oldLevel -\n            currentTouchLeftRel;\n          scrollTop =\n            ((currentTouchTopRel + scrollTop) * level) / oldLevel -\n            currentTouchTopRel;\n\n          // Recompute max scroll values\n          self.__computeScrollMax(level);\n        }\n      }\n\n      if (self.__enableScrollX) {\n        scrollLeft -= moveX * this.options.speedMultiplier;\n        var maxScrollLeft = self.__maxScrollLeft;\n\n        if (scrollLeft > maxScrollLeft || scrollLeft < 0) {\n          // Slow down on the edges\n          if (self.options.bouncing) {\n            scrollLeft += (moveX / 2) * this.options.speedMultiplier;\n          } else if (scrollLeft > maxScrollLeft) {\n            scrollLeft = maxScrollLeft;\n          } else {\n            scrollLeft = 0;\n          }\n        }\n      }\n\n      // Compute new vertical scroll position\n      if (self.__enableScrollY) {\n        scrollTop -= moveY * this.options.speedMultiplier;\n        var maxScrollTop = self.__maxScrollTop;\n\n        if (scrollTop > maxScrollTop || scrollTop < 0) {\n          // Slow down on the edges\n          if (self.options.bouncing) {\n            scrollTop += (moveY / 2) * this.options.speedMultiplier;\n\n            // Support pull-to-refresh (only when only y is scrollable)\n            if (\n              !self.__enableScrollX &&\n              (self.__refreshHeight != null || self.__loadHeight != null)\n            ) {\n              if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {\n                self.__refreshActive = true;\n                if (self.__refreshActivate) {\n                  self.__refreshActivate();\n                }\n              } else if (\n                self.__refreshActive &&\n                scrollTop > -self.__refreshHeight\n              ) {\n                self.__refreshActive = false;\n                if (self.__refreshDeactivate) {\n                  self.__refreshDeactivate();\n                }\n              }\n              // handle for push-load\n              else if (\n                !self.__loadActive &&\n                scrollTop >= self.__maxScrollTop + self.__loadHeight\n              ) {\n                self.__loadActive = true;\n                if (self.__loadActivate) {\n                  self.__loadActivate();\n                }\n              } else if (\n                self.__refreshActive &&\n                scrollTop < self.__maxScrollTop + self.__loadHeight\n              ) {\n                self.__loadActive = false;\n                if (self.__loadDeactivate) {\n                  self.__loadDeactivate();\n                }\n              }\n            }\n          } else if (scrollTop > maxScrollTop) {\n            scrollTop = maxScrollTop;\n          } else {\n            scrollTop = 0;\n          }\n        }\n      }\n\n      // Keep list from growing infinitely (holding min 10, max 20 measure points)\n      if (positions.length > 60) {\n        positions.splice(0, 30);\n      }\n\n      // Track scroll movement for decleration\n      positions.push(scrollLeft, scrollTop, timeStamp);\n\n      // Sync scroll position\n      self.__publish(scrollLeft, scrollTop, level);\n\n      // Otherwise figure out whether we are switching into dragging mode now.\n    } else {\n      var minimumTrackingForScroll = self.options.locking ? 3 : 0;\n      var minimumTrackingForDrag = 5;\n\n      var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);\n      var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);\n\n      self.__enableScrollX =\n        self.options.scrollingX && distanceX >= minimumTrackingForScroll;\n      self.__enableScrollY =\n        self.options.scrollingY && distanceY >= minimumTrackingForScroll;\n\n      positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);\n\n      self.__isDragging =\n        (self.__enableScrollX || self.__enableScrollY) &&\n        (distanceX >= minimumTrackingForDrag ||\n          distanceY >= minimumTrackingForDrag);\n      if (self.__isDragging) {\n        self.__interruptedAnimation = false;\n      }\n    }\n\n    // Update last touch positions and time stamp for next event\n    self.__lastTouchLeft = currentTouchLeft;\n    self.__lastTouchTop = currentTouchTop;\n    self.__lastTouchMove = timeStamp;\n    self.__lastScale = scale;\n  },\n\n  /**\n   * Touch end handler for scrolling support\n   */\n  doTouchEnd: function(timeStamp) {\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== 'number') {\n      throw new Error('Invalid timestamp value: ' + timeStamp);\n    }\n\n    var self = this;\n\n    // Ignore event when tracking is not enabled (no touchstart event on element)\n    // This is required as this listener ('touchmove') sits on the document and not on the element itself.\n    if (!self.__isTracking) {\n      return;\n    }\n\n    // Not touching anymore (when two finger hit the screen there are two touch end events)\n    self.__isTracking = false;\n\n    // Be sure to reset the dragging flag now. Here we also detect whether\n    // the finger has moved fast enough to switch into a deceleration animation.\n    if (self.__isDragging) {\n      // Reset dragging flag\n      self.__isDragging = false;\n\n      // Start deceleration\n      // Verify that the last move detected was in some relevant time frame\n      if (\n        self.__isSingleTouch &&\n        self.options.animating &&\n        timeStamp - self.__lastTouchMove <= 100\n      ) {\n        // Then figure out what the scroll position was about 100ms ago\n        var positions = self.__positions;\n        var endPos = positions.length - 1;\n        var startPos = endPos;\n\n        // Move pointer to position measured 100ms ago\n        for (\n          var i = endPos;\n          i > 0 && positions[i] > self.__lastTouchMove - 100;\n          i -= 3\n        ) {\n          startPos = i;\n        }\n\n        // If start and stop position is identical in a 100ms timeframe,\n        // we cannot compute any useful deceleration.\n        if (startPos !== endPos) {\n          // Compute relative movement between these two points\n          var timeOffset = positions[endPos] - positions[startPos];\n          var movedLeft = self.__scrollLeft - positions[startPos - 2];\n          var movedTop = self.__scrollTop - positions[startPos - 1];\n\n          // Based on 50ms compute the movement to apply for each render step\n          self.__decelerationVelocityX = (movedLeft / timeOffset) * (1000 / 60);\n          self.__decelerationVelocityY = (movedTop / timeOffset) * (1000 / 60);\n\n          // How much velocity is required to start the deceleration\n          var minVelocityToStartDeceleration =\n            self.options.paging || self.options.snapping ? 4 : 1;\n\n          // Verify that we have enough velocity to start deceleration\n          if (\n            Math.abs(self.__decelerationVelocityX) >\n              minVelocityToStartDeceleration ||\n            Math.abs(self.__decelerationVelocityY) >\n              minVelocityToStartDeceleration\n          ) {\n            // Deactivate pull-to-refresh when decelerating\n            if (!self.__refreshActive && !self.__loadActive) {\n              self.__startDeceleration(timeStamp);\n            }\n          } else {\n            self.__scrollComplete();\n          }\n        } else {\n          self.__scrollComplete();\n        }\n      } else if (timeStamp - self.__lastTouchMove > 100) {\n        self.__scrollComplete();\n      }\n    }\n\n    // If this was a slower move it is per default non decelerated, but this\n    // still means that we want snap back to the bounds which is done here.\n    // This is placed outside the condition above to improve edge case stability\n    // e.g. touchend fired without enabled dragging. This should normally do not\n    // have modified the scroll positions or even showed the scrollbars though.\n    if (!self.__isDecelerating) {\n      if (self.__refreshActive && self.__refreshStart) {\n        // Use publish instead of scrollTo to allow scrolling to out of boundary position\n        // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n        self.__publish(\n          self.__scrollLeft,\n          -self.__refreshHeight,\n          self.__zoomLevel,\n          true\n        );\n\n        if (self.__refreshStart) {\n          self.__refreshStart();\n        }\n      } else if (self.__loadActive && self.__loadStart) {\n        // Use publish instead of scrollTo to allow scrolling to out of boundary position\n        // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n        self.__publish(\n          self.__scrollLeft,\n          self.__maxScrollTop + self.__loadHeight,\n          self.__zoomLevel,\n          true\n        );\n\n        if (self.__loadStart) {\n          self.__loadStart();\n        }\n      } else {\n        if (self.__interruptedAnimation || self.__isDragging) {\n          self.__scrollComplete();\n        }\n        self.scrollTo(\n          self.__scrollLeft,\n          self.__scrollTop,\n          true,\n          self.__zoomLevel\n        );\n\n        // Directly signalize deactivation (nothing todo on refresh?)\n        if (self.__refreshActive) {\n          self.__refreshActive = false;\n          if (self.__refreshDeactivate) {\n            self.__refreshDeactivate();\n          }\n        } else if (self.__loadActive) {\n          self.__loadActive = false;\n          if (self.__loadDeactivate) {\n            self.__loadDeactivate();\n          }\n        }\n      }\n    }\n\n    // Fully cleanup list\n    self.__positions.length = 0;\n  },\n\n  /** Handle for scroll/publish */\n  onScroll: NOOP,\n\n  stop: function() {\n    var self = this;\n\n    self.__disable = true;\n  },\n  start: function() {\n    self.__disable = true;\n  },\n  /*\n\t---------------------------------------------------------------------------\n\t\tPRIVATE API\n\t---------------------------------------------------------------------------\n\t*/\n\n  /**\n   * Applies the scroll position to the content element\n   *\n   * @param left {Number} Left scroll position\n   * @param top {Number} Top scroll position\n   * @param animate {Boolean?false} Whether animation should be used to move to the new coordinates\n   */\n  __publish: function(left, top, zoom, animate) {\n    var self = this;\n    if (self.__disable) {\n      return;\n    }\n    if (isNaN(left)) {\n      left = this.__scrollLeft;\n    }\n    if (isNaN(top)) {\n      top = this.__scrollTop;\n    }\n    // Remember whether we had an animation, then we try to continue based on the current \"drive\" of the animation\n    var wasAnimating = self.__isAnimating;\n    if (wasAnimating) {\n      core.effect.Animate.stop(wasAnimating);\n      self.__isAnimating = false;\n    }\n\n    if (animate && self.options.animating) {\n      // Keep scheduled positions for scrollBy/zoomBy functionality\n      self.__scheduledLeft = left;\n      self.__scheduledTop = top;\n      self.__scheduledZoom = zoom;\n\n      var oldLeft = self.__scrollLeft;\n      var oldTop = self.__scrollTop;\n      var oldZoom = self.__zoomLevel;\n\n      var diffLeft = left - oldLeft;\n      var diffTop = top - oldTop;\n      var diffZoom = zoom - oldZoom;\n\n      var step = function(percent, now, render) {\n        if (render) {\n          self.__scrollLeft = oldLeft + diffLeft * percent;\n          self.__scrollTop = oldTop + diffTop * percent;\n          self.__zoomLevel = oldZoom + diffZoom * percent;\n\n          // Push values out\n          if (self.__callback) {\n            self.__callback(\n              self.__scrollLeft,\n              self.__scrollTop,\n              self.__zoomLevel\n            );\n            self.onScroll();\n          }\n        }\n      };\n\n      var verify = function(id) {\n        return self.__isAnimating === id;\n      };\n\n      var completed = function(\n        renderedFramesPerSecond,\n        animationId,\n        wasFinished\n      ) {\n        if (animationId === self.__isAnimating) {\n          self.__isAnimating = false;\n        }\n        if (self.__didDecelerationComplete || wasFinished) {\n          self.__scrollComplete();\n        }\n\n        if (self.options.zooming) {\n          self.__computeScrollMax();\n          if (self.__zoomComplete) {\n            self.__zoomComplete();\n            self.__zoomComplete = null;\n          }\n        }\n      };\n\n      // When continuing based on previous animation we choose an ease-out animation instead of ease-in-out\n      self.__isAnimating = core.effect.Animate.start(\n        step,\n        verify,\n        completed,\n        self.options.animationDuration,\n        wasAnimating ? animatingMethod : noAnimatingMethod\n      );\n    } else {\n      self.__scheduledLeft = self.__scrollLeft = left;\n      self.__scheduledTop = self.__scrollTop = top;\n      self.__scheduledZoom = self.__zoomLevel = zoom;\n\n      // Push values out\n      if (self.__callback) {\n        self.__callback(left, top, zoom);\n        self.onScroll();\n      }\n\n      // Fix max scroll ranges\n      if (self.options.zooming) {\n        self.__computeScrollMax();\n        if (self.__zoomComplete) {\n          self.__zoomComplete();\n          self.__zoomComplete = null;\n        }\n      }\n    }\n  },\n\n  /**\n   * Recomputes scroll minimum values based on client dimensions and content dimensions.\n   */\n  __computeScrollMax: function(zoomLevel) {\n    var self = this;\n\n    if (zoomLevel == null) {\n      zoomLevel = self.__zoomLevel;\n    }\n\n    self.__maxScrollLeft = Math.max(\n      self.__contentWidth * zoomLevel - self.__clientWidth,\n      0\n    );\n    self.__maxScrollTop = Math.max(\n      self.__contentHeight * zoomLevel - self.__clientHeight,\n      0\n    );\n  },\n  /** compute current page total page */\n  __computePage: function() {\n    var self = this;\n    var clientWidth = self.__clientWidth;\n    var clientHeight = self.__clientHeight;\n    var left = self.__scrollLeft;\n    var top = self.__scrollTop;\n    self.__totalXPage = Math.ceil(self.__contentWidth / clientWidth);\n    self.__currentPageX = Math.ceil(left / clientWidth + 1);\n    self.__totalYPage = Math.ceil(self.__contentHeight / clientHeight);\n    self.__currentPageY = Math.ceil(top / clientHeight + 1);\n  },\n  /** complete scroll*/\n  __scrollComplete: function() {\n    var self = this;\n    self.options.scrollingComplete();\n  },\n  /*\n\t---------------------------------------------------------------------------\n\t\tANIMATION (DECELERATION) SUPPORT\n\t---------------------------------------------------------------------------\n\t*/\n\n  /**\n   * Called when a touch sequence end and the speed of the finger was high enough\n   * to switch into deceleration mode.\n   */\n  __startDeceleration: function() {\n    var self = this;\n\n    if (self.options.paging) {\n      var scrollLeft = Math.max(\n        Math.min(self.__scrollLeft, self.__maxScrollLeft),\n        0\n      );\n      var scrollTop = Math.max(\n        Math.min(self.__scrollTop, self.__maxScrollTop),\n        0\n      );\n      var clientWidth = self.__clientWidth;\n      var clientHeight = self.__clientHeight;\n\n      // We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.\n      // Each page should have exactly the size of the client area.\n      self.__minDecelerationScrollLeft =\n        Math.floor(scrollLeft / clientWidth) * clientWidth;\n      self.__minDecelerationScrollTop =\n        Math.floor(scrollTop / clientHeight) * clientHeight;\n      self.__maxDecelerationScrollLeft =\n        Math.ceil(scrollLeft / clientWidth) * clientWidth;\n      self.__maxDecelerationScrollTop =\n        Math.ceil(scrollTop / clientHeight) * clientHeight;\n    } else {\n      self.__minDecelerationScrollLeft = 0;\n      self.__minDecelerationScrollTop = 0;\n      self.__maxDecelerationScrollLeft = self.__maxScrollLeft;\n      self.__maxDecelerationScrollTop = self.__maxScrollTop;\n    }\n\n    // Wrap class method\n    var step = function(percent, now, render) {\n      self.__stepThroughDeceleration(render);\n    };\n\n    // How much velocity is required to keep the deceleration running\n    var minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.001;\n\n    // Detect whether it's still worth to continue animating steps\n    // If we are already slow enough to not being user perceivable anymore, we stop the whole process here.\n    var verify = function() {\n      var shouldContinue =\n        Math.abs(self.__decelerationVelocityX) >=\n          minVelocityToKeepDecelerating ||\n        Math.abs(self.__decelerationVelocityY) >= minVelocityToKeepDecelerating;\n      if (!shouldContinue) {\n        self.__didDecelerationComplete = true;\n      }\n      return shouldContinue;\n    };\n\n    var completed = function() {\n      if (!self.__isDecelerating) {\n        return;\n      }\n      self.__isDecelerating = false;\n      if (self.__didDecelerationComplete) {\n        self.__scrollComplete();\n      }\n\n      // Animate to grid when snapping is active, otherwise just fix out-of-boundary positions\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);\n    };\n\n    // Start animation and switch on flag\n    self.__isDecelerating = core.effect.Animate.start(step, verify, completed);\n  },\n\n  /**\n   * Called on every step of the animation\n   *\n   * @param inMemory {Boolean?false} Whether to not render the current step, but keep it in memory only. Used internally only!\n   */\n  __stepThroughDeceleration: function(render) {\n    var self = this;\n\n    //\n    // COMPUTE NEXT SCROLL POSITION\n    //\n\n    // Add deceleration to scroll position\n    var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;\n    var scrollTop = self.__scrollTop + self.__decelerationVelocityY;\n\n    //\n    // HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE\n    //\n\n    if (!self.options.bouncing) {\n      var scrollLeftFixed = Math.max(\n        Math.min(self.__maxDecelerationScrollLeft, scrollLeft),\n        self.__minDecelerationScrollLeft\n      );\n      if (scrollLeftFixed !== scrollLeft) {\n        scrollLeft = scrollLeftFixed;\n        self.__decelerationVelocityX = 0;\n      }\n\n      var scrollTopFixed = Math.max(\n        Math.min(self.__maxDecelerationScrollTop, scrollTop),\n        self.__minDecelerationScrollTop\n      );\n      if (scrollTopFixed !== scrollTop) {\n        scrollTop = scrollTopFixed;\n        self.__decelerationVelocityY = 0;\n      }\n    }\n\n    //\n    // UPDATE SCROLL POSITION\n    //\n\n    if (render) {\n      self.__publish(scrollLeft, scrollTop, self.__zoomLevel);\n    } else {\n      self.__scrollLeft = scrollLeft;\n      self.__scrollTop = scrollTop;\n    }\n\n    //\n    // SLOW DOWN\n    //\n\n    // Slow down velocity on every iteration\n    if (!self.options.paging) {\n      // This is the factor applied to every iteration of the animation\n      // to slow down the process. This should emulate natural behavior where\n      // objects slow down when the initiator of the movement is removed\n      var frictionFactor = 0.95;\n\n      self.__decelerationVelocityX *= frictionFactor;\n      self.__decelerationVelocityY *= frictionFactor;\n    }\n\n    //\n    // BOUNCING SUPPORT\n    //\n\n    if (self.options.bouncing) {\n      var scrollOutsideX = 0;\n      var scrollOutsideY = 0;\n\n      // This configures the amount of change applied to deceleration/acceleration when reaching boundaries\n      var penetrationDeceleration = self.options.penetrationDeceleration;\n      var penetrationAcceleration = self.options.penetrationAcceleration;\n\n      // Check limits\n      if (scrollLeft < self.__minDecelerationScrollLeft) {\n        scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;\n      } else if (scrollLeft > self.__maxDecelerationScrollLeft) {\n        scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;\n      }\n\n      if (scrollTop < self.__minDecelerationScrollTop) {\n        scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;\n      } else if (scrollTop > self.__maxDecelerationScrollTop) {\n        scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;\n      }\n\n      // Slow down until slow enough, then flip back to snap position\n      if (scrollOutsideX !== 0) {\n        if (scrollOutsideX * self.__decelerationVelocityX <= 0) {\n          self.__decelerationVelocityX +=\n            scrollOutsideX * penetrationDeceleration;\n        } else {\n          self.__decelerationVelocityX =\n            scrollOutsideX * penetrationAcceleration;\n        }\n      }\n\n      if (scrollOutsideY !== 0) {\n        if (scrollOutsideY * self.__decelerationVelocityY <= 0) {\n          self.__decelerationVelocityY +=\n            scrollOutsideY * penetrationDeceleration;\n        } else {\n          self.__decelerationVelocityY =\n            scrollOutsideY * penetrationAcceleration;\n        }\n      }\n    }\n  }\n};\n\n// Copy over members to prototype\nfor (var key in members) {\n  Scroller.prototype[key] = members[key];\n}\n","import Scroller from '../../third-party/scroller';\nimport { render } from '../../third-party/scroller/render';\nimport { listenContainer } from '../../third-party/scroller/listener';\n\n/**\n * @description refresh and load callback\n */\nfunction createStateCallbacks(type, stageName, vm, tipDom) {\n  const listeners = vm.$listeners;\n\n  let activateCallback = () => {\n    vm.vuescroll.state[stageName] = 'active';\n  };\n\n  let deactivateCallback = () => {\n    vm.vuescroll.state[stageName] = 'deactive';\n  };\n\n  let startCallback = () => {\n    vm.vuescroll.state[stageName] = 'start';\n    setTimeout(() => {\n      vm.scroller.finishRefreshOrLoad();\n    }, 2000);\n  };\n\n  let beforeDeactivateCallback = done => {\n    vm.vuescroll.state[stageName] = 'beforeDeactive';\n    setTimeout(function() {\n      done();\n    }, 500);\n  };\n  /* istanbul ignore if */\n  if (listeners[type + '-activate']) {\n    activateCallback = () => {\n      vm.vuescroll.state[stageName] = 'active';\n      vm.$emit(type + '-activate', vm, tipDom);\n    };\n  }\n  /* istanbul ignore if */\n  if (listeners[type + '-before-deactivate']) {\n    beforeDeactivateCallback = done => {\n      vm.vuescroll.state[stageName] = 'beforeDeactive';\n      vm.$emit(type + '-before-deactivate', vm, tipDom, done.bind(vm.scroller));\n    };\n  }\n  /* istanbul ignore if */\n  if (listeners[type + '-deactivate']) {\n    deactivateCallback = () => {\n      vm.vuescroll.state[stageName] = 'deactive';\n      vm.$emit(type + '-deactivate', vm, tipDom);\n    };\n  }\n  /* istanbul ignore if */\n  if (listeners[type + '-start']) {\n    startCallback = () => {\n      vm.vuescroll.state[stageName] = 'start';\n      vm.$emit(\n        type + '-start',\n        vm,\n        tipDom,\n        vm.scroller.finishRefreshOrLoad.bind(vm.scroller)\n      );\n    };\n  }\n\n  return {\n    activateCallback,\n    deactivateCallback,\n    startCallback,\n    beforeDeactivateCallback\n  };\n}\n\nexport default {\n  methods: {\n    // Update:\n    // 1. update height/width\n    // 2. update refresh or load\n    updateScroller() {\n      this.updateDimesion();\n      this.registryRefreshLoad();\n    },\n    updateDimesion() {\n      const clientWidth = this.$el.clientWidth;\n      const clientHeight = this.$el.clientHeight;\n      let contentWidth = this.scrollPanelElm.scrollWidth;\n      let contentHeight = this.scrollPanelElm.scrollHeight;\n      let refreshHeight = 0;\n      let loadHeight = 0;\n      // If the refresh option is true,let's  give a \"margin-top\" style to\n      // the refresh-tip dom. let it to be invisible when doesn't trigger\n      // refresh.\n      if (this.mergedOptions.vuescroll.pullRefresh.enable) {\n        const refreshDom =\n          this.$refs['refreshDom'].elm || this.$refs['refreshDom'];\n        refreshHeight = refreshDom.offsetHeight;\n        if (!refreshDom.style.marginTop) {\n          refreshDom.style.marginTop = -refreshHeight + 'px';\n        }\n      }\n      if (this.mergedOptions.vuescroll.pushLoad.enable) {\n        const enableLoad = this.isEnableLoad();\n        if (enableLoad) {\n          const loadDom = this.$refs['loadDom'].elm || this.$refs['loadDom'];\n          loadHeight = loadDom.offsetHeight;\n          //  hide the trailing load dom..\n          contentHeight -= loadHeight;\n        }\n      }\n      if (this.scroller) {\n        this.scroller.setDimensions(\n          clientWidth,\n          clientHeight,\n          contentWidth,\n          contentHeight,\n          false\n        );\n      }\n    },\n    registryRefreshLoad() {\n      // registry refresh\n      if (this.mergedOptions.vuescroll.pullRefresh.enable) {\n        this.registryEvent('refresh');\n      }\n      // registry load\n      if (this.mergedOptions.vuescroll.pushLoad.enable) {\n        this.registryEvent('load');\n      }\n    },\n    registryScroller() {\n      const preventDefault = this.mergedOptions.vuescroll.scroller\n        .preventDefault;\n      const paging = this.mergedOptions.vuescroll.paging;\n      const snapping = this.mergedOptions.vuescroll.snapping.enable;\n      // disale zooming when refresh or load enabled\n      let zooming =\n        !this.refreshLoad &&\n        !paging &&\n        !snapping &&\n        this.mergedOptions.vuescroll.zooming;\n      const { scrollingY, scrollingX } = this.mergedOptions.scrollPanel;\n\n      const scrollingComplete = this.scrollingComplete.bind(this);\n\n      // Initialize Scroller\n      this.scroller = new Scroller(render(this.scrollPanelElm, window, 'px'), {\n        ...this.mergedOptions.vuescroll.scroller,\n        zooming,\n        scrollingY,\n        scrollingX: scrollingX && !this.refreshLoad,\n        animationDuration: this.mergedOptions.scrollPanel.speed,\n        paging,\n        snapping,\n        scrollingComplete\n      });\n\n      // Set snap\n      if (snapping) {\n        this.scroller.setSnapSize(\n          this.mergedOptions.vuescroll.snapping.width,\n          this.mergedOptions.vuescroll.snapping.height\n        );\n      }\n      var rect = this.$el.getBoundingClientRect();\n      this.scroller.setPosition(\n        rect.left + this.$el.clientLeft,\n        rect.top + this.$el.clientTop\n      );\n\n      // Get destroy callback\n      const cb = listenContainer(\n        this.$el,\n        this.scroller,\n        eventType => {\n          // Thie is to dispatch the event from the scroller.\n          // to let vuescroll refresh the dom\n          switch (eventType) {\n          case 'mousedown':\n            this.vuescroll.state.isDragging = true;\n            break;\n          case 'onscroll':\n            this.handleScroll(false);\n            break;\n          case 'mouseup':\n            this.vuescroll.state.isDragging = false;\n            break;\n          }\n        },\n        zooming,\n        preventDefault\n      );\n\n      this.updateScroller();\n\n      return cb;\n    },\n    updateSlideModeBarState() {\n      // update slide mode scrollbars' state\n      let heightPercentage, widthPercentage;\n      const vuescroll = this.$el;\n      const scroller = this.scroller;\n      let outerLeft = 0;\n      let outerTop = 0;\n      const clientWidth = this.$el.clientHeight;\n      const clientHeight = this.$el.clientHeight;\n      const contentWidth = clientWidth + this.scroller.__maxScrollLeft;\n      const contentHeight = clientHeight + this.scroller.__maxScrollTop;\n      const __enableScrollX =\n        clientWidth < contentWidth && this.mergedOptions.scrollPanel.scrollingX;\n      const __enableScrollY =\n        clientHeight < contentHeight &&\n        this.mergedOptions.scrollPanel.scrollingY;\n      // out of horizontal bountry\n      if (__enableScrollX) {\n        /* istanbul ignore if */\n        if (scroller.__scrollLeft < 0) {\n          outerLeft = -scroller.__scrollLeft;\n        } /* istanbul ignore next */ else if (\n          scroller.__scrollLeft > scroller.__maxScrollLeft\n        ) {\n          outerLeft = scroller.__scrollLeft - scroller.__maxScrollLeft;\n        }\n      }\n      // out of vertical bountry\n      if (__enableScrollY) {\n        if (scroller.__scrollTop < 0) {\n          outerTop = -scroller.__scrollTop;\n        } else if (scroller.__scrollTop > scroller.__maxScrollTop) {\n          outerTop = scroller.__scrollTop - scroller.__maxScrollTop;\n        }\n      }\n      heightPercentage = (clientHeight * 100) / (contentHeight + outerTop);\n      widthPercentage = (clientWidth * 100) / (contentWidth + outerLeft);\n      const scrollTop = Math.min(\n        Math.max(0, scroller.__scrollTop),\n        scroller.__maxScrollTop\n      );\n      const scrollLeft = Math.min(\n        Math.max(0, scroller.__scrollLeft),\n        scroller.__maxScrollLeft\n      );\n      this.bar.vBar.state.posValue =\n        ((scrollTop + outerTop) * 100) / vuescroll.clientHeight;\n      this.bar.hBar.state.posValue =\n        ((scrollLeft + outerLeft) * 100) / vuescroll.clientWidth;\n      /* istanbul ignore if */\n      if (scroller.__scrollLeft < 0) {\n        this.bar.hBar.state.posValue = 0;\n      }\n      if (scroller.__scrollTop < 0) {\n        this.bar.vBar.state.posValue = 0;\n      }\n      this.bar.vBar.state.size =\n        heightPercentage < 100 ? heightPercentage + '%' : 0;\n      this.bar.hBar.state.size =\n        widthPercentage < 100 ? widthPercentage + '%' : 0;\n    },\n    registryEvent(type) {\n      const domName = type == 'refresh' ? 'refreshDom' : 'loadDom';\n      const activateFunc =\n        type == 'refresh'\n          ? this.scroller.activatePullToRefresh\n          : this.scroller.activatePushToLoad;\n      const stageName = type == 'refresh' ? 'refreshStage' : 'loadStage';\n      const tipDom = this.$refs[domName].elm || this.$refs[domName];\n      const cbs = createStateCallbacks(type, stageName, this, tipDom);\n      const height = tipDom.offsetHeight;\n      activateFunc.bind(this.scroller)(height, cbs);\n    }\n  }\n};\n","import { modes } from './constants';\nimport { error } from '../util';\nexport default {\n  // vuescroll\n  vuescroll: {\n    mode: 'native',\n    // vuescroll's size(height/width) should be a percent(100%)\n    // or be a number that is equal to its parentNode's width or\n    // height ?\n    sizeStrategy: 'percent',\n    // pullRefresh or pushLoad is only for the slide mode...\n    pullRefresh: {\n      enable: false,\n      tips: {\n        deactive: 'Pull to Refresh',\n        active: 'Release to Refresh',\n        start: 'Refreshing...',\n        beforeDeactive: 'Refresh Successfully!'\n      }\n    },\n    pushLoad: {\n      enable: false,\n      tips: {\n        deactive: 'Push to Load',\n        active: 'Release to Load',\n        start: 'Loading...',\n        beforeDeactive: 'Load Successfully!'\n      }\n    },\n    paging: false,\n    zooming: true,\n    snapping: {\n      enable: false,\n      width: 100,\n      height: 100\n    },\n    // some scroller options\n    scroller: {\n      /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\n      bouncing: true,\n      /** Enable locking to the main axis if user moves only slightly on one of them at start */\n      locking: true,\n      /** Minimum zoom level */\n      minZoom: 0.5,\n      /** Maximum zoom level */\n      maxZoom: 3,\n      /** Multiply or decrease scrolling speed **/\n      speedMultiplier: 1,\n      /** This configures the amount of change applied to deceleration when reaching boundaries  **/\n      penetrationDeceleration: 0.03,\n      /** This configures the amount of change applied to acceleration when reaching boundaries  **/\n      penetrationAcceleration: 0.08,\n      /** Whether call e.preventDefault event when sliding the content or not */\n      preventDefault: true\n    }\n  },\n  scrollPanel: {\n    // when component mounted.. it will automatically scrolls.\n    initialScrollY: false,\n    initialScrollX: false,\n    // feat: #11\n    scrollingX: true,\n    scrollingY: true,\n    speed: 300,\n    easing: undefined\n  },\n  //\n  scrollContent: {\n    padding: false\n  },\n  //\n  rail: {\n    vRail: {\n      width: '6px',\n      pos: 'right',\n      background: '#01a99a',\n      opacity: 0\n    },\n    //\n    hRail: {\n      height: '6px',\n      pos: 'bottom',\n      background: '#01a99a',\n      opacity: 0\n    }\n  },\n  bar: {\n    showDelay: 500,\n    onlyShowBarOnScroll: true,\n    vBar: {\n      background: '#00a650',\n      keepShow: false,\n      opacity: 1,\n      hover: false\n    },\n    //\n    hBar: {\n      background: '#00a650',\n      keepShow: false,\n      opacity: 1,\n      hover: false\n    }\n  }\n};\n/**\n * validate the options\n *\n * @export\n * @param {any} ops\n */\nexport function validateOptions(ops) {\n  let shouldStopRender = false;\n  const { vuescroll, scrollPanel } = ops;\n\n  // validate vuescroll\n  if (!~modes.indexOf(vuescroll.mode)) {\n    error(`The vuescroll's option \"mode\" should be one of the ${modes}`);\n    shouldStopRender = true;\n  }\n\n  if (\n    vuescroll.paging == vuescroll.snapping.enable &&\n    vuescroll.paging &&\n    (vuescroll.pullRefresh || vuescroll.pushLoad)\n  ) {\n    error(\n      'paging, snapping, (pullRefresh with pushLoad) can only one of them to be true.'\n    );\n  }\n  // validate scrollPanel\n  const initialScrollY = scrollPanel['initialScrollY'];\n  const initialScrollX = scrollPanel['initialScrollX'];\n\n  if (initialScrollY && !String(initialScrollY).match(/^\\d+(\\.\\d+)?(%)?$/)) {\n    error(\n      'The prop `initialScrollY` should be a percent number like 10% or an exact number that greater than or equal to 0 like 100.'\n    );\n  }\n\n  if (initialScrollX && !String(initialScrollX).match(/^\\d+(\\.\\d+)?(%)?$/)) {\n    error(\n      'The prop `initialScrollX` should be a percent number like 10% or an exact number that greater than or equal to 0 like 100.'\n    );\n  }\n\n  return shouldStopRender;\n}\n","import GCF, { validateOptions } from '../shared/global-config';\nimport { deepMerge, defineReactive } from '../util';\n\n/**\n * hack the lifeCycle\n *\n * to merge the global data into user-define data\n */\nfunction hackPropsData() {\n  const vm = this;\n  if (vm.$options.name === 'vueScroll') {\n    const _gfc = deepMerge(vm.$vuescrollConfig, {});\n    const ops = deepMerge(GCF, _gfc);\n    vm.$options.propsData.ops = vm.$options.propsData.ops || {};\n    Object.keys(vm.$options.propsData.ops).forEach(key => {\n      {\n        defineReactive(vm.mergedOptions, key, vm.$options.propsData.ops);\n      }\n    });\n    // from ops to mergedOptions\n    deepMerge(ops, vm.mergedOptions);\n\n    const prefix = 'padding-';\n    defineReactive(vm.mergedOptions.scrollContent, 'paddPos', () => {\n      return prefix + vm.mergedOptions.rail.vRail.pos;\n    });\n    defineReactive(vm.mergedOptions.scrollContent, 'paddValue', () => {\n      return vm.mergedOptions.rail.vRail.width;\n    });\n  }\n}\nexport default {\n  data() {\n    return {\n      shouldStopRender: false,\n      mergedOptions: {\n        vuescroll: {},\n        scrollPanel: {},\n        scrollContent: {},\n        rail: {},\n        bar: {}\n      }\n    };\n  },\n  created() {\n    hackPropsData.call(this);\n\n    this._isVuescrollRoot = true;\n\n    this.renderError = validateOptions(this.mergedOptions);\n  }\n};\n","import {\n  createEasingFunction,\n  easingPattern\n} from '../third-party/easingPattern';\nimport { core } from '../third-party/scroller/animate';\nimport { warn, isChildInParent } from '../util';\n\nconst vsInstances = {};\n\nexport function refreshAll() {\n  for (let vs in vsInstances) {\n    vsInstances[vs].refresh();\n  }\n}\n\nfunction getNumericValue(distance, size) {\n  let number;\n  if (!(number = /(-?\\d+(?:\\.\\d+?)?)%$/.exec(distance))) {\n    number = distance - 0;\n  } else {\n    number = number[1] - 0;\n    number = (size * number) / 100;\n  }\n  return number;\n}\n\nfunction goScrolling(elm, deltaX, deltaY, speed, easing, scrollingComplete) {\n  const startLocationY = elm['scrollTop'];\n  const startLocationX = elm['scrollLeft'];\n  let positionX = startLocationX;\n  let positionY = startLocationY;\n  /**\n   * keep the limit of scroll delta.\n   */\n  /* istanbul ignore next */\n  if (startLocationY + deltaY < 0) {\n    deltaY = -startLocationY;\n  }\n  const scrollHeight = elm['scrollHeight'];\n  if (startLocationY + deltaY > scrollHeight) {\n    deltaY = scrollHeight - startLocationY;\n  }\n  if (startLocationX + deltaX < 0) {\n    deltaX = -startLocationX;\n  }\n  if (startLocationX + deltaX > elm['scrollWidth']) {\n    deltaX = elm['scrollWidth'] - startLocationX;\n  }\n\n  const easingMethod = createEasingFunction(easing, easingPattern);\n\n  const stepCallback = percentage => {\n    positionX = startLocationX + deltaX * percentage;\n    positionY = startLocationY + deltaY * percentage;\n    elm['scrollTop'] = Math.floor(positionY);\n    elm['scrollLeft'] = Math.floor(positionX);\n  };\n\n  const verifyCallback = () => {\n    return (\n      Math.abs(positionY - startLocationY) <= Math.abs(deltaY) ||\n      Math.abs(positionX - startLocationX) <= Math.abs(deltaX)\n    );\n  };\n\n  core.effect.Animate.start(\n    stepCallback,\n    verifyCallback,\n    scrollingComplete,\n    speed,\n    easingMethod\n  );\n}\n\nexport default {\n  mounted() {\n    vsInstances[this._uid] = this;\n  },\n  beforeDestroy() {\n    delete vsInstances[this._uid];\n  },\n  methods: {\n    // public api\n    scrollTo({ x, y }, animate = true, force = false) {\n      if (typeof x === 'undefined') {\n        x = this.vuescroll.state.internalScrollLeft || 0;\n      } else {\n        x = getNumericValue(x, this.scrollPanelElm.scrollWidth);\n      }\n      if (typeof y === 'undefined') {\n        y = this.vuescroll.state.internalScrollTop || 0;\n      } else {\n        y = getNumericValue(y, this.scrollPanelElm.scrollHeight);\n      }\n      this.internalScrollTo(x, y, animate, force);\n    },\n    scrollBy({ dx = 0, dy = 0 }, animate = true) {\n      let {\n        internalScrollLeft = 0,\n        internalScrollTop = 0\n      } = this.vuescroll.state;\n      if (dx) {\n        internalScrollLeft += getNumericValue(\n          dx,\n          this.scrollPanelElm.scrollWidth\n        );\n      }\n      if (dy) {\n        internalScrollTop += getNumericValue(\n          dy,\n          this.scrollPanelElm.scrollHeight\n        );\n      }\n      this.internalScrollTo(internalScrollLeft, internalScrollTop, animate);\n    },\n    zoomBy(factor, animate, originLeft, originTop, callback) {\n      if (this.mode != 'slide') {\n        warn('zoomBy and zoomTo are only for slide mode!');\n        return;\n      }\n      this.scroller.zoomBy(factor, animate, originLeft, originTop, callback);\n    },\n    zoomTo(level, animate = false, originLeft, originTop, callback) {\n      if (this.mode != 'slide') {\n        warn('zoomBy and zoomTo are only for slide mode!');\n        return;\n      }\n      this.scroller.zoomTo(level, animate, originLeft, originTop, callback);\n    },\n    getCurrentPage() {\n      if (this.mode != 'slide' || !this.mergedOptions.vuescroll.paging) {\n        warn(\n          'getCurrentPage and goToPage are only for slide mode and paging is enble!'\n        );\n        return;\n      }\n      return this.scroller.getCurrentPage();\n    },\n    goToPage(dest, animate = false) {\n      if (this.mode != 'slide' || !this.mergedOptions.vuescroll.paging) {\n        warn(\n          'getCurrentPage and goToPage are only for slide mode and paging is enble!'\n        );\n        return;\n      }\n      this.scroller.goToPage(dest, animate);\n    },\n    triggerRefreshOrLoad(type) {\n      if (this.mode != 'slide') {\n        warn('You can only use triggerRefreshOrLoad in slide mode!');\n        return;\n      }\n      const isRefresh = this.mergedOptions.vuescroll.pullRefresh.enable;\n      const isLoad = this.mergedOptions.vuescroll.pushLoad.enable;\n      if (type == 'refresh' && !isRefresh) {\n        warn('refresh must be enabled!');\n        return;\n      } else if (type == 'load' && !isLoad) {\n        warn('load must be enabled and content\\'s height > container\\'s height!');\n        return;\n      } else if (type !== 'refresh' && type !== 'load') {\n        warn('param must be one of load and refresh!');\n        return;\n      }\n      /* istanbul ignore if */\n      if (this.vuescroll.state[`${type}Stage`] == 'start') {\n        return;\n      }\n      this.scroller.triggerRefreshOrLoad(type);\n      return true;\n    },\n    getCurrentviewDom() {\n      const parent =\n        this.mode == 'slide' || this.mode == 'pure-native'\n          ? this.scrollPanelElm\n          : this.scrollContentElm;\n      const children = parent.children;\n      const domFragment = [];\n      const isCurrentview = dom => {\n        const { left, top, width, height } = dom.getBoundingClientRect();\n        const {\n          left: parentLeft,\n          top: parentTop,\n          height: parentHeight,\n          width: parentWidth\n        } = this.$el.getBoundingClientRect();\n        if (\n          left - parentLeft + width > 0 &&\n          left - parentLeft < parentWidth &&\n          top - parentTop + height > 0 &&\n          top - parentTop < parentHeight\n        ) {\n          return true;\n        }\n        return false;\n      };\n\n      for (let i = 0; i < children.length; i++) {\n        const dom = children.item(i);\n        if (isCurrentview(dom) && !dom.isResizeElm) {\n          domFragment.push(dom);\n        }\n      }\n\n      return domFragment;\n    },\n    // private api\n    internalScrollTo(destX, destY, animate, force) {\n      if (this.mode == 'native' || this.mode == 'pure-native') {\n        if (animate) {\n          // hadnle for scroll complete\n          const scrollingComplete = this.scrollingComplete.bind(this);\n\n          goScrolling(\n            this.$refs['scrollPanel'].$el,\n            destX - this.$refs['scrollPanel'].$el.scrollLeft,\n            destY - this.$refs['scrollPanel'].$el.scrollTop,\n            this.mergedOptions.scrollPanel.speed,\n            this.mergedOptions.scrollPanel.easing,\n            scrollingComplete\n          );\n        } else {\n          this.$refs['scrollPanel'].$el.scrollTop = destY;\n          this.$refs['scrollPanel'].$el.scrollLeft = destX;\n        }\n      }\n      // for non-native we use scroller's scorllTo\n      else if (this.mode == 'slide') {\n        this.scroller.scrollTo(destX, destY, animate, undefined, force);\n      }\n    },\n    scrollIntoView(elm, animate = true) {\n      const parentElm = this.$el;\n      if (typeof elm === 'string') {\n        elm = parentElm.querySelector(elm);\n      }\n      if (!isChildInParent(elm, parentElm)) {\n        warn(\n          'The element or selector you passed is not the element of Vuescroll, please pass the element that is in Vuescroll to scrollIntoView API. '\n        );\n        return;\n      }\n      // parent elm left, top\n      const { left, top } = this.$el.getBoundingClientRect();\n      // child elm left, top\n      const { left: childLeft, top: childTop } = elm.getBoundingClientRect();\n\n      const diffX = left - childLeft;\n      const diffY = top - childTop;\n\n      this.scrollBy(\n        {\n          dx: -diffX,\n          dy: -diffY\n        },\n        animate\n      );\n    },\n    refresh() {\n      this.refreshInternalStatus();\n    },\n    // Get the times you have scrolled!\n    getScrollingTimes() {\n      return this.vuescroll.state.scrollingTimes;\n    },\n    // Clear the times you have scrolled!\n    clearScrollingTimes() {\n      this.vuescroll.state.scrollingTimes = 0;\n    }\n  }\n};\n","// detect content size change\nimport { eventCenter, isIE } from '../../util';\nexport function listenResize(element, callback) {\n  return injectObject(element, callback);\n}\n\nfunction injectObject(element, callback) {\n  if (element.hasResized) {\n    return;\n  }\n\n  var OBJECT_STYLE =\n    'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; padding: 0; margin: 0; opacity: 0; z-index: -1000; pointer-events: none;';\n  // define a wrap due to ie's zIndex bug\n  var objWrap = document.createElement('div');\n  objWrap.style.cssText = OBJECT_STYLE;\n  var object = document.createElement('object');\n  object.style.cssText = OBJECT_STYLE;\n  object.type = 'text/html';\n  object.tabIndex = -1;\n  object.onload = () => {\n    eventCenter(object.contentDocument.defaultView, 'resize', callback);\n  };\n  // https://github.com/wnr/element-resize-detector/blob/aafe9f7ea11d1eebdab722c7c5b86634e734b9b8/src/detection-strategy/object.js#L159\n  if (!isIE()) {\n    object.data = 'about:blank';\n  }\n  objWrap.isResizeElm = true;\n  objWrap.appendChild(object);\n  element.appendChild(objWrap);\n  if (isIE()) {\n    object.data = 'about:blank';\n  }\n  return function destroy() {\n    if (object.contentDocument) {\n      eventCenter(\n        object.contentDocument.defaultView,\n        'resize',\n        callback,\n        'off'\n      );\n    }\n    element.removeChild(objWrap);\n    element.hasResized = false;\n  };\n}\n","export default {\n  vertical: {\n    size: 'height',\n    opsSize: 'width',\n    posName: 'top',\n    opposName: 'bottom',\n    page: 'pageY',\n    scroll: 'scrollTop',\n    scrollSize: 'scrollHeight',\n    offset: 'offsetHeight',\n    client: 'clientY',\n    axis: 'Y'\n  },\n  horizontal: {\n    size: 'width',\n    opsSize: 'height',\n    posName: 'left',\n    opposName: 'right',\n    page: 'pageX',\n    scroll: 'scrollLeft',\n    scrollSize: 'scrollWidth',\n    offset: 'offsetWidth',\n    client: 'clientX',\n    axis: 'X'\n  }\n};\n","import scrollMap from '../../shared/scroll-map';\nimport { eventCenter, isSupportTouch, getRealParent } from '../../util';\n\nconst colorCache = {};\nconst rgbReg = /rgb\\(/;\nconst extractRgbColor = /rgb\\((.*)\\)/;\n\n/* istanbul ignore next */\nfunction createMouseEvent(ctx) {\n  const parent = getRealParent(ctx);\n\n  function mousedown(e) {\n    e.stopImmediatePropagation();\n    document.onselectstart = () => false;\n    ctx.axisStartPos =\n      e[ctx.bar.client] -\n      ctx.$refs['inner'].getBoundingClientRect()[ctx.bar.posName];\n    // tell parent that the mouse has been down.\n    ctx.$emit('setBarClick', true);\n    eventCenter(document, 'mousemove', mousemove);\n    eventCenter(document, 'mouseup', mouseup);\n  }\n  function mousemove(e) {\n    if (!ctx.axisStartPos) {\n      return;\n    }\n    const delta =\n      e[ctx.bar.client] - ctx.$el.getBoundingClientRect()[ctx.bar.posName];\n    const percent = (delta - ctx.axisStartPos) / ctx.$el[ctx.bar.offset];\n    parent.scrollTo(\n      {\n        [ctx.bar.axis.toLowerCase()]:\n          parent.scrollPanelElm[ctx.bar.scrollSize] * percent\n      },\n      false\n    );\n  }\n  function mouseup() {\n    ctx.$emit('setBarClick', false);\n    document.onselectstart = null;\n    parent.hideBar();\n    ctx.axisStartPos = 0;\n    eventCenter(document, 'mousemove', mousemove, false, 'off');\n    eventCenter(document, 'mouseup', mouseup, false, 'off');\n  }\n\n  return mousedown;\n}\n\n/* istanbul ignore next */\nfunction createTouchEvent(ctx) {\n  const parent = getRealParent(ctx);\n\n  function touchstart(e) {\n    e.stopImmediatePropagation();\n    e.preventDefault();\n\n    document.onselectstart = () => false;\n\n    ctx.axisStartPos =\n      e.touches[0][ctx.bar.client] -\n      ctx.$refs['inner'].getBoundingClientRect()[ctx.bar.posName];\n\n    // tell parent that the mouse has been down.\n    ctx.$emit('setBarClick', true);\n    eventCenter(document, 'touchmove', touchmove);\n    eventCenter(document, 'touchend', touchend);\n  }\n  function touchmove(e) {\n    if (!ctx.axisStartPos) {\n      return;\n    }\n    const delta =\n      e.touches[0][ctx.bar.client] -\n      ctx.$el.getBoundingClientRect()[ctx.bar.posName];\n    const percent = (delta - ctx.axisStartPos) / ctx.$el[ctx.bar.offset];\n    parent.scrollTo(\n      {\n        [ctx.bar.axis.toLowerCase()]:\n          parent.scrollPanelElm[ctx.bar.scrollSize] * percent\n      },\n      false\n    );\n  }\n  function touchend() {\n    ctx.$emit('setBarClick', false);\n    document.onselectstart = null;\n    parent.hideBar();\n    ctx.axisStartPos = 0;\n    eventCenter(document, 'touchmove', touchmove, false, 'off');\n    eventCenter(document, 'touchend', touchend, false, 'off');\n  }\n  return touchstart;\n}\n\n// Transform a common color int oa `rgbA` color\nfunction getRgbAColor(color, opacity) {\n  const id = color + '&' + opacity;\n  if (colorCache[id]) {\n    return colorCache[id];\n  }\n\n  const div = document.createElement('div');\n  div.style.background = color;\n  document.body.appendChild(div);\n  const computedColor = window.getComputedStyle(div).backgroundColor;\n  document.body.removeChild(div);\n\n  /* istanbul ignore if */\n  if (!rgbReg.test(computedColor)) {\n    return color;\n  }\n\n  return (colorCache[id] = `rgba(${\n    extractRgbColor.exec(computedColor)[1]\n  }, ${opacity})`);\n}\n\n/* istanbul ignore next */\nfunction handleClickTrack(e) {\n  const ctx = this;\n  const parent = getRealParent(this);\n  const { client, offset, posName, axis } = ctx.bar;\n  const inner = ctx.$refs['inner'];\n  const barOffset = inner[offset];\n  const percent =\n    (e[client] -\n      e.currentTarget.getBoundingClientRect()[posName] -\n      barOffset / 2) /\n    e.currentTarget[offset];\n\n  parent.scrollTo({\n    [axis.toLowerCase()]: percent * 100 + '%'\n  });\n}\n\nexport default {\n  name: 'bar',\n  props: {\n    ops: {\n      type: Object,\n      required: true\n    },\n    state: {\n      type: Object,\n      required: true\n    },\n    type: {\n      type: String,\n      required: true\n    }\n  },\n  computed: {\n    bar() {\n      return scrollMap[this.type];\n    }\n  },\n  render(h) {\n    const vm = this;\n    const railBackgroundColor = getRgbAColor(\n      vm.ops.rail.background,\n      vm.ops.rail.opacity\n    );\n    let style = {\n      [vm.bar.size]: vm.state.size,\n      background: vm.ops.bar.background,\n      opacity: vm.state.opacity,\n      transform: `translate${scrollMap[vm.type].axis}(${vm.state.posValue}%)`\n    };\n    const bar = {\n      style: style,\n      class: `__bar-is-${vm.type}`,\n      ref: 'inner',\n      on: {}\n    };\n\n    /* istanbul ignore if */\n    if (vm.ops.bar.hover) {\n      bar.on['mouseenter'] = () => {\n        vm.$el.style.background = vm.ops.hover;\n      };\n      bar.on['mouseleave'] = () => {\n        vm.$el.style.background = vm.ops.background;\n      };\n    }\n    /* istanbul ignore if */\n    if (isSupportTouch()) {\n      bar.on['touchstart'] = createTouchEvent(this);\n    } else {\n      bar.on['mousedown'] = createMouseEvent(this);\n    }\n\n    const rail = {\n      class: `__rail-is-${vm.type}`,\n      style: {\n        borderRadius: vm.ops.rail[vm.bar.opsSize],\n        background: railBackgroundColor,\n        [vm.bar.opsSize]: vm.ops.rail[vm.bar.opsSize],\n        [vm.ops.rail.pos]: '2px'\n      },\n      on: {\n        click(e) /* istanbul ignore next */ {\n          handleClickTrack.call(vm, e);\n        }\n      }\n    };\n\n    return (\n      <div {...rail}>\n        <div {...bar} />\n      </div>\n    );\n  }\n};\n\n/**\n * create bars\n *\n * @param {any} size\n * @param {any} type\n */\nexport function createBar(h, vm, type) {\n  const axis = type === 'vertical' ? 'Y' : 'X';\n  const barType = `${type.charAt(0)}Bar`;\n  const railType = `${type.charAt(0)}Rail`;\n\n  if (\n    !vm.bar[barType].state.size ||\n    !vm.mergedOptions.scrollPanel['scrolling' + axis] ||\n    vm.mode == 'pure-native' ||\n    (vm.refreshLoad && type !== 'vertical' && vm.mode === 'slide')\n  ) {\n    return null;\n  }\n\n  const barData = {\n    props: {\n      type: type,\n      ops: {\n        bar: vm.mergedOptions.bar[barType],\n        rail: vm.mergedOptions.rail[railType]\n      },\n      state: vm.bar[barType].state\n    },\n    on: {\n      setBarClick: vm.setBarClick\n    },\n    ref: `${type}Bar`\n  };\n\n  return <bar {...barData} />;\n}\n","// begin importing\nimport {\n  getGutter,\n  isSupportGivenStyle,\n  isIE,\n  insertChildrenIntoSlot,\n  getRealParent\n} from '../../util';\nimport { createContent } from './vuescroll-content';\n// vueScrollPanel\nexport default {\n  name: 'scrollPanel',\n  props: { ops: { type: Object, required: true } },\n  methods: {\n    // trigger scrollPanel options initialScrollX,\n    // initialScrollY\n    updateInitialScroll() {\n      let x = 0;\n      let y = 0;\n      const parent = getRealParent(this);\n      if (this.ops.initialScrollX) {\n        x = this.ops.initialScrollX;\n      }\n      if (this.ops.initialScrollY) {\n        y = this.ops.initialScrollY;\n      }\n      if (x || y) {\n        parent.scrollTo({ x, y });\n      }\n    }\n  },\n  mounted() {\n    setTimeout(() => {\n      if (!this._isDestroyed) {\n        this.updateInitialScroll();\n      }\n    }, 0);\n  },\n  render(h) {\n    // eslint-disable-line\n    let data = {\n      class: ['__panel']\n    };\n\n    const parent = getRealParent(this);\n\n    const _customPanel = parent.$slots['scroll-panel'];\n    if (_customPanel) {\n      return insertChildrenIntoSlot(h, _customPanel, this.$slots.default, data);\n    }\n\n    return <div {...data}>{[this.$slots.default]}</div>;\n  }\n};\n\n/**\n * create a scrollPanel\n *\n * @param {any} size\n * @param {any} vm\n * @returns\n */\nexport function createPanel(h, vm) {\n  // scrollPanel data start\n  const scrollPanelData = {\n    ref: 'scrollPanel',\n    style: {},\n    class: [],\n    nativeOn: {\n      scroll: vm.handleScroll\n    },\n    props: {\n      ops: vm.mergedOptions.scrollPanel\n    }\n  };\n  // set overflow only if the in native mode\n  if (vm.mode == 'native') {\n    scrollPanelData.class.push('__native');\n    // dynamic set overflow scroll\n    // feat: #11\n    if (vm.mergedOptions.scrollPanel.scrollingY) {\n      scrollPanelData.style['overflowY'] = vm.bar.vBar.state.size\n        ? 'scroll'\n        : '';\n    } else {\n      scrollPanelData.style['overflowY'] = 'hidden';\n    }\n    if (vm.mergedOptions.scrollPanel.scrollingX) {\n      scrollPanelData.style['overflowX'] = vm.bar.hBar.state.size\n        ? 'scroll'\n        : '';\n    } else {\n      scrollPanelData.style['overflowX'] = 'hidden';\n    }\n    let gutter = getGutter();\n    /* istanbul ignore if */\n    if (!gutter && vm.mergedOptions.vuescroll.mode != 'pure-native') {\n      scrollPanelData.class.push('__hidebar');\n    } else {\n      // hide system bar by use a negative value px\n      // gutter should be 0 when manually disable scrollingX #14\n      if (vm.bar.vBar.state.size && vm.mergedOptions.scrollPanel.scrollingY) {\n        scrollPanelData.style.marginRight = `-${gutter}px`;\n      }\n      if (vm.bar.hBar.state.size && vm.mergedOptions.scrollPanel.scrollingX) {\n        scrollPanelData.style.height = `calc(100% + ${gutter}px)`;\n      }\n    }\n    // clear legency styles of slide mode...\n    scrollPanelData.style.transformOrigin = '';\n    scrollPanelData.style.transform = '';\n  } else if (vm.mode == 'slide') {\n    scrollPanelData.class.push('__slide');\n    let width = isSupportGivenStyle('width', 'fit-content');\n    if (width) {\n      scrollPanelData.style['width'] = width;\n    } /* istanbul ignore next */ else {\n      /* \n       * Fallback to inline-block while doesn't support fit-content\n       */\n      scrollPanelData['display'] = 'inline-block';\n    }\n  } else if (vm.mode == 'pure-native') {\n    scrollPanelData.class.push('__pure-native');\n    if (vm.mergedOptions.scrollPanel.scrollingY) {\n      scrollPanelData.style['overflowY'] = 'auto';\n    } else {\n      scrollPanelData.style['overflowY'] = 'hidden';\n    }\n    if (vm.mergedOptions.scrollPanel.scrollingX) {\n      scrollPanelData.style['overflowX'] = 'auto';\n    } else {\n      scrollPanelData.style['overflowX'] = 'hidden';\n    }\n  }\n  return (\n    <scrollPanel {...scrollPanelData}>{createPanelChildren(vm, h)}</scrollPanel>\n  );\n}\n\nfunction createPanelChildren(vm, h) {\n  if (vm.mode == 'native') {\n    return [createContent(h, vm)];\n  } else if (vm.mode == 'slide') {\n    let renderChildren = [vm.$slots.default];\n\n    /**\n     *  Keep the children-rendered-order in case of the style crash\n     *  when push-load or pull-refresh is enable\n     */\n    let _customPanel = vm.$slots['scroll-panel'];\n    if (_customPanel) {\n      /* istanbul ignore if */\n      if (_customPanel.length > 1) {\n        renderChildren = _customPanel.concat(renderChildren);\n      } else {\n        _customPanel = _customPanel[0];\n        const ch = _customPanel.children;\n        if (Array.isArray(ch)) {\n          renderChildren = ch.concat(renderChildren);\n        }\n      }\n    }\n\n    // handle refresh\n    if (vm.mergedOptions.vuescroll.pullRefresh.enable) {\n      let refreshDom = null;\n      refreshDom = createTipDom(h, vm, 'refresh');\n      renderChildren.unshift(\n        <div class=\"__refresh\" ref=\"refreshDom\" key=\"refshDom\">\n          {[refreshDom, vm.pullRefreshTip]}\n        </div>\n      );\n    }\n\n    // handle load\n    if (vm.mergedOptions.vuescroll.pushLoad.enable) {\n      let loadDom = null;\n      loadDom = createTipDom(h, vm, 'load');\n      const enableLoad = vm.isEnableLoad();\n      renderChildren.push(\n        <div\n          ref=\"loadDom\"\n          key=\"loadDom\"\n          class={{ __load: true, '__load-disabled': !enableLoad }}\n        >\n          {[loadDom, vm.pushLoadTip]}\n        </div>\n      );\n    }\n    return renderChildren;\n  } else if (vm.mode == 'pure-native') {\n    return [vm.$slots.default];\n  }\n}\n\n// Create load or refresh tip dom of each stages\n\nfunction createTipDom(h, vm, type) {\n  const stage = vm.vuescroll.state[`${type}Stage`];\n  let dom = null;\n  /* istanbul ignore if */\n  if ((dom = vm.$slots[`${type}-${stage}`])) {\n    return dom[0];\n  }\n  switch (stage) {\n  case 'deactive':\n    dom = (\n      <svg\n        version=\"1.1\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n        x=\"0px\"\n        y=\"0px\"\n        viewBox=\"0 0 1000 1000\"\n        enable-background=\"new 0 0 1000 1000\"\n        xmlSpace=\"preserve\"\n      >\n        <metadata> Svg Vector Icons : http://www.sfont.cn </metadata>\n        <g>\n          <g transform=\"matrix(1 0 0 -1 0 1008)\">\n            <path d=\"M10,543l490,455l490-455L885,438L570,735.5V18H430v717.5L115,438L10,543z\" />\n          </g>\n        </g>\n      </svg>\n    );\n    break;\n  case 'start':\n    // IE and edge seem not supporting  tag - `animateTransform`\n    // Just return null.\n    /* istanbul ignore if */\n    if (isIE()) {\n      dom = null;\n      break;\n    }\n    dom = (\n      <svg\n        version=\"1.1\"\n        id=\"loader-1\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n        x=\"0px\"\n        y=\"0px\"\n        viewBox=\"0 0 50 50\"\n        style=\"enable-background:new 0 0 50 50;\"\n        xmlSpace=\"preserve\"\n      >\n        <path\n          fill=\"#000\"\n          d=\"M43.935,25.145c0-10.318-8.364-18.683-18.683-18.683c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615c8.072,0,14.615,6.543,14.615,14.615H43.935z\"\n        >\n          <animateTransform\n            attributeType=\"xml\"\n            attributeName=\"transform\"\n            type=\"rotate\"\n            from=\"0 25 25\"\n            to=\"360 25 25\"\n            dur=\"0.6s\"\n            repeatCount=\"indefinite\"\n          />\n        </path>\n      </svg>\n    );\n    break;\n  case 'active':\n    dom = (\n      <svg\n        version=\"1.1\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n        x=\"0px\"\n        y=\"0px\"\n        viewBox=\"0 0 1000 1000\"\n        enable-background=\"new 0 0 1000 1000\"\n        xmlSpace=\"preserve\"\n      >\n        <metadata> Svg Vector Icons : http://www.sfont.cn </metadata>\n        <g>\n          <g transform=\"matrix(1 0 0 -1 0 1008)\">\n            <path d=\"M500,18L10,473l105,105l315-297.5V998h140V280.5L885,578l105-105L500,18z\" />\n          </g>\n        </g>\n      </svg>\n    );\n    break;\n  }\n  return dom;\n}\n","import {\n  deepMerge,\n  isSupportGivenStyle,\n  insertChildrenIntoSlot\n} from '../../util';\n// ScrollContent, stateless, treat as a functional component\nexport default {\n  name: 'scrollContent',\n  functional: true,\n  props: {\n    ops: { type: Object },\n    state: {\n      type: Object,\n      default() {\n        return {};\n      }\n    }\n  },\n  render(h, { props, slots, parent }) {\n    let style = deepMerge(props.state.style, {});\n    style.position = 'relative';\n    let width = isSupportGivenStyle('width', 'fit-content');\n    if (width) {\n      style.width = width;\n    } /* istanbul ignore next */ else {\n      // fallback to inline block while\n      // doesn't support 'fit-content',\n      // this may cause some issues, but this\n      // can make `resize` event work...\n      style['display'] = 'inline-block';\n    }\n    style.boxSizing = 'border-box';\n    if (props.ops.padding) {\n      style[props.ops.paddPos] = props.ops.paddValue;\n    }\n\n    const propsData = {\n      style: style,\n      ref: 'scrollContent',\n      class: '__view'\n    };\n\n    const _customContent = parent.$slots['scroll-content'];\n    if (_customContent) {\n      return insertChildrenIntoSlot(\n        h,\n        _customContent,\n        slots().default,\n        propsData\n      );\n    }\n\n    return <div {...propsData}>{slots().default}</div>;\n  }\n};\n\n/**\n * create scroll content\n *\n * @param {any} size\n * @param {any} vm\n * @returns\n */\nexport function createContent(h, vm) {\n  const scrollContentData = {\n    props: {\n      ops: vm.mergedOptions.scrollContent\n    }\n  };\n  return (\n    <scrollContent {...scrollContentData}>{[vm.$slots.default]}</scrollContent>\n  );\n}\n","/* ------------------- Mix Start ---------------- */\n\n/**\n *  Mode mix\n */\nimport nativeMode from '../mixins/mode/native-mode';\nimport slideMode from '../mixins/mode/slide-mode';\n\n/**\n *  Lifecycle mix\n */\nimport hackLifecycle from '../mixins/hack-lifecycle';\n\n/**\n *  Init\n */\nimport init from '../mixins/init';\n\n/**\n *  Api\n */\nimport api from '../mixins/api';\n\n/**\n *  Computed\n */\nimport computed from '../mixins/computed';\n\n/**\n *  Event Hander\n */\nimport eventHelper from '../mixins/event-handler';\n\n/**\n *  Helper\n */\nimport helper from '../mixins/helper';\n\n/**\n *  Event Emitter\n */\nimport eventEmitter from '../mixins/event-emitter';\n\n/**\n *  Refresh Mechanism\n */\nimport refresh from '../mixins/refresh';\n\n/**\n *  Detect Resize Mechanism\n */\nimport resize from '../mixins/resize';\n\n/* ------------------- Mix End ---------------- */\n\n/**\n *  Components\n */\nimport bar, { createBar } from './child-components/vuescroll-bar';\nimport scrollContent from './child-components/vuescroll-content';\nimport scrollPanel, { createPanel } from './child-components/vuescroll-panel';\n\n/**\n *  Util\n */\nimport { isSupportTouch, insertChildrenIntoSlot } from '../util';\n\nconst vueScrollCore = {\n  name: 'vueScroll',\n  components: { bar, scrollContent, scrollPanel },\n  props: {\n    ops: { type: Object }\n  },\n  mixins: [\n    hackLifecycle,\n    api,\n    nativeMode,\n    slideMode,\n    computed,\n    eventEmitter,\n    eventHelper,\n    helper,\n    init,\n    refresh,\n    resize\n  ],\n  mounted() {\n    if (!this.renderError) {\n      this.initVariables();\n\n      this.initWatchOpsChange();\n\n      this.refreshInternalStatus();\n\n      this.$nextTick(() => {\n        if (!this._isDestroyed) {\n          // update again to ensure bar's size is correct.\n          this.updateBarStateAndEmitEvent();\n          // update scroller again since we get real dom.\n          if (this.mode == 'slide') {\n            this.updateScroller();\n          }\n          this.scrollToAnchor();\n        }\n      }, 0);\n    }\n  },\n  updated() {\n    this.vuescroll.updatedCbs.forEach(cb => {\n      cb.call(this);\n    });\n    // Clear\n    this.vuescroll.updatedCbs = [];\n  },\n  beforeDestroy() {\n    // remove registryed resize\n    if (this.destroyParentDomResize) {\n      this.destroyParentDomResize();\n      this.destroyParentDomResize = null;\n    }\n    if (this.destroyResize) {\n      this.destroyResize();\n      this.destroyResize = null;\n    }\n  },\n  data() {\n    return {\n      /**\n       * @description\n       * In state props of each components, we store the states of each\n       * components, and in mergedOptions props, we store the options\n       * that are megred from user-defined options to default options.\n       * @author wangyi7099\n       * @returns\n       */\n      vuescroll: {\n        state: {\n          isDragging: false,\n          isClickingBar: false,\n          pointerLeave: true,\n          internalScrollTop: 0,\n          internalScrollLeft: 0,\n          posX: null,\n          posY: null,\n          refreshStage: 'deactive',\n          loadStage: 'deactive',\n          height: '100%',\n          width: '100%',\n          scrollingTimes: 0\n        },\n        updatedCbs: []\n      },\n      bar: {\n        vBar: {\n          state: {\n            posValue: 0,\n            size: 0,\n            opacity: 0\n          }\n        },\n        hBar: {\n          state: {\n            posValue: 0,\n            size: 0,\n            opacity: 0\n          }\n        },\n        renderError: false\n      }\n    };\n  },\n  render(h) {\n    let vm = this;\n    if (vm.renderError) {\n      return <div>{[vm.$slots['default']]}</div>;\n    }\n    // vuescroll data\n    const vuescrollData = {\n      style: {\n        height: vm.vuescroll.state.height,\n        width: vm.vuescroll.state.width,\n        padding: 0\n      },\n      class: '__vuescroll'\n    };\n    if (!isSupportTouch()) {\n      vuescrollData.on = {\n        mouseenter() {\n          vm.vuescroll.state.pointerLeave = false;\n          vm.updateBarStateAndEmitEvent();\n        },\n        mouseleave() {\n          vm.vuescroll.state.pointerLeave = true;\n          vm.hideBar();\n        },\n        mousemove() /* istanbul ignore next */ {\n          vm.vuescroll.state.pointerLeave = false;\n          vm.updateBarStateAndEmitEvent();\n        }\n      };\n    } /* istanbul ignore next */ else {\n      vuescrollData.on = {\n        touchstart() {\n          vm.vuescroll.state.pointerLeave = false;\n          vm.updateBarStateAndEmitEvent();\n        },\n        touchend() {\n          vm.vuescroll.state.pointerLeave = true;\n          vm.hideBar();\n        },\n        touchmove() /* istanbul ignore next */ {\n          vm.vuescroll.state.pointerLeave = false;\n          vm.updateBarStateAndEmitEvent();\n        }\n      };\n    }\n\n    const _customContainer = this.$slots['scroll-container'];\n\n    const ch = [\n      createPanel(h, vm),\n      createBar(h, vm, 'vertical'),\n      createBar(h, vm, 'horizontal')\n    ];\n\n    if (_customContainer) {\n      return insertChildrenIntoSlot(h, _customContainer, ch, vuescrollData);\n    }\n\n    return <div {...vuescrollData}>{ch}</div>;\n  }\n};\n\nexport default vueScrollCore;\n","import {getPrefix} from '../../util';\n\n/* DOM-based rendering (Uses 3D when available, falls back on margin when transform not available) */\nexport function render(content, global, suffix, value) {\n  var x = null;\n  var y = null;\n\n  if (typeof content == 'string') {\n    y = content == 'vertical' ? (x = 0) || value : (x = value) && 0;\n  }\n\n  var vendorPrefix = getPrefix(global);\n\n  var helperElem = document.createElement('div');\n  var undef;\n\n  var perspectiveProperty = vendorPrefix + 'Perspective';\n  var transformProperty = 'transform'; //vendorPrefix + 'Transform';\n\n  if (helperElem.style[perspectiveProperty] !== undef) {\n    if (typeof content == 'string') {\n      return {\n        [transformProperty]:\n          'translate3d(' + x + suffix + ',' + y + suffix + ',0)'\n      };\n    }\n    return function(left, top, zoom) {\n      content.style[transformProperty] =\n        'translate3d(' +\n        -left +\n        suffix +\n        ',' +\n        -top +\n        suffix +\n        ',0) scale(' +\n        zoom +\n        ')';\n    };\n  } else if (helperElem.style[transformProperty] !== undef) {\n    if (typeof content == 'string') {\n      return {\n        [transformProperty]: 'translate(' + x + suffix + ',' + y + suffix + ')'\n      };\n    }\n    return function(left, top, zoom) {\n      content.style[transformProperty] =\n        'translate(' +\n        -left +\n        suffix +\n        ',' +\n        -top +\n        suffix +\n        ') scale(' +\n        zoom +\n        ')';\n    };\n  }\n}\n","export function listenContainer(\n  container,\n  scroller,\n  eventCallback,\n  zooming,\n  preventDefault\n) {\n  let destroy = null;\n  // for touch\n  function touchstart(e) {\n    // Don't react if initial down happens on a form element\n    if (\n      e.touches[0] &&\n      e.touches[0].target &&\n      e.touches[0].target.tagName.match(/input|textarea|select/i)\n    ) {\n      return;\n    }\n    eventCallback('mousedown');\n    scroller.doTouchStart(e.touches, e.timeStamp);\n    if (preventDefault) {\n      e.preventDefault();\n    }\n    // here , we want to manully prevent default, so we\n    // set passive to false\n    // see https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener\n    document.addEventListener('touchmove', touchmove, { passive: false });\n  }\n  function touchmove(e) {\n    eventCallback('mousemove');\n    scroller.doTouchMove(e.touches, e.timeStamp, e.scale);\n    e.preventDefault();\n  }\n  function touchend(e) {\n    eventCallback('mouseup');\n    scroller.doTouchEnd(e.timeStamp);\n    document.removeEventListener('touchmove', touchmove);\n  }\n  function touchcancel(e) {\n    scroller.doTouchEnd(e.timeStamp);\n  }\n\n  // for mouse\n  function mousedownEvent(e) {\n    if (e.target.tagName.match(/input|textarea|select/i)) {\n      return;\n    }\n    eventCallback('mousedown');\n    scroller.doTouchStart(\n      [\n        {\n          pageX: e.pageX,\n          pageY: e.pageY\n        }\n      ],\n      e.timeStamp\n    );\n\n    if (preventDefault) {\n      e.preventDefault();\n    }\n\n    mousedown = true;\n  }\n  function mousemove(e) {\n    if (!mousedown) {\n      return;\n    }\n    eventCallback('mousemove');\n    scroller.doTouchMove(\n      [\n        {\n          pageX: e.pageX,\n          pageY: e.pageY\n        }\n      ],\n      e.timeStamp\n    );\n\n    mousedown = true;\n  }\n  function mouseup(e) {\n    if (!mousedown) {\n      return;\n    }\n    eventCallback('mouseup');\n    scroller.doTouchEnd(e.timeStamp);\n\n    mousedown = false;\n  }\n  function zoomHandle(e) {\n    scroller.doMouseZoom(\n      e.detail ? e.detail * -120 : e.wheelDelta,\n      e.timeStamp,\n      e.pageX,\n      e.pageY\n    );\n  }\n  if ('ontouchstart' in window) {\n    container.addEventListener('touchstart', touchstart, false);\n\n    document.addEventListener('touchend', touchend, false);\n\n    document.addEventListener('touchcancel', touchcancel, false);\n\n    destroy = function() {\n      container.removeEventListener('touchstart', touchstart, false);\n\n      document.removeEventListener('touchend', touchend, false);\n\n      document.removeEventListener('touchcancel', touchcancel, false);\n    };\n  } else {\n    var mousedown = false;\n\n    container.addEventListener('mousedown', mousedownEvent, false);\n\n    document.addEventListener('mousemove', mousemove, false);\n\n    document.addEventListener('mouseup', mouseup, false);\n    if (zooming) {\n      container.addEventListener(\n        navigator.userAgent.indexOf('Firefox') > -1\n          ? 'DOMMouseScroll'\n          : 'mousewheel',\n        zoomHandle,\n        false\n      );\n    }\n    // container.addEventListener(navigator.userAgent.indexOf(\"Firefox\") > -1 ? \"DOMMouseScroll\" :  \"mousewheel\", function(e) {\n    //     scroller.doMouseZoom(e.detail ? (e.detail * -120) : e.wheelDelta, e.timeStamp, e.pageX, e.pageY);\n    // }, false);\n    destroy = function() {\n      container.removeEventListener('mousedown', mousedownEvent, false);\n      document.removeEventListener('mousemove', mousemove, false);\n      document.removeEventListener('mouseup', mouseup, false);\n      container.removeEventListener(\n        navigator.userAgent.indexOf('Firefox') > -1\n          ? 'DOMMouseScroll'\n          : 'mousewheel',\n        zoomHandle,\n        false\n      );\n    };\n  }\n  // handle __publish event\n  scroller.onScroll = () => {\n    eventCallback('onscroll');\n  };\n  return destroy;\n}\n","export default {\n  computed: {\n    scrollPanelElm() {\n      return this.$refs['scrollPanel']._isVue\n        ? this.$refs['scrollPanel'].$el\n        : this.$refs['scrollPanel'];\n    },\n    scrollContentElm() {\n      return this.$refs['scrollContent']._isVue\n        ? this.$refs['scrollContent'].$el\n        : this.$refs['scrollContent'];\n    },\n    mode() {\n      return this.mergedOptions.vuescroll.mode;\n    },\n    pullRefreshTip() {\n      return this.mergedOptions.vuescroll.pullRefresh.tips[\n        this.vuescroll.state.refreshStage\n      ];\n    },\n    pushLoadTip() {\n      return this.mergedOptions.vuescroll.pushLoad.tips[\n        this.vuescroll.state.loadStage\n      ];\n    },\n    refreshLoad() {\n      return (\n        this.mergedOptions.vuescroll.pullRefresh.enable ||\n        this.mergedOptions.vuescroll.pushLoad.enable\n      );\n    }\n  }\n};\n","export default {\n  methods: {\n    updateBarStateAndEmitEvent(eventType, nativeEvent = null) {\n      if (this.mode == 'native' || this.mode == 'pure-native') {\n        this.updateNativeModeBarState();\n      } else if (this.mode == 'slide') {\n        if (!this.scroller) {\n          return;\n        }\n        this.updateSlideModeBarState();\n      }\n      if (eventType) {\n        this.emitEvent(eventType, nativeEvent);\n      }\n      if (this.mergedOptions.bar.onlyShowBarOnScroll) {\n        if (\n          eventType == 'handle-scroll' ||\n          eventType == 'handle-resize' ||\n          eventType == 'refresh-status' ||\n          eventType == 'window-resize' ||\n          eventType == 'options-change'\n        ) {\n          this.showAndDefferedHideBar(true);\n        }\n      } else {\n        this.showAndDefferedHideBar();\n      }\n    },\n    /**\n     *  emit user registry event\n     */\n    emitEvent(eventType, nativeEvent = null) {\n      let {\n        scrollHeight,\n        scrollWidth,\n        clientHeight,\n        clientWidth,\n        scrollTop,\n        scrollLeft\n      } = this.scrollPanelElm;\n      const vertical = {\n        type: 'vertical'\n      };\n      const horizontal = {\n        type: 'horizontal'\n      };\n      if (this.mode == 'slide') {\n        scrollHeight = this.scroller.__contentHeight;\n        scrollWidth = this.scroller.__contentWidth;\n        scrollTop = this.scroller.__scrollTop;\n        scrollLeft = this.scroller.__scrollLeft;\n        clientHeight = this.$el.clientHeight;\n        clientWidth = this.$el.clientWidth;\n      }\n      vertical['process'] = Math.min(\n        scrollTop / (scrollHeight - clientHeight),\n        1\n      );\n      horizontal['process'] = Math.min(\n        scrollLeft / (scrollWidth - clientWidth),\n        1\n      );\n      vertical['barSize'] = this.bar.vBar.state.size;\n      horizontal['barSize'] = this.bar.hBar.state.size;\n      vertical['scrollTop'] = scrollTop;\n      horizontal['scrollLeft'] = scrollLeft;\n      vertical['directionY'] = this.vuescroll.state.posY;\n      horizontal['directionX'] = this.vuescroll.state.posX;\n      this.$emit(eventType, vertical, horizontal, nativeEvent);\n    }\n  }\n};\n","export default {\n  methods: {\n    handleScroll(nativeEvent) {\n      this.recordCurrentPos();\n      this.updateBarStateAndEmitEvent('handle-scroll', nativeEvent);\n    },\n    scrollingComplete() {\n      this.vuescroll.state.scrollingTimes++;\n      this.updateBarStateAndEmitEvent('handle-scroll-complete');\n    },\n    setBarClick(val) {\n      /* istanbul ignore next */\n      this.vuescroll.state.isClickingBar = val;\n    }\n  }\n};\n","function findValuesByMode(mode, vm) {\n  let axis = {};\n  switch (mode) {\n  case 'native':\n  case 'pure-native':\n    axis = {\n      x: vm.scrollPanelElm.scrollLeft,\n      y: vm.scrollPanelElm.scrollTop\n    };\n    break;\n  case 'slide':\n    axis = { x: vm.scroller.__scrollLeft, y: vm.scroller.__scrollTop };\n    break;\n  }\n  return axis;\n}\n\nexport default {\n  methods: {\n    isEnableLoad() {\n      // Enable load only when clientHeight <= scrollHeight\n      if (!this._isMounted) return false;\n      const panelElm = this.scrollPanelElm;\n      const containerElm = this.$el;\n\n      /* istanbul ignore if */\n      if (!this.mergedOptions.vuescroll.pushLoad.enable) {\n        return false;\n      }\n      let loadDom = null;\n      if (this.$refs['loadDom']) {\n        loadDom = this.$refs['loadDom'].elm || this.$refs['loadDom'];\n      }\n      const loadHeight = (loadDom && loadDom.offsetHeight) || 0;\n      /* istanbul ignore if */\n      if (panelElm.scrollHeight - loadHeight <= containerElm.clientHeight) {\n        return false;\n      }\n      return true;\n    },\n    showAndDefferedHideBar(forceHideBar) {\n      this.showBar();\n      if (this.timeoutId) {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = 0;\n      }\n      this.timeoutId = setTimeout(() => {\n        this.timeoutId = 0;\n        this.hideBar(forceHideBar);\n      }, this.mergedOptions.bar.showDelay);\n    },\n    showBar() {\n      this.bar.vBar.state.opacity = this.mergedOptions.bar.vBar.opacity;\n      this.bar.hBar.state.opacity = this.mergedOptions.bar.hBar.opacity;\n    },\n    hideBar(forceHideBar) {\n      // when in non-native mode dragging content\n      // in slide mode, just return\n      /* istanbul ignore next */\n      if (this.vuescroll.state.isDragging) {\n        return;\n      }\n\n      if (forceHideBar && !this.mergedOptions.bar.hBar.keepShow) {\n        this.bar.hBar.state.opacity = 0;\n      }\n      if (forceHideBar && !this.mergedOptions.bar.vBar.keepShow) {\n        this.bar.vBar.state.opacity = 0;\n      }\n      // add isClickingBar condition\n      // to prevent from hiding bar while dragging the bar\n      if (\n        !this.mergedOptions.bar.vBar.keepShow &&\n        !this.vuescroll.state.isClickingBar &&\n        this.vuescroll.state.pointerLeave\n      ) {\n        this.bar.vBar.state.opacity = 0;\n      }\n      if (\n        !this.mergedOptions.bar.hBar.keepShow &&\n        !this.vuescroll.state.isClickingBar &&\n        this.vuescroll.state.pointerLeave\n      ) {\n        this.bar.hBar.state.opacity = 0;\n      }\n    },\n    recordCurrentPos() {\n      let mode = this.mode;\n      if (this.mode !== this.lastMode) {\n        mode = this.lastMode;\n        this.lastMode = this.mode;\n      }\n      const state = this.vuescroll.state;\n      let axis = findValuesByMode(mode, this);\n      const oldX = state.internalScrollLeft;\n      const oldY = state.internalScrollTop;\n      state.posX =\n        oldX - axis.x > 0 ? 'right' : oldX - axis.x < 0 ? 'left' : null;\n      state.posY = oldY - axis.y > 0 ? 'up' : oldY - axis.y < 0 ? 'down' : null;\n      state.internalScrollLeft = axis.x;\n      state.internalScrollTop = axis.y;\n    },\n    useNumbericSize() {\n      const parentElm = this.$el.parentNode;\n      const { position } = parentElm.style;\n      if (!position || position == 'static') {\n        this.$el.parentNode.style.position = 'relative';\n      }\n      this.vuescroll.state.height = parentElm.offsetHeight + 'px';\n      this.vuescroll.state.width = parentElm.offsetWidth + 'px';\n    },\n    usePercentSize() {\n      this.vuescroll.state.height = '100%';\n      this.vuescroll.state.width = '100%';\n    },\n    // set its size to be equal to its parentNode\n    setVsSize() {\n      if (this.mergedOptions.vuescroll.sizeStrategy == 'number') {\n        this.useNumbericSize();\n        this.registryParentResize();\n      } else if (this.mergedOptions.vuescroll.sizeStrategy == 'percent') {\n        if (this.destroyParentDomResize) {\n          this.destroyParentDomResize();\n          this.destroyParentDomResize = null;\n        }\n        this.usePercentSize();\n      }\n    }\n  }\n};\n","import { smallChangeArray } from '../shared/constants';\nimport { isChildInParent } from '../util';\n\nexport default {\n  methods: {\n    initWatchOpsChange() {\n      const watchOpts = {\n        deep: true,\n        sync: true\n      };\n      this.$watch(\n        'mergedOptions',\n        () => {\n          // record current position\n          this.recordCurrentPos();\n          setTimeout(() => {\n            if (this.isSmallChangeThisTick == true) {\n              this.isSmallChangeThisTick = false;\n              this.updateBarStateAndEmitEvent('options-change');\n              return;\n            }\n            this.refreshInternalStatus();\n          }, 0);\n        },\n        watchOpts\n      );\n\n      smallChangeArray.forEach(opts => {\n        this.$watch(\n          opts,\n          () => {\n            // when small changes changed,\n            // we need not to updateMode or registryResize\n            this.isSmallChangeThisTick = true;\n          },\n          watchOpts\n        );\n      });\n    },\n    // scrollTo hash-anchor while mounted\n    scrollToAnchor() /* istanbul ignore next */ {\n      const validateHashSelector = function(hash) {\n        return /^#[a-zA-Z_]\\d*$/.test(hash);\n      };\n      let hash = window.location.hash;\n      if (\n        !hash ||\n        ((hash = hash.slice(hash.lastIndexOf('#'))) &&\n          !validateHashSelector(hash))\n      ) {\n        return;\n      }\n      const elm = document.querySelector(hash);\n      if (\n        !isChildInParent(elm, this.$el) ||\n        this.mergedOptions.scrollPanel.initialScrollY ||\n        this.mergedOptions.scrollPanel.initialScrollX\n      ) {\n        return;\n      }\n      this.scrollIntoView(elm);\n    },\n    initVariables() {\n      this.lastMode = this.mode;\n      this.$el._isVuescroll = true;\n      this.clearScrollingTimes();\n    }\n  }\n};\n","export default {\n  methods: {\n    updateMode() {\n      const x = this.vuescroll.state.internalScrollLeft;\n      const y = this.vuescroll.state.internalScrollTop;\n      if (this.destroyScroller) {\n        this.scroller.stop();\n        this.destroyScroller();\n        this.destroyScroller = null;\n      }\n      if (this.mode == 'slide') {\n        this.destroyScroller = this.registryScroller();\n      } else if (this.mode == 'native' || this.mode == 'pure-native') {\n        // remove the legacy transform style attribute\n        this.scrollPanelElm.style.transform = '';\n        this.scrollPanelElm.style.transformOrigin = '';\n      }\n      // keep the last-mode's position.\n      this.scrollTo({ x, y }, false, true /* force */);\n    },\n    refreshInternalStatus() {\n      // 1.set vuescroll height or width according to\n      // sizeStrategy\n      this.setVsSize();\n      // 2. registry resize event\n      this.registryResize();\n      // 3. registry scroller if mode is 'slide'\n      // or remove 'transform origin' is the mode is not `slide`\n      this.updateMode();\n      // 4. update scrollbar's height/width\n      this.updateBarStateAndEmitEvent('refresh-status');\n    }\n  }\n};\n","import { listenResize } from '../third-party/resize-detector';\n\nexport default {\n  methods: {\n    registryResize() {\n      /* istanbul ignore next */\n      if (this.destroyResize) {\n        // when toggling the mode\n        // we should clean the flag-object.\n        this.destroyResize();\n      }\n      let contentElm = null;\n      if (this.mode == 'slide' || this.mode == 'pure-native') {\n        contentElm = this.scrollPanelElm;\n      } else if (this.mode == 'native') {\n        // scrollContent maybe a component or a pure-dom\n        contentElm = this.scrollContentElm;\n      }\n      const handleWindowResize = function() /* istanbul ignore next */ {\n        this.updateBarStateAndEmitEvent('window-resize');\n        if (this.mode == 'slide') {\n          this.vuescroll.updatedCbs.push(this.updateScroller);\n          this.$forceUpdate();\n        }\n      };\n      const handleDomResize = () => {\n        let currentSize = {};\n        if (this.mode == 'slide') {\n          currentSize['width'] = this.scroller.__contentWidth;\n          currentSize['height'] = this.scroller.__contentHeight;\n          this.updateBarStateAndEmitEvent('handle-resize', currentSize);\n          // update scroller should after rendering\n          this.vuescroll.updatedCbs.push(this.updateScroller);\n          this.$forceUpdate();\n        } else if (this.mode == 'native' || this.mode == 'pure-native') {\n          currentSize['width'] = this.scrollPanelElm.scrollWidth;\n          currentSize['height'] = this.scrollPanelElm.scrollHeight;\n          this.updateBarStateAndEmitEvent('handle-resize', currentSize);\n        }\n      };\n      window.addEventListener('resize', handleWindowResize.bind(this), false);\n      const destroyDomResize = listenResize(contentElm, handleDomResize);\n      const destroyWindowResize = () => {\n        window.removeEventListener('resize', handleWindowResize, false);\n      };\n\n      this.destroyResize = () => {\n        destroyWindowResize();\n        destroyDomResize();\n      };\n    },\n    registryParentResize() {\n      this.destroyParentDomResize = listenResize(\n        this.$el.parentNode,\n        this.useNumbericSize\n      );\n    }\n  }\n};\n","import Vue from 'vue';\nimport vuescroll from './components/vuescroll';\nimport GCF from './shared/global-config';\nimport { deepMerge } from './util';\nimport { refreshAll } from './mixins/api';\n\nimport './style/vuescroll.scss';\n\nconst Vuescroll = {\n  install(Vue) {\n    // registry vuescroll\n    Vue.component(vuescroll.name, vuescroll);\n    Vue.prototype.$vuescrollConfig = deepMerge(GCF, {});\n  },\n  version: '__version__',\n  refreshAll\n};\n\n/* istanbul ignore if */\nif (typeof window !== 'undefined' && window.Vue) {\n  Vue.use(Vuescroll);\n}\n\nexport default Vuescroll;\n"],"names":["deepCopy","source","target","key","_typeof","deepMerge","from","to","defineReactive","souceKey","getter","defineProperty","scrollBarWidth","eventCenter","dom","eventName","hander","capture","addEventListener","removeEventListener","error","msg","warn","isChildInParent","child","parent","flag","parentNode","nodeType","_isVuescroll","pxValueReg","extractNumberFromPx","value","_return","exec","isSupportTouch","window","getPrefix","global","engine","docStyle","document","documentElement","style","opera","Object","prototype","toString","call","navigator","cpuClass","isSupportGivenStyle","property","compatibleValue","testElm","createElement","isIE","agent","userAgent","toLowerCase","indexOf","insertChildrenIntoSlot","h","parentVnode","childVNode","data","isComponent","componentOptions","tag","_data","nativeOn","on","props","propsData","getRealParent","ctx","$parent","_isVuescrollRoot","scrollPanel","this","scrollPanelElm","vuescroll","$el","isPercent","mergedOptions","sizeStrategy","clientWidth","state","width","clientHeight","height","heightPercentage","scrollHeight","widthPercentage","scrollWidth","bar","vBar","posValue","scrollTop","hBar","scrollLeft","size","createEasingFunction","easing","easingPattern","time","pattern","Date","now","running","counter","core","effect","Animate","requestFrame","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","isNative","test","callback","root","requests","rafHandle","intervalHandle","lastActive","callbackHandle","setInterval","currentRequests","hasOwnProperty","id","cleared","stepCallback","verifyCallback","completedCallback","duration","easingMethod","start","lastFrame","percent","dropCounter","body","newRunning","usedId","step","virtual","render","droppedFrames","Math","round","j","min","modes","NOOP","smallChangeArray","animatingMethod","noAnimatingMethod","Scroller","options","__callback","animatingEasing","noAnimatingEasing","members","contentWidth","contentHeight","animate","noScroll","self","__clientWidth","__clientHeight","__contentWidth","__contentHeight","__computeScrollMax","scrollTo","__scrollLeft","__scrollTop","left","top","__clientLeft","__clientTop","__snapWidth","__snapHeight","activateCallback","deactivateCallback","startCallback","beforeDeactivateCallback","__refreshHeight","__refreshActivate","__refreshBeforeDeactivate","__refreshDeactivate","__refreshStart","__loadHeight","__loadActivate","__loadBeforeDeactivate","__loadDeactivate","__loadStart","type","wasDecelerating","__isDecelerating","stop","__publish","__zoomLevel","__refreshActive","__maxScrollTop","__loadActive","__maxScrollLeft","level","originLeft","originTop","zooming","Error","__zoomComplete","oldLevel","max","maxZoom","minZoom","factor","zoomTo","zoom","force","scrollingX","paging","snapping","scrollingY","__isTracking","startLeft","__isAnimating","__scheduledLeft","startTop","__scheduledTop","__computePage","__currentPageX","__currentPageY","x","y","isNaN","wheelDelta","timeStamp","pageX","pageY","change","touches","length","valueOf","currentTouchLeft","currentTouchTop","__interruptedAnimation","isSingleTouch","abs","__initialTouchLeft","__initialTouchTop","__zoomLevelStart","__lastTouchLeft","__lastTouchTop","__lastTouchMove","__lastScale","__enableScrollX","__enableScrollY","__didDecelerationComplete","__isDragging","__isSingleTouch","__positions","scale","positions","moveX","moveY","currentTouchLeftRel","currentTouchTopRel","speedMultiplier","maxScrollLeft","bouncing","maxScrollTop","splice","push","minimumTrackingForScroll","locking","distanceX","distanceY","animating","endPos","startPos","i","timeOffset","movedLeft","movedTop","__decelerationVelocityX","__decelerationVelocityY","minVelocityToStartDeceleration","__startDeceleration","__scrollComplete","__disable","wasAnimating","__scheduledZoom","oldLeft","oldTop","oldZoom","diffLeft","diffTop","diffZoom","onScroll","renderedFramesPerSecond","animationId","wasFinished","animationDuration","zoomLevel","__totalXPage","ceil","__totalYPage","scrollingComplete","__minDecelerationScrollLeft","floor","__minDecelerationScrollTop","__maxDecelerationScrollLeft","__maxDecelerationScrollTop","minVelocityToKeepDecelerating","__stepThroughDeceleration","shouldContinue","scrollLeftFixed","scrollTopFixed","scrollOutsideX","scrollOutsideY","penetrationDeceleration","penetrationAcceleration","undefined","vm","$options","name","_gfc","$vuescrollConfig","ops","GCF","keys","forEach","scrollContent","rail","vRail","pos","renderError","shouldStopRender","mode","enable","pullRefresh","pushLoad","initialScrollY","initialScrollX","String","match","validateOptions","vsInstances","getNumericValue","distance","number","listenResize","element","hasResized","OBJECT_STYLE","objWrap","cssText","object","tabIndex","onload","contentDocument","defaultView","isResizeElm","appendChild","removeChild","injectObject","colorCache","rgbReg","extractRgbColor","createBar","axis","barType","charAt","railType","refreshLoad","setBarClick","createPanel","scrollPanelData","handleScroll","class","gutter","Vue","$isServer","outer","visibility","position","widthNoScroll","offsetWidth","overflow","inner","widthWithScroll","getGutter","marginRight","transformOrigin","transform","$slots","default","renderChildren","_customPanel","concat","ch","children","Array","isArray","refreshDom","createTipDom","unshift","ref","pullRefreshTip","loadDom","enableLoad","isEnableLoad","__load","__load-disabled","pushLoadTip","createPanelChildren","stage","d","vueScrollCore","scrollMap","railBackgroundColor","color","opacity","div","background","computedColor","getComputedStyle","backgroundColor","getRgbAColor","hover","touchmove","e","axisStartPos","client","getBoundingClientRect","posName","offset","scrollSize","touchend","$emit","onselectstart","hideBar","stopImmediatePropagation","preventDefault","$refs","createTouchEvent","mousemove","mouseup","createMouseEvent","opsSize","barOffset","currentTarget","slots","boxSizing","padding","paddPos","paddValue","_customContent","required","_this","_isDestroyed","updateInitialScroll","hackLifecycle","_uid","internalScrollLeft","internalScrollTop","internalScrollTo","dx","dy","scroller","zoomBy","getCurrentPage","dest","goToPage","isRefresh","isLoad","triggerRefreshOrLoad","parentLeft","parentTop","parentHeight","parentWidth","scrollContentElm","domFragment","item","destX","destY","bind","elm","deltaX","deltaY","speed","startLocationY","startLocationX","positionX","positionY","percentage","parentElm","querySelector","diffX","diffY","scrollBy","refreshInternalStatus","scrollingTimes","nativeMode","updateDimesion","registryRefreshLoad","refreshHeight","offsetHeight","marginTop","setDimensions","registryEvent","content","suffix","vendorPrefix","helperElem","perspectiveProperty","transformProperty","undef","setSnapSize","rect","setPosition","clientLeft","clientTop","cb","container","eventCallback","destroy","touchstart","tagName","doTouchStart","passive","doTouchMove","doTouchEnd","touchcancel","mousedownEvent","mousedown","zoomHandle","doMouseZoom","detail","listenContainer","eventType","isDragging","updateScroller","outerLeft","outerTop","stageName","tipDom","listeners","domName","activateFunc","activatePullToRefresh","activatePushToLoad","cbs","$listeners","finishRefreshOrLoad","done","_isVue","tips","refreshStage","loadStage","nativeEvent","updateNativeModeBarState","updateSlideModeBarState","emitEvent","onlyShowBarOnScroll","showAndDefferedHideBar","vertical","horizontal","posY","posX","recordCurrentPos","updateBarStateAndEmitEvent","val","isClickingBar","_isMounted","panelElm","containerElm","loadHeight","forceHideBar","showBar","timeoutId","setTimeout","showDelay","keepShow","pointerLeave","lastMode","findValuesByMode","oldX","oldY","useNumbericSize","registryParentResize","destroyParentDomResize","usePercentSize","watchOpts","$watch","isSmallChangeThisTick","opts","hash","location","slice","lastIndexOf","scrollIntoView","clearScrollingTimes","destroyScroller","registryScroller","setVsSize","registryResize","updateMode","destroyResize","contentElm","handleWindowResize","updatedCbs","$forceUpdate","destroyDomResize","currentSize","initVariables","initWatchOpsChange","$nextTick","scrollToAnchor","vuescrollData","_customContainer","Vuescroll","component","vs","refresh","use"],"mappings":"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"}