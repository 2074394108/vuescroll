{"version":3,"file":"vuescroll.min.js","sources":["../src/util/index.js","../src/third-party/resize-detector/index.js","../src/shared/constants.js","../src/shared/global-config.js","../src/mixins/hack-lifecycle.js","../src/third-party/easingPattern/index.js","../src/third-party/scroller/animate.js","../src/third-party/scroller/requestAnimationFrame.js","../src/mixins/api.js","../src/mixins/mode/native-mode.js","../src/third-party/scroller/index.js","../src/mixins/mode/slide-mode.js","../src/shared/scroll-map.js","../src/components/child-components/vuescroll-bar.js","../src/components/child-components/vuescroll-panel.js","../src/components/child-components/vuescroll-content.js","../src/components/vuescroll.js","../src/third-party/scroller/render.js","../src/third-party/scroller/listener.js","../src/index.js"],"sourcesContent":["import Vue from 'vue';\r\n\r\nexport function deepCopy(source, target) {\r\n  target = (typeof target === 'object' && target) || {};\r\n  for (var key in source) {\r\n    target[key] =\r\n      typeof source[key] === 'object'\r\n        ? deepCopy(source[key], (target[key] = {}))\r\n        : source[key];\r\n  }\r\n  return target;\r\n}\r\n\r\nexport function deepMerge(from, to) {\r\n  to = to || {};\r\n  for (var key in from) {\r\n    if (typeof from[key] === 'object') {\r\n      if (typeof to[key] === 'undefined') {\r\n        to[key] = {};\r\n        deepCopy(from[key], to[key]);\r\n      } else {\r\n        deepMerge(from[key], to[key]);\r\n      }\r\n    } else {\r\n      if (typeof to[key] === 'undefined') to[key] = from[key];\r\n    }\r\n  }\r\n  return to;\r\n}\r\n\r\nexport function defineReactive(target, key, source, souceKey) {\r\n  let getter = null;\r\n  /* istanbul ignore if */\r\n  if (!source[key] && typeof source !== 'function') {\r\n    return;\r\n  }\r\n  souceKey = souceKey || key;\r\n  if (typeof source === 'function') {\r\n    getter = source;\r\n  }\r\n  Object.defineProperty(target, key, {\r\n    get:\r\n      getter ||\r\n      function() {\r\n        return source[souceKey];\r\n      },\r\n    configurable: true\r\n  });\r\n}\r\n\r\nlet scrollBarWidth;\r\n\r\nexport function getGutter() {\r\n  /* istanbul ignore next */\r\n  if (Vue.prototype.$isServer) return 0;\r\n  if (scrollBarWidth !== undefined) return scrollBarWidth;\r\n  const outer = document.createElement('div');\r\n  outer.style.visibility = 'hidden';\r\n  outer.style.width = '100px';\r\n  outer.style.position = 'absolute';\r\n  outer.style.top = '-9999px';\r\n  document.body.appendChild(outer);\r\n\r\n  const widthNoScroll = outer.offsetWidth;\r\n  outer.style.overflow = 'scroll';\r\n  const inner = document.createElement('div');\r\n  inner.style.width = '100%';\r\n  outer.appendChild(inner);\r\n\r\n  const widthWithScroll = inner.offsetWidth;\r\n  outer.parentNode.removeChild(outer);\r\n  scrollBarWidth = widthNoScroll - widthWithScroll;\r\n  return scrollBarWidth;\r\n}\r\n\r\nexport function eventCenter(\r\n  dom,\r\n  eventName,\r\n  hander,\r\n  capture = false,\r\n  type = 'on'\r\n) {\r\n  type == 'on'\r\n    ? dom.addEventListener(eventName, hander, capture)\r\n    : dom.removeEventListener(eventName, hander, capture);\r\n}\r\n\r\nexport const error = msg => {\r\n  console.error(`[vuescroll] ${msg}`);\r\n};\r\nexport const warn = msg => {\r\n  console.warn(`[vuescroll] ${msg}`);\r\n};\r\n\r\nexport function isChildInParent(child, parent) {\r\n  let flag = false;\r\n  if (!child || !parent) {\r\n    return flag;\r\n  }\r\n  while (\r\n    child.parentNode !== parent &&\r\n    child.parentNode.nodeType !== 9 &&\r\n    !child.parentNode._isVuescroll\r\n  ) {\r\n    child = child.parentNode;\r\n  }\r\n  if (child.parentNode == parent) {\r\n    flag = true;\r\n  }\r\n  return flag;\r\n}\r\n\r\nconst pxValueReg = /(.*?)px/;\r\nexport function extractNumberFromPx(value) {\r\n  const _return = pxValueReg.exec(value);\r\n  return _return && _return[1];\r\n}\r\n\r\nexport function isSupportTouch() {\r\n  return 'ontouchstart' in window;\r\n}\r\n\r\nexport function getPrefix(global) {\r\n  var docStyle = document.documentElement.style;\r\n  var engine;\r\n  /* istanbul ignore if */\r\n  if (\r\n    global.opera &&\r\n    Object.prototype.toString.call(opera) === '[object Opera]'\r\n  ) {\r\n    engine = 'presto';\r\n  } /* istanbul ignore next */ else if ('MozAppearance' in docStyle) {\r\n    engine = 'gecko';\r\n  } else if ('WebkitAppearance' in docStyle) {\r\n    engine = 'webkit';\r\n  } /* istanbul ignore next */ else if (\r\n    typeof navigator.cpuClass === 'string'\r\n  ) {\r\n    engine = 'trident';\r\n  }\r\n  var vendorPrefix = {\r\n    trident: 'ms',\r\n    gecko: 'moz',\r\n    webkit: 'webkit',\r\n    presto: 'O'\r\n  }[engine];\r\n  return vendorPrefix;\r\n}\r\n\r\nexport function isSupportGivenStyle(property, value) {\r\n  const compatibleValue = `-${getPrefix(window)}-${value}`;\r\n  const testElm = document.createElement('div');\r\n  testElm.style[property] = compatibleValue;\r\n  if (testElm.style[property] == compatibleValue) {\r\n    return compatibleValue;\r\n  }\r\n  /* istanbul ignore next */\r\n  return false;\r\n}\r\n\r\nexport function isIE() /* istanbul ignore next */ {\r\n  var agent = navigator.userAgent.toLowerCase();\r\n  return (\r\n    agent.indexOf('msie') !== -1 ||\r\n    agent.indexOf('trident') !== -1 ||\r\n    agent.indexOf(' edge/') !== -1\r\n  );\r\n}\r\n\r\nexport function insertChildrenIntoSlot(h, parentVnode, childVNode, data) {\r\n  parentVnode = parentVnode[0] ? parentVnode[0] : parentVnode;\r\n  const tag =\r\n    (parentVnode.componentOptions && parentVnode.componentOptions.tag) ||\r\n    parentVnode.tag;\r\n  // if (!Array.isArray(childVNode)) {\r\n  //   childVNode = [childVNode];\r\n  // }\r\n\r\n  // // Remove null node\r\n  // for (let index = 0; index < childVNode.length; index++) {\r\n  //   const element = childVNode[index];\r\n  //   if (!element) {\r\n  //     childVNode.splice(index, 1);\r\n  //     index--;\r\n  //   }\r\n  // }\r\n  const _data = parentVnode.componentOptions || parentVnode.data || {};\r\n\r\n  // If component, use `nativeOn` intead.\r\n  if (parentVnode.componentOptions) {\r\n    data.nativeOn = data.on;\r\n    _data.props = _data.propsData;\r\n\r\n    delete data.on;\r\n    delete data.propsData;\r\n  }\r\n\r\n  return h(\r\n    tag,\r\n    {\r\n      ...data,\r\n      ..._data\r\n    },\r\n    childVNode\r\n  );\r\n}\r\n\r\nexport function getRealParent(ctx) {\r\n  let parent = ctx.$parent;\r\n\r\n  if (!parent._isVuescrollRoot && parent) {\r\n    parent = parent.$parent;\r\n  }\r\n\r\n  return parent;\r\n}\r\n","// detect content size change\r\nimport { eventCenter, isIE } from '../../util';\r\nexport function listenResize(element, callback) {\r\n  return injectObject(element, callback);\r\n}\r\n\r\nfunction injectObject(element, callback) {\r\n  if (element.hasResized) {\r\n    return;\r\n  }\r\n\r\n  var OBJECT_STYLE =\r\n    'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; padding: 0; margin: 0; opacity: 0; z-index: -1000; pointer-events: none;';\r\n  // define a wrap due to ie's zIndex bug\r\n  var objWrap = document.createElement('div');\r\n  objWrap.style.cssText = OBJECT_STYLE;\r\n  var object = document.createElement('object');\r\n  object.style.cssText = OBJECT_STYLE;\r\n  object.type = 'text/html';\r\n  object.tabIndex = -1;\r\n  object.onload = () => {\r\n    eventCenter(object.contentDocument.defaultView, 'resize', callback);\r\n  };\r\n  // https://github.com/wnr/element-resize-detector/blob/aafe9f7ea11d1eebdab722c7c5b86634e734b9b8/src/detection-strategy/object.js#L159\r\n  if (!isIE()) {\r\n    object.data = 'about:blank';\r\n  }\r\n  objWrap.isResizeElm = true;\r\n  objWrap.appendChild(object);\r\n  element.appendChild(objWrap);\r\n  if (isIE()) {\r\n    object.data = 'about:blank';\r\n  }\r\n  return function destroy() {\r\n    if (object.contentDocument) {\r\n      eventCenter(\r\n        object.contentDocument.defaultView,\r\n        'resize',\r\n        callback,\r\n        'off'\r\n      );\r\n    }\r\n    element.removeChild(objWrap);\r\n    element.hasResized = false;\r\n  };\r\n}\r\n","// all modes\r\nexport const modes = ['slide', 'native', 'pure-native'];\r\n// do nothing\r\nexport const NOOP = () => {};\r\n// some small changes.\r\nexport const smallChangeArray = [\r\n  'mergedOptions.vuescroll.pullRefresh.tips',\r\n  'mergedOptions.vuescroll.pushLoad.tips',\r\n  'mergedOptions.rail',\r\n  'mergedOptions.bar'\r\n];\r\n","import { modes } from './constants';\r\nimport { error } from '../util';\r\nexport default {\r\n  // vuescroll\r\n  vuescroll: {\r\n    mode: 'native',\r\n    // vuescroll's size(height/width) should be a percent(100%)\r\n    // or be a number that is equal to its parentNode's width or\r\n    // height ?\r\n    sizeStrategy: 'percent',\r\n    // pullRefresh or pushLoad is only for the slide mode...\r\n    pullRefresh: {\r\n      enable: false,\r\n      tips: {\r\n        deactive: 'Pull to Refresh',\r\n        active: 'Release to Refresh',\r\n        start: 'Refreshing...',\r\n        beforeDeactive: 'Refresh Successfully!'\r\n      }\r\n    },\r\n    pushLoad: {\r\n      enable: false,\r\n      tips: {\r\n        deactive: 'Push to Load',\r\n        active: 'Release to Load',\r\n        start: 'Loading...',\r\n        beforeDeactive: 'Load Successfully!'\r\n      }\r\n    },\r\n    paging: false,\r\n    zooming: true,\r\n    snapping: {\r\n      enable: false,\r\n      width: 100,\r\n      height: 100\r\n    },\r\n    // some scroller options\r\n    scroller: {\r\n      /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\r\n      bouncing: true,\r\n      /** Enable locking to the main axis if user moves only slightly on one of them at start */\r\n      locking: true,\r\n      /** Minimum zoom level */\r\n      minZoom: 0.5,\r\n      /** Maximum zoom level */\r\n      maxZoom: 3,\r\n      /** Multiply or decrease scrolling speed **/\r\n      speedMultiplier: 1,\r\n      /** This configures the amount of change applied to deceleration when reaching boundaries  **/\r\n      penetrationDeceleration: 0.03,\r\n      /** This configures the amount of change applied to acceleration when reaching boundaries  **/\r\n      penetrationAcceleration: 0.08,\r\n      /** Whether call e.preventDefault event when sliding the content or not */\r\n      preventDefault: true\r\n    }\r\n  },\r\n  scrollPanel: {\r\n    // when component mounted.. it will automatically scrolls.\r\n    initialScrollY: false,\r\n    initialScrollX: false,\r\n    // feat: #11\r\n    scrollingX: true,\r\n    scrollingY: true,\r\n    speed: 300,\r\n    easing: undefined\r\n  },\r\n  //\r\n  scrollContent: {\r\n    padding: false\r\n  },\r\n  //\r\n  rail: {\r\n    vRail: {\r\n      width: '6px',\r\n      pos: 'right',\r\n      background: '#01a99a',\r\n      opacity: 0\r\n    },\r\n    //\r\n    hRail: {\r\n      height: '6px',\r\n      pos: 'bottom',\r\n      background: '#01a99a',\r\n      opacity: 0\r\n    }\r\n  },\r\n  bar: {\r\n    showDelay: 500,\r\n    vBar: {\r\n      background: '#00a650',\r\n      keepShow: false,\r\n      opacity: 1,\r\n      hover: false\r\n    },\r\n    //\r\n    hBar: {\r\n      background: '#00a650',\r\n      keepShow: false,\r\n      opacity: 1,\r\n      hover: false\r\n    }\r\n  }\r\n};\r\n/**\r\n * validate the options\r\n *\r\n * @export\r\n * @param {any} ops\r\n */\r\nexport function validateOptions(ops) {\r\n  let shouldStopRender = false;\r\n  const { vuescroll, scrollPanel } = ops;\r\n\r\n  // validate vuescroll\r\n  if (!~modes.indexOf(vuescroll.mode)) {\r\n    error(`The vuescroll's option \"mode\" should be one of the ${modes}`);\r\n    shouldStopRender = true;\r\n  }\r\n\r\n  if (\r\n    vuescroll.paging == vuescroll.snapping.enable &&\r\n    vuescroll.paging &&\r\n    (vuescroll.pullRefresh || vuescroll.pushLoad)\r\n  ) {\r\n    error(\r\n      'paging, snapping, (pullRefresh with pushLoad) can only one of them to be true.'\r\n    );\r\n  }\r\n  // validate scrollPanel\r\n  const initialScrollY = scrollPanel['initialScrollY'];\r\n  const initialScrollX = scrollPanel['initialScrollX'];\r\n\r\n  if (initialScrollY && !String(initialScrollY).match(/^\\d+(\\.\\d+)?(%)?$/)) {\r\n    error(\r\n      'The prop `initialScrollY` should be a percent number like 10% or an exact number that greater than or equal to 0 like 100.'\r\n    );\r\n  }\r\n\r\n  if (initialScrollX && !String(initialScrollX).match(/^\\d+(\\.\\d+)?(%)?$/)) {\r\n    error(\r\n      'The prop `initialScrollX` should be a percent number like 10% or an exact number that greater than or equal to 0 like 100.'\r\n    );\r\n  }\r\n\r\n  return shouldStopRender;\r\n}\r\n","import GCF, { validateOptions } from '../shared/global-config';\r\nimport { deepMerge, defineReactive } from '../util';\r\n\r\n/**\r\n * hack the lifeCycle\r\n *\r\n * to merge the global data into user-define data\r\n */\r\nfunction hackPropsData() {\r\n  const vm = this;\r\n  if (vm.$options.name === 'vueScroll') {\r\n    const _gfc = deepMerge(vm.$vuescrollConfig, {});\r\n    const ops = deepMerge(GCF, _gfc);\r\n    vm.$options.propsData.ops = vm.$options.propsData.ops || {};\r\n    Object.keys(vm.$options.propsData.ops).forEach(key => {\r\n      {\r\n        defineReactive(vm.mergedOptions, key, vm.$options.propsData.ops);\r\n      }\r\n    });\r\n    // from ops to mergedOptions\r\n    deepMerge(ops, vm.mergedOptions);\r\n\r\n    const prefix = 'padding-';\r\n    defineReactive(vm.mergedOptions.scrollContent, 'paddPos', () => {\r\n      return prefix + vm.mergedOptions.rail.vRail.pos;\r\n    });\r\n    defineReactive(vm.mergedOptions.scrollContent, 'paddValue', () => {\r\n      return vm.mergedOptions.rail.vRail.width;\r\n    });\r\n  }\r\n}\r\nexport default {\r\n  data() {\r\n    return {\r\n      shouldStopRender: false,\r\n      mergedOptions: {\r\n        vuescroll: {},\r\n        scrollPanel: {},\r\n        scrollContent: {},\r\n        rail: {},\r\n        bar: {}\r\n      }\r\n    };\r\n  },\r\n  created() {\r\n    hackPropsData.call(this);\r\n\r\n    this._isVuescrollRoot = true;\r\n\r\n    this.renderError = validateOptions(this.mergedOptions);\r\n  }\r\n};\r\n","/**\r\n *  Compatible to scroller's animation function\r\n */\r\nexport function createEasingFunction(easing, easingPattern) {\r\n  return function(time) {\r\n    return easingPattern(easing, time);\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate the easing pattern\r\n * @link https://github.com/cferdinandi/smooth-scroll/blob/master/src/js/smooth-scroll.js\r\n * modified by wangyi7099\r\n * @param {String} type Easing pattern\r\n * @param {Number} time Time animation should take to complete\r\n * @returns {Number}\r\n */\r\nexport function easingPattern(easing, time) {\r\n  let pattern = null;\r\n  /* istanbul ignore next */\r\n  {\r\n    // Default Easing Patterns\r\n    if (easing === 'easeInQuad') pattern = time * time; // accelerating from zero velocity\r\n    if (easing === 'easeOutQuad') pattern = time * (2 - time); // decelerating to zero velocity\r\n    if (easing === 'easeInOutQuad')\r\n      pattern = time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time; // acceleration until halfway, then deceleration\r\n    if (easing === 'easeInCubic') pattern = time * time * time; // accelerating from zero velocity\r\n    if (easing === 'easeOutCubic') pattern = --time * time * time + 1; // decelerating to zero velocity\r\n    if (easing === 'easeInOutCubic')\r\n      pattern =\r\n        time < 0.5\r\n          ? 4 * time * time * time\r\n          : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1; // acceleration until halfway, then deceleration\r\n    if (easing === 'easeInQuart') pattern = time * time * time * time; // accelerating from zero velocity\r\n    if (easing === 'easeOutQuart') pattern = 1 - --time * time * time * time; // decelerating to zero velocity\r\n    if (easing === 'easeInOutQuart')\r\n      pattern =\r\n        time < 0.5\r\n          ? 8 * time * time * time * time\r\n          : 1 - 8 * --time * time * time * time; // acceleration until halfway, then deceleration\r\n    if (easing === 'easeInQuint') pattern = time * time * time * time * time; // accelerating from zero velocity\r\n    if (easing === 'easeOutQuint')\r\n      pattern = 1 + --time * time * time * time * time; // decelerating to zero velocity\r\n    if (easing === 'easeInOutQuint')\r\n      pattern =\r\n        time < 0.5\r\n          ? 16 * time * time * time * time * time\r\n          : 1 + 16 * --time * time * time * time * time; // acceleration until halfway, then deceleration\r\n  }\r\n  return pattern || time; // no easing, no acceleration\r\n}\r\n","/*\r\n * Scroller\r\n * http://github.com/zynga/scroller\r\n *\r\n * Copyright 2011, Zynga Inc.\r\n * Licensed under the MIT License.\r\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\r\n *\r\n * Based on the work of: Unify Project (unify-project.org)\r\n * http://unify-project.org\r\n * Copyright 2011, Deutsche Telekom AG\r\n * License: MIT + Apache (V2)\r\n */\r\n\r\n/**\r\n * Generic animation class with support for dropped frames both optional easing and duration.\r\n *\r\n * Optional duration is useful when the lifetime is defined by another condition than time\r\n * e.g. speed of an animating object, etc.\r\n *\r\n * Dropped frame logic allows to keep using the same updater logic independent from the actual\r\n * rendering. This eases a lot of cases where it might be pretty complex to break down a state\r\n * based on the pure time difference.\r\n */\r\nimport { requestAnimationFrame } from './requestAnimationFrame';\r\n\r\nvar time =\r\n  Date.now ||\r\n  function() {\r\n    return +new Date();\r\n  };\r\nvar desiredFrames = 60;\r\nvar millisecondsPerSecond = 1000;\r\nvar running = {};\r\nvar counter = 1;\r\n\r\nconst core = { effect: {} };\r\nlet global = null;\r\n\r\nif (typeof window !== 'undefined') {\r\n  global = window;\r\n} else {\r\n  global = {};\r\n}\r\n\r\ncore.effect.Animate = {\r\n  /**\r\n   * A requestAnimationFrame wrapper / polyfill.\r\n   *\r\n   * @param callback {Function} The callback to be invoked before the next repaint.\r\n   * @param root {HTMLElement} The root element for the repaint\r\n   */\r\n  requestAnimationFrame: requestAnimationFrame(global),\r\n  /**\r\n   * Stops the given animation.\r\n   *\r\n   * @param id {Integer} Unique animation ID\r\n   * @return {Boolean} Whether the animation was stopped (aka, was running before)\r\n   */\r\n  stop: function(id) {\r\n    var cleared = running[id] != null;\r\n    if (cleared) {\r\n      running[id] = null;\r\n    }\r\n\r\n    return cleared;\r\n  },\r\n\r\n  /**\r\n   * Whether the given animation is still running.\r\n   *\r\n   * @param id {Integer} Unique animation ID\r\n   * @return {Boolean} Whether the animation is still running\r\n   */\r\n  isRunning: function(id) {\r\n    return running[id] != null;\r\n  },\r\n\r\n  /**\r\n   * Start the animation.\r\n   *\r\n   * @param stepCallback {Function} Pointer to function which is executed on every step.\r\n   *   Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`\r\n   * @param verifyCallback {Function} Executed before every animation step.\r\n   *   Signature of the method should be `function() { return continueWithAnimation; }`\r\n   * @param completedCallback {Function}\r\n   *   Signature of the method should be `function(droppedFrames, finishedAnimation) {}`\r\n   * @param duration {Integer} Milliseconds to run the animation\r\n   * @param easingMethod {Function} Pointer to easing function\r\n   *   Signature of the method should be `function(percent) { return modifiedValue; }`\r\n   * @param root {Element ? document.body} Render root, when available. Used for internal\r\n   *   usage of requestAnimationFrame.\r\n   * @return {Integer} Identifier of animation. Can be used to stop it any time.\r\n   */\r\n  start: function(\r\n    stepCallback,\r\n    verifyCallback,\r\n    completedCallback,\r\n    duration,\r\n    easingMethod,\r\n    root\r\n  ) {\r\n    var start = time();\r\n    var lastFrame = start;\r\n    var percent = 0;\r\n    var dropCounter = 0;\r\n    var id = counter++;\r\n\r\n    if (!root) {\r\n      root = document.body;\r\n    }\r\n\r\n    // Compacting running db automatically every few new animations\r\n    if (id % 20 === 0) {\r\n      var newRunning = {};\r\n      for (var usedId in running) {\r\n        newRunning[usedId] = true;\r\n      }\r\n      running = newRunning;\r\n    }\r\n\r\n    // This is the internal step method which is called every few milliseconds\r\n    var step = function(virtual) {\r\n      // Normalize virtual value\r\n      var render = virtual !== true;\r\n\r\n      // Get current time\r\n      var now = time();\r\n\r\n      // Verification is executed before next animation step\r\n      if (!running[id] || (verifyCallback && !verifyCallback(id))) {\r\n        running[id] = null;\r\n        completedCallback &&\r\n          completedCallback(\r\n            desiredFrames -\r\n              dropCounter / ((now - start) / millisecondsPerSecond),\r\n            id,\r\n            false\r\n          );\r\n        return;\r\n      }\r\n\r\n      // For the current rendering to apply let's update omitted steps in memory.\r\n      // This is important to bring internal state variables up-to-date with progress in time.\r\n      if (render) {\r\n        var droppedFrames =\r\n          Math.round(\r\n            (now - lastFrame) / (millisecondsPerSecond / desiredFrames)\r\n          ) - 1;\r\n        for (var j = 0; j < Math.min(droppedFrames, 4); j++) {\r\n          step(true);\r\n          dropCounter++;\r\n        }\r\n      }\r\n\r\n      // Compute percent value\r\n      if (duration) {\r\n        percent = (now - start) / duration;\r\n        if (percent > 1) {\r\n          percent = 1;\r\n        }\r\n      }\r\n\r\n      // Execute step callback, then...\r\n      var value = easingMethod ? easingMethod(percent) : percent;\r\n      if (\r\n        (stepCallback(value, now, render) === false || percent === 1) &&\r\n        render\r\n      ) {\r\n        running[id] = null;\r\n        completedCallback &&\r\n          completedCallback(\r\n            desiredFrames -\r\n              dropCounter / ((now - start) / millisecondsPerSecond),\r\n            id,\r\n            percent === 1 || duration == null\r\n          );\r\n      } else if (render) {\r\n        lastFrame = now;\r\n        core.effect.Animate.requestAnimationFrame(step, root);\r\n      }\r\n    };\r\n\r\n    // Mark as running\r\n    running[id] = true;\r\n\r\n    // Init first step\r\n    core.effect.Animate.requestAnimationFrame(step, root);\r\n\r\n    // Return unique animation ID\r\n    return id;\r\n  }\r\n};\r\n\r\nexport { core };\r\n","export function requestAnimationFrame(global) {\r\n  // Check for request animation Frame support\r\n  var requestFrame =\r\n    global.requestAnimationFrame ||\r\n    global.webkitRequestAnimationFrame ||\r\n    global.mozRequestAnimationFrame ||\r\n    global.oRequestAnimationFrame;\r\n  var isNative = !!requestFrame;\r\n\r\n  if (\r\n    requestFrame &&\r\n    !/requestAnimationFrame\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}/i.test(\r\n      requestFrame.toString()\r\n    )\r\n  ) {\r\n    isNative = false;\r\n  }\r\n\r\n  if (isNative) {\r\n    return function(callback, root) {\r\n      requestFrame(callback, root);\r\n    };\r\n  }\r\n\r\n  var TARGET_FPS = 60;\r\n  var requests = {};\r\n  var rafHandle = 1;\r\n  var intervalHandle = null;\r\n  var lastActive = +new Date();\r\n\r\n  return function(callback) {\r\n    var callbackHandle = rafHandle++;\r\n\r\n    // Store callback\r\n    requests[callbackHandle] = callback;\r\n    requestCount++;\r\n\r\n    // Create timeout at first request\r\n    if (intervalHandle === null) {\r\n      intervalHandle = setInterval(function() {\r\n        var time = +new Date();\r\n        var currentRequests = requests;\r\n\r\n        // Reset data structure before executing callbacks\r\n        requests = {};\r\n        requestCount = 0;\r\n\r\n        for (var key in currentRequests) {\r\n          if (currentRequests.hasOwnProperty(key)) {\r\n            currentRequests[key](time);\r\n            lastActive = time;\r\n          }\r\n        }\r\n\r\n        // Disable the timeout when nothing happens for a certain\r\n        // period of time\r\n        if (time - lastActive > 2500) {\r\n          clearInterval(intervalHandle);\r\n          intervalHandle = null;\r\n        }\r\n      }, 1000 / TARGET_FPS);\r\n    }\r\n\r\n    return callbackHandle;\r\n  };\r\n}\r\n","import {\r\n  createEasingFunction,\r\n  easingPattern\r\n} from '../third-party/easingPattern';\r\nimport { core } from '../third-party/scroller/animate';\r\nimport { warn, isChildInParent } from '../util';\r\n\r\nconst vsInstances = {};\r\n\r\nexport function refreshAll() {\r\n  for (let vs in vsInstances) {\r\n    vsInstances[vs].refresh();\r\n  }\r\n}\r\n\r\nfunction getNumericValue(distance, size) {\r\n  let number;\r\n  if (!(number = /(-?\\d+(?:\\.\\d+?)?)%$/.exec(distance))) {\r\n    number = distance - 0;\r\n  } else {\r\n    number = number[1] - 0;\r\n    number = (size * number) / 100;\r\n  }\r\n  return number;\r\n}\r\n\r\nfunction goScrolling(elm, deltaX, deltaY, speed, easing, scrollingComplete) {\r\n  const startLocationY = elm['scrollTop'];\r\n  const startLocationX = elm['scrollLeft'];\r\n  let positionX = startLocationX;\r\n  let positionY = startLocationY;\r\n  /**\r\n   * keep the limit of scroll delta.\r\n   */\r\n  /* istanbul ignore next */\r\n  if (startLocationY + deltaY < 0) {\r\n    deltaY = -startLocationY;\r\n  }\r\n  const scrollHeight = elm['scrollHeight'];\r\n  if (startLocationY + deltaY > scrollHeight) {\r\n    deltaY = scrollHeight - startLocationY;\r\n  }\r\n  if (startLocationX + deltaX < 0) {\r\n    deltaX = -startLocationX;\r\n  }\r\n  if (startLocationX + deltaX > elm['scrollWidth']) {\r\n    deltaX = elm['scrollWidth'] - startLocationX;\r\n  }\r\n\r\n  const easingMethod = createEasingFunction(easing, easingPattern);\r\n\r\n  const stepCallback = percentage => {\r\n    positionX = startLocationX + deltaX * percentage;\r\n    positionY = startLocationY + deltaY * percentage;\r\n    elm['scrollTop'] = Math.floor(positionY);\r\n    elm['scrollLeft'] = Math.floor(positionX);\r\n  };\r\n\r\n  const verifyCallback = () => {\r\n    return (\r\n      Math.abs(positionY - startLocationY) <= Math.abs(deltaY) ||\r\n      Math.abs(positionX - startLocationX) <= Math.abs(deltaX)\r\n    );\r\n  };\r\n\r\n  core.effect.Animate.start(\r\n    stepCallback,\r\n    verifyCallback,\r\n    scrollingComplete,\r\n    speed,\r\n    easingMethod\r\n  );\r\n}\r\n\r\nexport default {\r\n  mounted() {\r\n    vsInstances[this._uid] = this;\r\n  },\r\n  beforeDestroy() {\r\n    delete vsInstances[this._uid];\r\n  },\r\n  methods: {\r\n    // public api\r\n    scrollTo({ x, y }, animate = true, force = false) {\r\n      if (typeof x === 'undefined') {\r\n        x = this.vuescroll.state.internalScrollLeft || 0;\r\n      } else {\r\n        x = getNumericValue(x, this.scrollPanelElm.scrollWidth);\r\n      }\r\n      if (typeof y === 'undefined') {\r\n        y = this.vuescroll.state.internalScrollTop || 0;\r\n      } else {\r\n        y = getNumericValue(y, this.scrollPanelElm.scrollHeight);\r\n      }\r\n      this.internalScrollTo(x, y, animate, force);\r\n    },\r\n    scrollBy({ dx = 0, dy = 0 }, animate = true) {\r\n      let {\r\n        internalScrollLeft = 0,\r\n        internalScrollTop = 0\r\n      } = this.vuescroll.state;\r\n      if (dx) {\r\n        internalScrollLeft += getNumericValue(\r\n          dx,\r\n          this.scrollPanelElm.scrollWidth\r\n        );\r\n      }\r\n      if (dy) {\r\n        internalScrollTop += getNumericValue(\r\n          dy,\r\n          this.scrollPanelElm.scrollHeight\r\n        );\r\n      }\r\n      this.internalScrollTo(internalScrollLeft, internalScrollTop, animate);\r\n    },\r\n    zoomBy(factor, animate, originLeft, originTop, callback) {\r\n      if (this.mode != 'slide') {\r\n        warn('zoomBy and zoomTo are only for slide mode!');\r\n        return;\r\n      }\r\n      this.scroller.zoomBy(factor, animate, originLeft, originTop, callback);\r\n    },\r\n    zoomTo(level, animate = false, originLeft, originTop, callback) {\r\n      if (this.mode != 'slide') {\r\n        warn('zoomBy and zoomTo are only for slide mode!');\r\n        return;\r\n      }\r\n      this.scroller.zoomTo(level, animate, originLeft, originTop, callback);\r\n    },\r\n    getCurrentPage() {\r\n      if (this.mode != 'slide' || !this.mergedOptions.vuescroll.paging) {\r\n        warn(\r\n          'getCurrentPage and goToPage are only for slide mode and paging is enble!'\r\n        );\r\n        return;\r\n      }\r\n      return this.scroller.getCurrentPage();\r\n    },\r\n    goToPage(dest, animate = false) {\r\n      if (this.mode != 'slide' || !this.mergedOptions.vuescroll.paging) {\r\n        warn(\r\n          'getCurrentPage and goToPage are only for slide mode and paging is enble!'\r\n        );\r\n        return;\r\n      }\r\n      this.scroller.goToPage(dest, animate);\r\n    },\r\n    triggerRefreshOrLoad(type) {\r\n      if (this.mode != 'slide') {\r\n        warn('You can only use triggerRefreshOrLoad in slide mode!');\r\n        return;\r\n      }\r\n      const isRefresh = this.mergedOptions.vuescroll.pullRefresh.enable;\r\n      const isLoad = this.mergedOptions.vuescroll.pushLoad.enable;\r\n      if (type == 'refresh' && !isRefresh) {\r\n        warn('refresh must be enabled!');\r\n        return;\r\n      } else if (type == 'load' && !isLoad) {\r\n        warn('load must be enabled!');\r\n        return;\r\n      } else if (type !== 'refresh' && type !== 'load') {\r\n        warn('param must be one of load and refresh!');\r\n        return;\r\n      }\r\n      /* istanbul ignore if */\r\n      if (this.vuescroll.state[`${type}Stage`] == 'start') {\r\n        return;\r\n      }\r\n      this.scroller.triggerRefreshOrLoad(type);\r\n      return true;\r\n    },\r\n    getCurrentviewDom() {\r\n      const parent =\r\n        this.mode == 'slide' || this.mode == 'pure-native'\r\n          ? this.scrollPanelElm\r\n          : this.scrollContentElm;\r\n      const children = parent.children;\r\n      const domFragment = [];\r\n      const isCurrentview = dom => {\r\n        const { left, top, width, height } = dom.getBoundingClientRect();\r\n        const {\r\n          left: parentLeft,\r\n          top: parentTop,\r\n          height: parentHeight,\r\n          width: parentWidth\r\n        } = this.$el.getBoundingClientRect();\r\n        if (\r\n          left - parentLeft + width > 0 &&\r\n          left - parentLeft < parentWidth &&\r\n          top - parentTop + height > 0 &&\r\n          top - parentTop < parentHeight\r\n        ) {\r\n          return true;\r\n        }\r\n        return false;\r\n      };\r\n\r\n      for (let i = 0; i < children.length; i++) {\r\n        const dom = children.item(i);\r\n        if (isCurrentview(dom) && !dom.isResizeElm) {\r\n          domFragment.push(dom);\r\n        }\r\n      }\r\n\r\n      return domFragment;\r\n    },\r\n    // private api\r\n    internalScrollTo(destX, destY, animate, force) {\r\n      if (this.mode == 'native' || this.mode == 'pure-native') {\r\n        if (animate) {\r\n          // hadnle for scroll complete\r\n          const scrollingComplete = () => {\r\n            this.updateBarStateAndEmitEvent('handle-scroll-complete');\r\n          };\r\n          goScrolling(\r\n            this.$refs['scrollPanel'].$el,\r\n            destX - this.$refs['scrollPanel'].$el.scrollLeft,\r\n            destY - this.$refs['scrollPanel'].$el.scrollTop,\r\n            this.mergedOptions.scrollPanel.speed,\r\n            this.mergedOptions.scrollPanel.easing,\r\n            scrollingComplete\r\n          );\r\n        } else {\r\n          this.$refs['scrollPanel'].$el.scrollTop = destY;\r\n          this.$refs['scrollPanel'].$el.scrollLeft = destX;\r\n        }\r\n      }\r\n      // for non-native we use scroller's scorllTo\r\n      else if (this.mode == 'slide') {\r\n        this.scroller.scrollTo(destX, destY, animate, undefined, force);\r\n      }\r\n    },\r\n    scrollIntoView(elm, animate = true) {\r\n      const parentElm = this.$el;\r\n      if (typeof elm === 'string') {\r\n        elm = parentElm.querySelector(elm);\r\n      }\r\n      if (!isChildInParent(elm, parentElm)) {\r\n        warn(\r\n          'The element or selector you passed is not the element of Vuescroll, please pass the element that is in Vuescroll to scrollIntoView API. '\r\n        );\r\n        return;\r\n      }\r\n      // parent elm left, top\r\n      const { left, top } = this.$el.getBoundingClientRect();\r\n      // child elm left, top\r\n      const { left: childLeft, top: childTop } = elm.getBoundingClientRect();\r\n\r\n      const diffX = left - childLeft;\r\n      const diffY = top - childTop;\r\n\r\n      this.scrollBy(\r\n        {\r\n          dx: -diffX,\r\n          dy: -diffY\r\n        },\r\n        animate\r\n      );\r\n    },\r\n    refresh() {\r\n      this.refreshInternalStatus();\r\n    }\r\n  }\r\n};\r\n","import { extractNumberFromPx } from '../../util';\r\nexport default {\r\n  methods: {\r\n    updateNativeModeBarState() {\r\n      const scrollPanel = this.scrollPanelElm;\r\n      const vuescroll = this.$el;\r\n      const isPercent = this.mergedOptions.vuescroll.sizeStrategy == 'percent';\r\n      const clientWidth = isPercent\r\n        ? vuescroll.clientWidth\r\n        : extractNumberFromPx(this.vuescroll.state.width);\r\n      const clientHeight = isPercent\r\n        ? vuescroll.clientHeight\r\n        : extractNumberFromPx(this.vuescroll.state.height);\r\n      let heightPercentage = (clientHeight * 100) / scrollPanel.scrollHeight;\r\n      let widthPercentage = (clientWidth * 100) / scrollPanel.scrollWidth;\r\n      this.bar.vBar.state.posValue =\r\n        (scrollPanel.scrollTop * 100) / clientHeight;\r\n      this.bar.hBar.state.posValue =\r\n        (scrollPanel.scrollLeft * 100) / clientWidth;\r\n      this.bar.vBar.state.size =\r\n        heightPercentage < 100 ? heightPercentage + '%' : 0;\r\n      this.bar.hBar.state.size =\r\n        widthPercentage < 100 ? widthPercentage + '%' : 0;\r\n    }\r\n  }\r\n};\r\n","/*\r\n * Scroller\r\n * http://github.com/zynga/scroller\r\n *\r\n * modified by wangyi7099\r\n * \r\n * Copyright 2011, Zynga Inc.\r\n * Licensed under the MIT License.\r\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\r\n *\r\n * Based on the work of: Unify Project (unify-project.org)\r\n * http://unify-project.org\r\n * Copyright 2011, Deutsche Telekom AG\r\n * License: MIT + Apache (V2)\r\n */\r\nimport { easingPattern, createEasingFunction } from '../easingPattern';\r\nimport { core } from './animate';\r\nimport { NOOP } from '../../shared/constants';\r\n\r\nvar animatingMethod = null;\r\n\r\nvar noAnimatingMethod = null;\r\n\r\nexport default function Scroller(callback, options) {\r\n  this.__callback = callback;\r\n\r\n  this.options = {\r\n    /** Enable scrolling on x-axis */\r\n    scrollingX: true,\r\n\r\n    /** Enable scrolling on y-axis */\r\n    scrollingY: true,\r\n\r\n    /** Enable animations for deceleration, snap back, zooming and scrolling */\r\n    animating: true,\r\n\r\n    /** duration for animations triggered by scrollTo/zoomTo */\r\n    animationDuration: 250,\r\n\r\n    /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\r\n    bouncing: true,\r\n\r\n    /** Enable locking to the main axis if user moves only slightly on one of them at start */\r\n    locking: true,\r\n\r\n    /** Enable pagination mode (switching between full page content panes) */\r\n    paging: false,\r\n\r\n    /** Enable snapping of content to a configured pixel grid */\r\n    snapping: false,\r\n\r\n    /** Enable zooming of content via API, fingers and mouse wheel */\r\n    zooming: false,\r\n\r\n    /** Minimum zoom level */\r\n    minZoom: 0.5,\r\n\r\n    /** Maximum zoom level */\r\n    maxZoom: 3,\r\n\r\n    /** Multiply or decrease scrolling speed **/\r\n    speedMultiplier: 1,\r\n\r\n    /** Callback that is fired on the later of touch end or deceleration end,\r\n\t\t\t\tprovided that another scrolling action has not begun. Used to know\r\n\t\t\t\twhen to fade out a scrollbar. */\r\n    scrollingComplete: NOOP,\r\n\r\n    animatingEasing: 'easeOutCubic',\r\n\r\n    noAnimatingEasing: 'easeInOutCubic',\r\n\r\n    /** This configures the amount of change applied to deceleration when reaching boundaries  **/\r\n    penetrationDeceleration: 0.03,\r\n\r\n    /** This configures the amount of change applied to acceleration when reaching boundaries  **/\r\n    penetrationAcceleration: 0.08\r\n  };\r\n\r\n  for (var key in options) {\r\n    this.options[key] = options[key];\r\n  }\r\n\r\n  animatingMethod = createEasingFunction(\r\n    this.options.animatingEasing,\r\n    easingPattern\r\n  );\r\n  noAnimatingMethod = createEasingFunction(\r\n    this.options.noAnimatingEasing,\r\n    easingPattern\r\n  );\r\n}\r\n\r\nvar members = {\r\n  /*\r\n\t---------------------------------------------------------------------------\r\n\t\tINTERNAL FIELDS :: STATUS\r\n\t---------------------------------------------------------------------------\r\n\t*/\r\n\r\n  /** {Boolean} Whether only a single finger is used in touch handling */\r\n  __isSingleTouch: false,\r\n\r\n  /** {Boolean} Whether a touch event sequence is in progress */\r\n  __isTracking: false,\r\n\r\n  /** {Boolean} Whether a deceleration animation went to completion. */\r\n  __didDecelerationComplete: false,\r\n\r\n  /**\r\n   * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when\r\n   * a gesturestart event happens. This has higher priority than dragging.\r\n   */\r\n  __isGesturing: false,\r\n\r\n  /**\r\n   * {Boolean} Whether the user has moved by such a distance that we have enabled\r\n   * dragging mode. Hint: It's only enabled after some pixels of movement to\r\n   * not interrupt with clicks etc.\r\n   */\r\n  __isDragging: false,\r\n\r\n  /**\r\n   * {Boolean} Not touching and dragging anymore, and smoothly animating the\r\n   * touch sequence using deceleration.\r\n   */\r\n  __isDecelerating: false,\r\n\r\n  /**\r\n   * {Boolean} Smoothly animating the currently configured change\r\n   */\r\n  __isAnimating: false,\r\n\r\n  /*\r\n\t---------------------------------------------------------------------------\r\n\t\tINTERNAL FIELDS :: DIMENSIONS\r\n\t---------------------------------------------------------------------------\r\n\t*/\r\n\r\n  /** {Integer} Available outer left position (from document perspective) */\r\n  __clientLeft: 0,\r\n\r\n  /** {Integer} Available outer top position (from document perspective) */\r\n  __clientTop: 0,\r\n\r\n  /** {Integer} Available outer width */\r\n  __clientWidth: 0,\r\n\r\n  /** {Integer} Available outer height */\r\n  __clientHeight: 0,\r\n\r\n  /** {Integer} Outer width of content */\r\n  __contentWidth: 0,\r\n\r\n  /** {Integer} Outer height of content */\r\n  __contentHeight: 0,\r\n\r\n  /** {Integer} Snapping width for content */\r\n  __snapWidth: 100,\r\n\r\n  /** {Integer} Snapping height for content */\r\n  __snapHeight: 100,\r\n\r\n  /** {Integer} Height to assign to refresh area */\r\n  __refreshHeight: null,\r\n  /** {Integer} Height to assign to refresh area */\r\n  __loadHeight: null,\r\n  /** {Boolean} Whether the refresh process is enabled when the event is released now */\r\n  __refreshActive: false,\r\n\r\n  /** {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release */\r\n  __refreshActivate: null,\r\n\r\n  __refreshBeforeDeactivate: null,\r\n\r\n  /** {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled */\r\n  __refreshDeactivate: null,\r\n\r\n  /** {Function} Callback to execute to start the actual refresh. Call {@link #refreshFinish} when done */\r\n  __refreshStart: null,\r\n\r\n  __loadActive: null,\r\n\r\n  __loadActivate: null,\r\n\r\n  __loadBeforeDeactivate: null,\r\n\r\n  __loadDeactivate: null,\r\n\r\n  __loadStart: null,\r\n  /** {Number} Zoom level */\r\n  __zoomLevel: 1,\r\n\r\n  /** {Number} Scroll position on x-axis */\r\n  __scrollLeft: 0,\r\n\r\n  /** {Number} Scroll position on y-axis */\r\n  __scrollTop: 0,\r\n\r\n  /** {Integer} Maximum allowed scroll position on x-axis */\r\n  __maxScrollLeft: 0,\r\n\r\n  /** {Integer} Maximum allowed scroll position on y-axis */\r\n  __maxScrollTop: 0,\r\n\r\n  /* {Number} Scheduled left position (final position when animating) */\r\n  __scheduledLeft: 0,\r\n\r\n  /* {Number} Scheduled top position (final position when animating) */\r\n  __scheduledTop: 0,\r\n\r\n  /* {Number} Scheduled zoom level (final scale when animating) */\r\n  __scheduledZoom: 0,\r\n\r\n  /**\r\n   * current page\r\n   */\r\n  __currentPageX: null,\r\n\r\n  __currentPageY: null,\r\n\r\n  /**\r\n   * total page\r\n   */\r\n  __totalXPage: null,\r\n\r\n  __totalYPage: null,\r\n  /*\r\n\t---------------------------------------------------------------------------\r\n\t\tINTERNAL FIELDS :: LAST POSITIONS\r\n\t---------------------------------------------------------------------------\r\n\t*/\r\n  /** whether the scroller is disabled or not */\r\n  __disable: false,\r\n  /** {Number} Left position of finger at start */\r\n  __lastTouchLeft: null,\r\n\r\n  /** {Number} Top position of finger at start */\r\n  __lastTouchTop: null,\r\n\r\n  /** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */\r\n  __lastTouchMove: null,\r\n\r\n  /** {Array} List of positions, uses three indexes for each state: left, top, timestamp */\r\n  __positions: null,\r\n\r\n  /*\r\n\t---------------------------------------------------------------------------\r\n\t\tINTERNAL FIELDS :: DECELERATION SUPPORT\r\n\t---------------------------------------------------------------------------\r\n\t*/\r\n\r\n  /** {Integer} Minimum left scroll position during deceleration */\r\n  __minDecelerationScrollLeft: null,\r\n\r\n  /** {Integer} Minimum top scroll position during deceleration */\r\n  __minDecelerationScrollTop: null,\r\n\r\n  /** {Integer} Maximum left scroll position during deceleration */\r\n  __maxDecelerationScrollLeft: null,\r\n\r\n  /** {Integer} Maximum top scroll position during deceleration */\r\n  __maxDecelerationScrollTop: null,\r\n\r\n  /** {Number} Current factor to modify horizontal scroll position with on every step */\r\n  __decelerationVelocityX: null,\r\n\r\n  /** {Number} Current factor to modify vertical scroll position with on every step */\r\n  __decelerationVelocityY: null,\r\n\r\n  /*\r\n\t---------------------------------------------------------------------------\r\n\t\tPUBLIC API\r\n\t---------------------------------------------------------------------------\r\n\t*/\r\n\r\n  /**\r\n   * Configures the dimensions of the client (outer) and content (inner) elements.\r\n   * Requires the available space for the outer element and the outer size of the inner element.\r\n   * All values which are falsy (null or zero etc.) are ignored and the old value is kept.\r\n   *\r\n   * @param clientWidth {Integer ? null} Inner width of outer element\r\n   * @param clientHeight {Integer ? null} Inner height of outer element\r\n   * @param contentWidth {Integer ? null} Outer width of inner element\r\n   * @param contentHeight {Integer ? null} Outer height of inner element\r\n   */\r\n  setDimensions: function(\r\n    clientWidth,\r\n    clientHeight,\r\n    contentWidth,\r\n    contentHeight,\r\n    animate = trye\r\n  ) {\r\n    var self = this;\r\n\r\n    // Only update values which are defined\r\n    if (clientWidth === +clientWidth) {\r\n      self.__clientWidth = clientWidth;\r\n    }\r\n\r\n    if (clientHeight === +clientHeight) {\r\n      self.__clientHeight = clientHeight;\r\n    }\r\n\r\n    if (contentWidth === +contentWidth) {\r\n      self.__contentWidth = contentWidth;\r\n    }\r\n\r\n    if (contentHeight === +contentHeight) {\r\n      self.__contentHeight = contentHeight;\r\n    }\r\n\r\n    // Refresh maximums\r\n    self.__computeScrollMax();\r\n\r\n    // Refresh scroll position\r\n    self.scrollTo(self.__scrollLeft, self.__scrollTop, animate);\r\n  },\r\n\r\n  /**\r\n   * Sets the client coordinates in relation to the document.\r\n   *\r\n   * @param left {Integer ? 0} Left position of outer element\r\n   * @param top {Integer ? 0} Top position of outer element\r\n   */\r\n  setPosition: function(left, top) {\r\n    var self = this;\r\n\r\n    self.__clientLeft = left || 0;\r\n    self.__clientTop = top || 0;\r\n  },\r\n\r\n  /**\r\n   * Configures the snapping (when snapping is active)\r\n   *\r\n   * @param width {Integer} Snapping width\r\n   * @param height {Integer} Snapping height\r\n   */\r\n  setSnapSize: function(width, height) {\r\n    var self = this;\r\n\r\n    self.__snapWidth = width;\r\n    self.__snapHeight = height;\r\n  },\r\n\r\n  /**\r\n   * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever\r\n   * the user event is released during visibility of this zone. This was introduced by some apps on iOS like\r\n   * the official Twitter client.\r\n   *\r\n   * @param height {Integer} Height of pull-to-refresh zone on top of rendered list\r\n   * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.\r\n   * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.\r\n   * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.\r\n   */\r\n  activatePullToRefresh: function(\r\n    height,\r\n    {\r\n      activateCallback,\r\n      deactivateCallback,\r\n      startCallback,\r\n      beforeDeactivateCallback\r\n    }\r\n  ) {\r\n    var self = this;\r\n\r\n    self.__refreshHeight = height;\r\n    self.__refreshActivate = activateCallback;\r\n    self.__refreshBeforeDeactivate = beforeDeactivateCallback;\r\n    self.__refreshDeactivate = deactivateCallback;\r\n    self.__refreshStart = startCallback;\r\n  },\r\n  activatePushToLoad: function(\r\n    height,\r\n    {\r\n      activateCallback,\r\n      deactivateCallback,\r\n      startCallback,\r\n      beforeDeactivateCallback\r\n    }\r\n  ) {\r\n    var self = this;\r\n\r\n    self.__loadHeight = height;\r\n    self.__loadActivate = activateCallback;\r\n    self.__loadBeforeDeactivate = beforeDeactivateCallback;\r\n    self.__loadDeactivate = deactivateCallback;\r\n    self.__loadStart = startCallback;\r\n  },\r\n\r\n  /**\r\n   * Starts pull-to-refresh manually.\r\n   */\r\n  triggerRefreshOrLoad: function(type = 'refresh') {\r\n    var wasDecelerating = this.__isDecelerating;\r\n    if (wasDecelerating) {\r\n      core.effect.Animate.stop(wasDecelerating);\r\n      this.__isDecelerating = false;\r\n    }\r\n    // Use publish instead of scrollTo to allow scrolling to out of boundary position\r\n    // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\r\n    if (type == 'refresh') {\r\n      this.__publish(\r\n        this.__scrollLeft,\r\n        -this.__refreshHeight,\r\n        this.__zoomLevel,\r\n        true\r\n      );\r\n      if (this.__refreshStart) {\r\n        this.__refreshStart();\r\n        this.__refreshActive = true;\r\n      }\r\n    } else {\r\n      this.__publish(\r\n        this.__scrollLeft,\r\n        this.__maxScrollTop + this.__loadHeight,\r\n        this.__zoomLevel,\r\n        true\r\n      );\r\n      if (this.__loadStart) {\r\n        this.__loadStart();\r\n        this.__loadActive = true;\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Signalizes that pull-to-refresh is finished.\r\n   */\r\n  finishRefreshOrLoad: function() {\r\n    var self = this;\r\n\r\n    if (self.__refreshBeforeDeactivate && self.__refreshActive) {\r\n      self.__refreshActive = false;\r\n      self.__refreshBeforeDeactivate(function() {\r\n        if (self.__refreshDeactivate) {\r\n          self.__refreshDeactivate();\r\n        }\r\n        self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\r\n      });\r\n    } else if (self.__refreshDeactivate && self.__refreshActive) {\r\n      self.__refreshActive = false;\r\n      self.__refreshDeactivate();\r\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\r\n    }\r\n\r\n    if (self.__loadBeforeDeactivate && self.__loadActive) {\r\n      self.__loadActive = false;\r\n      self.__loadBeforeDeactivate(function() {\r\n        if (self.__loadDeactivate) {\r\n          self.__loadDeactivate();\r\n        }\r\n        self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\r\n      });\r\n    } else if (self.__loadDeactivate && self.__loadActive) {\r\n      self.__loadActive = false;\r\n      self.__loadDeactivate();\r\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Returns the scroll position and zooming values\r\n   *\r\n   * @return {Map} `left` and `top` scroll position and `zoom` level\r\n   */\r\n  getValues: function() {\r\n    var self = this;\r\n\r\n    return {\r\n      left: self.__scrollLeft,\r\n      top: self.__scrollTop,\r\n      zoom: self.__zoomLevel\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Returns the maximum scroll values\r\n   *\r\n   * @return {Map} `left` and `top` maximum scroll values\r\n   */\r\n  getScrollMax: function() {\r\n    var self = this;\r\n\r\n    return {\r\n      left: self.__maxScrollLeft,\r\n      top: self.__maxScrollTop\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Zooms to the given level. Supports optional animation. Zooms\r\n   * the center when no coordinates are given.\r\n   *\r\n   * @param level {Number} Level to zoom to\r\n   * @param animate {Boolean ? false} Whether to use animation\r\n   * @param originLeft {Number ? null} Zoom in at given left coordinate\r\n   * @param originTop {Number ? null} Zoom in at given top coordinate\r\n   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\r\n   */\r\n  zoomTo: function(level, animate, originLeft, originTop, callback) {\r\n    var self = this;\r\n\r\n    if (!self.options.zooming) {\r\n      throw new Error('Zooming is not enabled!');\r\n    }\r\n\r\n    // Add callback if exists\r\n    if (callback) {\r\n      self.__zoomComplete = callback;\r\n    }\r\n\r\n    // Stop deceleration\r\n    if (self.__isDecelerating) {\r\n      core.effect.Animate.stop(self.__isDecelerating);\r\n      self.__isDecelerating = false;\r\n    }\r\n\r\n    var oldLevel = self.__zoomLevel;\r\n\r\n    // Normalize input origin to center of viewport if not defined\r\n    if (originLeft == null) {\r\n      originLeft = self.__clientWidth / 2;\r\n    }\r\n\r\n    if (originTop == null) {\r\n      originTop = self.__clientHeight / 2;\r\n    }\r\n\r\n    // Limit level according to configuration\r\n    level = Math.max(\r\n      Math.min(level, self.options.maxZoom),\r\n      self.options.minZoom\r\n    );\r\n\r\n    // Recompute maximum values while temporary tweaking maximum scroll ranges\r\n    self.__computeScrollMax(level);\r\n\r\n    // Recompute left and top coordinates based on new zoom level\r\n    var left = (originLeft + self.__scrollLeft) * level / oldLevel - originLeft;\r\n    var top = (originTop + self.__scrollTop) * level / oldLevel - originTop;\r\n\r\n    // Limit x-axis\r\n    if (left > self.__maxScrollLeft) {\r\n      left = self.__maxScrollLeft;\r\n    } else if (left < 0) {\r\n      left = 0;\r\n    }\r\n\r\n    // Limit y-axis\r\n    if (top > self.__maxScrollTop) {\r\n      top = self.__maxScrollTop;\r\n    } else if (top < 0) {\r\n      top = 0;\r\n    }\r\n\r\n    // Push values out\r\n    self.__publish(left, top, level, animate);\r\n  },\r\n\r\n  /**\r\n   * Zooms the content by the given factor.\r\n   *\r\n   * @param factor {Number} Zoom by given factor\r\n   * @param animate {Boolean ? false} Whether to use animation\r\n   * @param originLeft {Number ? 0} Zoom in at given left coordinate\r\n   * @param originTop {Number ? 0} Zoom in at given top coordinate\r\n   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\r\n   */\r\n  zoomBy: function(factor, animate, originLeft, originTop, callback) {\r\n    var self = this;\r\n\r\n    self.zoomTo(\r\n      self.__zoomLevel * factor,\r\n      animate,\r\n      originLeft,\r\n      originTop,\r\n      callback\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Scrolls to the given position. Respect limitations and snapping automatically.\r\n   *\r\n   * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>\r\n   * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>\r\n   * @param animate {Boolean?false} Whether the scrolling should happen using an animation\r\n   * @param zoom {Number?null} Zoom level to go to\r\n   */\r\n  scrollTo: function(left, top, animate, zoom, force) {\r\n    var self = this;\r\n\r\n    // Stop deceleration\r\n    if (self.__isDecelerating) {\r\n      core.effect.Animate.stop(self.__isDecelerating);\r\n      self.__isDecelerating = false;\r\n    }\r\n\r\n    // Correct coordinates based on new zoom level\r\n    if (zoom != null && zoom !== self.__zoomLevel) {\r\n      if (!self.options.zooming) {\r\n        throw new Error('Zooming is not enabled!');\r\n      }\r\n\r\n      left *= zoom;\r\n      top *= zoom;\r\n\r\n      // Recompute maximum values while temporary tweaking maximum scroll ranges\r\n      self.__computeScrollMax(zoom);\r\n    } else {\r\n      // Keep zoom when not defined\r\n      zoom = self.__zoomLevel;\r\n    }\r\n\r\n    if (!self.options.scrollingX && !force) {\r\n      left = self.__scrollLeft;\r\n    } else {\r\n      if (self.options.paging) {\r\n        left = Math.round(left / self.__clientWidth) * self.__clientWidth;\r\n      } else if (self.options.snapping) {\r\n        left = Math.round(left / self.__snapWidth) * self.__snapWidth;\r\n      }\r\n    }\r\n\r\n    if (!self.options.scrollingY && !force) {\r\n      top = self.__scrollTop;\r\n    } else {\r\n      if (self.options.paging) {\r\n        top = Math.round(top / self.__clientHeight) * self.__clientHeight;\r\n      } else if (self.options.snapping) {\r\n        top = Math.round(top / self.__snapHeight) * self.__snapHeight;\r\n      }\r\n    }\r\n\r\n    // Limit for allowed ranges\r\n    left = Math.max(Math.min(self.__maxScrollLeft, left), 0);\r\n    top = Math.max(Math.min(self.__maxScrollTop, top), 0);\r\n    // Don't animate when no change detected, still call publish to make sure\r\n    // that rendered position is really in-sync with internal data\r\n    if (left === self.__scrollLeft && top === self.__scrollTop) {\r\n      animate = false;\r\n    }\r\n\r\n    // Publish new values\r\n    if (!self.__isTracking) {\r\n      self.__publish(left, top, zoom, animate);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Scroll by the given offset\r\n   *\r\n   * @param left {Number ? 0} Scroll x-axis by given offset\r\n   * @param top {Number ? 0} Scroll x-axis by given offset\r\n   * @param animate {Boolean ? false} Whether to animate the given change\r\n   */\r\n  scrollBy: function(left, top, animate) {\r\n    var self = this;\r\n\r\n    var startLeft = self.__isAnimating\r\n      ? self.__scheduledLeft\r\n      : self.__scrollLeft;\r\n    var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;\r\n\r\n    self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);\r\n  },\r\n  getCurrentPage() {\r\n    this.__computePage();\r\n    return {\r\n      x: this.__currentPageX,\r\n      y: this.__currentPageY\r\n    };\r\n  },\r\n\r\n  goToPage({ x, y }, animate) {\r\n    if (isNaN(x)) {\r\n      x = 1;\r\n    }\r\n    if (isNaN(y)) {\r\n      y = 1;\r\n    }\r\n    this.scrollTo(\r\n      (x - 1) * this.__clientWidth,\r\n      (y - 1) * this.__clientHeight,\r\n      animate\r\n    );\r\n  },\r\n\r\n  /*\r\n\t---------------------------------------------------------------------------\r\n\t\tEVENT CALLBACKS\r\n\t---------------------------------------------------------------------------\r\n\t*/\r\n\r\n  /**\r\n   * Mouse wheel handler for zooming support\r\n   */\r\n  doMouseZoom: function(wheelDelta, timeStamp, pageX, pageY) {\r\n    var self = this;\r\n    var change = wheelDelta > 0 ? 0.97 : 1.03;\r\n\r\n    return self.zoomTo(\r\n      self.__zoomLevel * change,\r\n      false,\r\n      pageX - self.__clientLeft,\r\n      pageY - self.__clientTop\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Touch start handler for scrolling support\r\n   */\r\n  doTouchStart: function(touches, timeStamp) {\r\n    // Array-like check is enough here\r\n    if (touches.length == null) {\r\n      throw new Error('Invalid touch list: ' + touches);\r\n    }\r\n\r\n    if (timeStamp instanceof Date) {\r\n      timeStamp = timeStamp.valueOf();\r\n    }\r\n    if (typeof timeStamp !== 'number') {\r\n      throw new Error('Invalid timestamp value: ' + timeStamp);\r\n    }\r\n\r\n    var self = this;\r\n\r\n    // Reset interruptedAnimation flag\r\n    self.__interruptedAnimation = true;\r\n\r\n    // Stop deceleration\r\n    if (self.__isDecelerating) {\r\n      core.effect.Animate.stop(self.__isDecelerating);\r\n      self.__isDecelerating = false;\r\n      self.__interruptedAnimation = true;\r\n    }\r\n\r\n    // Stop animation\r\n    if (self.__isAnimating) {\r\n      core.effect.Animate.stop(self.__isAnimating);\r\n      self.__isAnimating = false;\r\n      self.__interruptedAnimation = true;\r\n    }\r\n\r\n    // Use center point when dealing with two fingers\r\n    var currentTouchLeft, currentTouchTop;\r\n    var isSingleTouch = touches.length === 1;\r\n    if (isSingleTouch) {\r\n      currentTouchLeft = touches[0].pageX;\r\n      currentTouchTop = touches[0].pageY;\r\n    } else {\r\n      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\r\n      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\r\n    }\r\n\r\n    // Store initial positions\r\n    self.__initialTouchLeft = currentTouchLeft;\r\n    self.__initialTouchTop = currentTouchTop;\r\n\r\n    // Store current zoom level\r\n    self.__zoomLevelStart = self.__zoomLevel;\r\n\r\n    // Store initial touch positions\r\n    self.__lastTouchLeft = currentTouchLeft;\r\n    self.__lastTouchTop = currentTouchTop;\r\n\r\n    // Store initial move time stamp\r\n    self.__lastTouchMove = timeStamp;\r\n\r\n    // Reset initial scale\r\n    self.__lastScale = 1;\r\n\r\n    // Reset locking flags\r\n    self.__enableScrollX = !isSingleTouch && self.options.scrollingX;\r\n    self.__enableScrollY = !isSingleTouch && self.options.scrollingY;\r\n\r\n    // Reset tracking flag\r\n    self.__isTracking = true;\r\n\r\n    // Reset deceleration complete flag\r\n    self.__didDecelerationComplete = false;\r\n\r\n    // Dragging starts directly with two fingers, otherwise lazy with an offset\r\n    self.__isDragging = !isSingleTouch;\r\n\r\n    // Some features are  in multi touch scenarios\r\n    self.__isSingleTouch = isSingleTouch;\r\n\r\n    // Clearing data structure\r\n    self.__positions = [];\r\n  },\r\n\r\n  /**\r\n   * Touch move handler for scrolling support\r\n   */\r\n  doTouchMove: function(touches, timeStamp, scale) {\r\n    // Array-like check is enough here\r\n    if (touches.length == null) {\r\n      throw new Error('Invalid touch list: ' + touches);\r\n    }\r\n\r\n    if (timeStamp instanceof Date) {\r\n      timeStamp = timeStamp.valueOf();\r\n    }\r\n    if (typeof timeStamp !== 'number') {\r\n      throw new Error('Invalid timestamp value: ' + timeStamp);\r\n    }\r\n\r\n    var self = this;\r\n\r\n    // Ignore event when tracking is not enabled (event might be outside of element)\r\n    if (!self.__isTracking) {\r\n      return;\r\n    }\r\n\r\n    var currentTouchLeft, currentTouchTop;\r\n\r\n    // Compute move based around of center of fingers\r\n    if (touches.length === 2) {\r\n      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\r\n      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\r\n    } else {\r\n      currentTouchLeft = touches[0].pageX;\r\n      currentTouchTop = touches[0].pageY;\r\n    }\r\n\r\n    var positions = self.__positions;\r\n\r\n    // Are we already is dragging mode?\r\n    if (self.__isDragging) {\r\n      // Compute move distance\r\n      var moveX = currentTouchLeft - self.__lastTouchLeft;\r\n      var moveY = currentTouchTop - self.__lastTouchTop;\r\n\r\n      // Read previous scroll position and zooming\r\n      var scrollLeft = self.__scrollLeft;\r\n      var scrollTop = self.__scrollTop;\r\n      var level = self.__zoomLevel;\r\n\r\n      // Work with scaling\r\n      if (scale != null && self.options.zooming) {\r\n        var oldLevel = level;\r\n\r\n        // Recompute level based on previous scale and new scale\r\n        level = level / self.__lastScale * scale;\r\n\r\n        // Limit level according to configuration\r\n        level = Math.max(\r\n          Math.min(level, self.options.maxZoom),\r\n          self.options.minZoom\r\n        );\r\n\r\n        // Only do further compution when change happened\r\n        if (oldLevel !== level) {\r\n          // Compute relative event position to container\r\n          var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;\r\n          var currentTouchTopRel = currentTouchTop - self.__clientTop;\r\n\r\n          // Recompute left and top coordinates based on new zoom level\r\n          scrollLeft =\r\n            (currentTouchLeftRel + scrollLeft) * level / oldLevel -\r\n            currentTouchLeftRel;\r\n          scrollTop =\r\n            (currentTouchTopRel + scrollTop) * level / oldLevel -\r\n            currentTouchTopRel;\r\n\r\n          // Recompute max scroll values\r\n          self.__computeScrollMax(level);\r\n        }\r\n      }\r\n\r\n      if (self.__enableScrollX) {\r\n        scrollLeft -= moveX * this.options.speedMultiplier;\r\n        var maxScrollLeft = self.__maxScrollLeft;\r\n\r\n        if (scrollLeft > maxScrollLeft || scrollLeft < 0) {\r\n          // Slow down on the edges\r\n          if (self.options.bouncing) {\r\n            scrollLeft += moveX / 2 * this.options.speedMultiplier;\r\n          } else if (scrollLeft > maxScrollLeft) {\r\n            scrollLeft = maxScrollLeft;\r\n          } else {\r\n            scrollLeft = 0;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Compute new vertical scroll position\r\n      if (self.__enableScrollY) {\r\n        scrollTop -= moveY * this.options.speedMultiplier;\r\n        var maxScrollTop = self.__maxScrollTop;\r\n\r\n        if (scrollTop > maxScrollTop || scrollTop < 0) {\r\n          // Slow down on the edges\r\n          if (self.options.bouncing) {\r\n            scrollTop += moveY / 2 * this.options.speedMultiplier;\r\n\r\n            // Support pull-to-refresh (only when only y is scrollable)\r\n            if (\r\n              !self.__enableScrollX &&\r\n              (self.__refreshHeight != null || self.__loadHeight != null)\r\n            ) {\r\n              if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {\r\n                self.__refreshActive = true;\r\n                if (self.__refreshActivate) {\r\n                  self.__refreshActivate();\r\n                }\r\n              } else if (\r\n                self.__refreshActive &&\r\n                scrollTop > -self.__refreshHeight\r\n              ) {\r\n                self.__refreshActive = false;\r\n                if (self.__refreshDeactivate) {\r\n                  self.__refreshDeactivate();\r\n                }\r\n              }\r\n              // handle for push-load\r\n              else if (\r\n                !self.__loadActive &&\r\n                scrollTop >= self.__maxScrollTop + self.__loadHeight\r\n              ) {\r\n                self.__loadActive = true;\r\n                if (self.__loadActivate) {\r\n                  self.__loadActivate();\r\n                }\r\n              } else if (\r\n                self.__refreshActive &&\r\n                scrollTop < self.__maxScrollTop + self.__loadHeight\r\n              ) {\r\n                self.__loadActive = false;\r\n                if (self.__loadDeactivate) {\r\n                  self.__loadDeactivate();\r\n                }\r\n              }\r\n            }\r\n          } else if (scrollTop > maxScrollTop) {\r\n            scrollTop = maxScrollTop;\r\n          } else {\r\n            scrollTop = 0;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Keep list from growing infinitely (holding min 10, max 20 measure points)\r\n      if (positions.length > 60) {\r\n        positions.splice(0, 30);\r\n      }\r\n\r\n      // Track scroll movement for decleration\r\n      positions.push(scrollLeft, scrollTop, timeStamp);\r\n\r\n      // Sync scroll position\r\n      self.__publish(scrollLeft, scrollTop, level);\r\n\r\n      // Otherwise figure out whether we are switching into dragging mode now.\r\n    } else {\r\n      var minimumTrackingForScroll = self.options.locking ? 3 : 0;\r\n      var minimumTrackingForDrag = 5;\r\n\r\n      var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);\r\n      var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);\r\n\r\n      self.__enableScrollX =\r\n        self.options.scrollingX && distanceX >= minimumTrackingForScroll;\r\n      self.__enableScrollY =\r\n        self.options.scrollingY && distanceY >= minimumTrackingForScroll;\r\n\r\n      positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);\r\n\r\n      self.__isDragging =\r\n        (self.__enableScrollX || self.__enableScrollY) &&\r\n        (distanceX >= minimumTrackingForDrag ||\r\n          distanceY >= minimumTrackingForDrag);\r\n      if (self.__isDragging) {\r\n        self.__interruptedAnimation = false;\r\n      }\r\n    }\r\n\r\n    // Update last touch positions and time stamp for next event\r\n    self.__lastTouchLeft = currentTouchLeft;\r\n    self.__lastTouchTop = currentTouchTop;\r\n    self.__lastTouchMove = timeStamp;\r\n    self.__lastScale = scale;\r\n  },\r\n\r\n  /**\r\n   * Touch end handler for scrolling support\r\n   */\r\n  doTouchEnd: function(timeStamp) {\r\n    if (timeStamp instanceof Date) {\r\n      timeStamp = timeStamp.valueOf();\r\n    }\r\n    if (typeof timeStamp !== 'number') {\r\n      throw new Error('Invalid timestamp value: ' + timeStamp);\r\n    }\r\n\r\n    var self = this;\r\n\r\n    // Ignore event when tracking is not enabled (no touchstart event on element)\r\n    // This is required as this listener ('touchmove') sits on the document and not on the element itself.\r\n    if (!self.__isTracking) {\r\n      return;\r\n    }\r\n\r\n    // Not touching anymore (when two finger hit the screen there are two touch end events)\r\n    self.__isTracking = false;\r\n\r\n    // Be sure to reset the dragging flag now. Here we also detect whether\r\n    // the finger has moved fast enough to switch into a deceleration animation.\r\n    if (self.__isDragging) {\r\n      // Reset dragging flag\r\n      self.__isDragging = false;\r\n\r\n      // Start deceleration\r\n      // Verify that the last move detected was in some relevant time frame\r\n      if (\r\n        self.__isSingleTouch &&\r\n        self.options.animating &&\r\n        timeStamp - self.__lastTouchMove <= 100\r\n      ) {\r\n        // Then figure out what the scroll position was about 100ms ago\r\n        var positions = self.__positions;\r\n        var endPos = positions.length - 1;\r\n        var startPos = endPos;\r\n\r\n        // Move pointer to position measured 100ms ago\r\n        for (\r\n          var i = endPos;\r\n          i > 0 && positions[i] > self.__lastTouchMove - 100;\r\n          i -= 3\r\n        ) {\r\n          startPos = i;\r\n        }\r\n\r\n        // If start and stop position is identical in a 100ms timeframe,\r\n        // we cannot compute any useful deceleration.\r\n        if (startPos !== endPos) {\r\n          // Compute relative movement between these two points\r\n          var timeOffset = positions[endPos] - positions[startPos];\r\n          var movedLeft = self.__scrollLeft - positions[startPos - 2];\r\n          var movedTop = self.__scrollTop - positions[startPos - 1];\r\n\r\n          // Based on 50ms compute the movement to apply for each render step\r\n          self.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);\r\n          self.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60);\r\n\r\n          // How much velocity is required to start the deceleration\r\n          var minVelocityToStartDeceleration =\r\n            self.options.paging || self.options.snapping ? 4 : 1;\r\n\r\n          // Verify that we have enough velocity to start deceleration\r\n          if (\r\n            Math.abs(self.__decelerationVelocityX) >\r\n              minVelocityToStartDeceleration ||\r\n            Math.abs(self.__decelerationVelocityY) >\r\n              minVelocityToStartDeceleration\r\n          ) {\r\n            // Deactivate pull-to-refresh when decelerating\r\n            if (!self.__refreshActive && !self.__loadActive) {\r\n              self.__startDeceleration(timeStamp);\r\n            }\r\n          } else {\r\n            self.__scrollComplete();\r\n          }\r\n        } else {\r\n          self.__scrollComplete();\r\n        }\r\n      } else if (timeStamp - self.__lastTouchMove > 100) {\r\n        self.__scrollComplete();\r\n      }\r\n    }\r\n\r\n    // If this was a slower move it is per default non decelerated, but this\r\n    // still means that we want snap back to the bounds which is done here.\r\n    // This is placed outside the condition above to improve edge case stability\r\n    // e.g. touchend fired without enabled dragging. This should normally do not\r\n    // have modified the scroll positions or even showed the scrollbars though.\r\n    if (!self.__isDecelerating) {\r\n      if (self.__refreshActive && self.__refreshStart) {\r\n        // Use publish instead of scrollTo to allow scrolling to out of boundary position\r\n        // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\r\n        self.__publish(\r\n          self.__scrollLeft,\r\n          -self.__refreshHeight,\r\n          self.__zoomLevel,\r\n          true\r\n        );\r\n\r\n        if (self.__refreshStart) {\r\n          self.__refreshStart();\r\n        }\r\n      } else if (self.__loadActive && self.__loadStart) {\r\n        // Use publish instead of scrollTo to allow scrolling to out of boundary position\r\n        // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\r\n        self.__publish(\r\n          self.__scrollLeft,\r\n          self.__maxScrollTop + self.__loadHeight,\r\n          self.__zoomLevel,\r\n          true\r\n        );\r\n\r\n        if (self.__loadStart) {\r\n          self.__loadStart();\r\n        }\r\n      } else {\r\n        if (self.__interruptedAnimation || self.__isDragging) {\r\n          self.__scrollComplete();\r\n        }\r\n        self.scrollTo(\r\n          self.__scrollLeft,\r\n          self.__scrollTop,\r\n          true,\r\n          self.__zoomLevel\r\n        );\r\n\r\n        // Directly signalize deactivation (nothing todo on refresh?)\r\n        if (self.__refreshActive) {\r\n          self.__refreshActive = false;\r\n          if (self.__refreshDeactivate) {\r\n            self.__refreshDeactivate();\r\n          }\r\n        } else if (self.__loadActive) {\r\n          self.__loadActive = false;\r\n          if (self.__loadDeactivate) {\r\n            self.__loadDeactivate();\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fully cleanup list\r\n    self.__positions.length = 0;\r\n  },\r\n\r\n  /** Handle for scroll/publish */\r\n  onScroll: NOOP,\r\n\r\n  stop: function() {\r\n    var self = this;\r\n\r\n    self.__disable = true;\r\n  },\r\n  start: function() {\r\n    self.__disable = true;\r\n  },\r\n  /*\r\n\t---------------------------------------------------------------------------\r\n\t\tPRIVATE API\r\n\t---------------------------------------------------------------------------\r\n\t*/\r\n\r\n  /**\r\n   * Applies the scroll position to the content element\r\n   *\r\n   * @param left {Number} Left scroll position\r\n   * @param top {Number} Top scroll position\r\n   * @param animate {Boolean?false} Whether animation should be used to move to the new coordinates\r\n   */\r\n  __publish: function(left, top, zoom, animate) {\r\n    var self = this;\r\n    if (self.__disable) {\r\n      return;\r\n    }\r\n    if (isNaN(left)) {\r\n      left = this.__scrollLeft;\r\n    }\r\n    if (isNaN(top)) {\r\n      top = this.__scrollTop;\r\n    }\r\n    // Remember whether we had an animation, then we try to continue based on the current \"drive\" of the animation\r\n    var wasAnimating = self.__isAnimating;\r\n    if (wasAnimating) {\r\n      core.effect.Animate.stop(wasAnimating);\r\n      self.__isAnimating = false;\r\n    }\r\n\r\n    if (animate && self.options.animating) {\r\n      // Keep scheduled positions for scrollBy/zoomBy functionality\r\n      self.__scheduledLeft = left;\r\n      self.__scheduledTop = top;\r\n      self.__scheduledZoom = zoom;\r\n\r\n      var oldLeft = self.__scrollLeft;\r\n      var oldTop = self.__scrollTop;\r\n      var oldZoom = self.__zoomLevel;\r\n\r\n      var diffLeft = left - oldLeft;\r\n      var diffTop = top - oldTop;\r\n      var diffZoom = zoom - oldZoom;\r\n\r\n      var step = function(percent, now, render) {\r\n        if (render) {\r\n          self.__scrollLeft = oldLeft + diffLeft * percent;\r\n          self.__scrollTop = oldTop + diffTop * percent;\r\n          self.__zoomLevel = oldZoom + diffZoom * percent;\r\n\r\n          // Push values out\r\n          if (self.__callback) {\r\n            self.__callback(\r\n              self.__scrollLeft,\r\n              self.__scrollTop,\r\n              self.__zoomLevel\r\n            );\r\n            self.onScroll();\r\n          }\r\n        }\r\n      };\r\n\r\n      var verify = function(id) {\r\n        return self.__isAnimating === id;\r\n      };\r\n\r\n      var completed = function(\r\n        renderedFramesPerSecond,\r\n        animationId,\r\n        wasFinished\r\n      ) {\r\n        if (animationId === self.__isAnimating) {\r\n          self.__isAnimating = false;\r\n        }\r\n        if (self.__didDecelerationComplete || wasFinished) {\r\n          self.__scrollComplete();\r\n        }\r\n\r\n        if (self.options.zooming) {\r\n          self.__computeScrollMax();\r\n          if (self.__zoomComplete) {\r\n            self.__zoomComplete();\r\n            self.__zoomComplete = null;\r\n          }\r\n        }\r\n      };\r\n\r\n      // When continuing based on previous animation we choose an ease-out animation instead of ease-in-out\r\n      self.__isAnimating = core.effect.Animate.start(\r\n        step,\r\n        verify,\r\n        completed,\r\n        self.options.animationDuration,\r\n        wasAnimating ? animatingMethod : noAnimatingMethod\r\n      );\r\n    } else {\r\n      self.__scheduledLeft = self.__scrollLeft = left;\r\n      self.__scheduledTop = self.__scrollTop = top;\r\n      self.__scheduledZoom = self.__zoomLevel = zoom;\r\n\r\n      // Push values out\r\n      if (self.__callback) {\r\n        self.__callback(left, top, zoom);\r\n        self.onScroll();\r\n      }\r\n\r\n      // Fix max scroll ranges\r\n      if (self.options.zooming) {\r\n        self.__computeScrollMax();\r\n        if (self.__zoomComplete) {\r\n          self.__zoomComplete();\r\n          self.__zoomComplete = null;\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Recomputes scroll minimum values based on client dimensions and content dimensions.\r\n   */\r\n  __computeScrollMax: function(zoomLevel) {\r\n    var self = this;\r\n\r\n    if (zoomLevel == null) {\r\n      zoomLevel = self.__zoomLevel;\r\n    }\r\n\r\n    self.__maxScrollLeft = Math.max(\r\n      self.__contentWidth * zoomLevel - self.__clientWidth,\r\n      0\r\n    );\r\n    self.__maxScrollTop = Math.max(\r\n      self.__contentHeight * zoomLevel - self.__clientHeight,\r\n      0\r\n    );\r\n  },\r\n  /** compute current page total page */\r\n  __computePage: function() {\r\n    var self = this;\r\n    var clientWidth = self.__clientWidth;\r\n    var clientHeight = self.__clientHeight;\r\n    var left = self.__scrollLeft;\r\n    var top = self.__scrollTop;\r\n    self.__totalXPage = Math.ceil(self.__contentWidth / clientWidth);\r\n    self.__currentPageX = Math.ceil(left / clientWidth + 1);\r\n    self.__totalYPage = Math.ceil(self.__contentHeight / clientHeight);\r\n    self.__currentPageY = Math.ceil(top / clientHeight + 1);\r\n  },\r\n  /** complete scroll*/\r\n  __scrollComplete: function() {\r\n    var self = this;\r\n    self.options.scrollingComplete();\r\n  },\r\n  /*\r\n\t---------------------------------------------------------------------------\r\n\t\tANIMATION (DECELERATION) SUPPORT\r\n\t---------------------------------------------------------------------------\r\n\t*/\r\n\r\n  /**\r\n   * Called when a touch sequence end and the speed of the finger was high enough\r\n   * to switch into deceleration mode.\r\n   */\r\n  __startDeceleration: function() {\r\n    var self = this;\r\n\r\n    if (self.options.paging) {\r\n      var scrollLeft = Math.max(\r\n        Math.min(self.__scrollLeft, self.__maxScrollLeft),\r\n        0\r\n      );\r\n      var scrollTop = Math.max(\r\n        Math.min(self.__scrollTop, self.__maxScrollTop),\r\n        0\r\n      );\r\n      var clientWidth = self.__clientWidth;\r\n      var clientHeight = self.__clientHeight;\r\n\r\n      // We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.\r\n      // Each page should have exactly the size of the client area.\r\n      self.__minDecelerationScrollLeft =\r\n        Math.floor(scrollLeft / clientWidth) * clientWidth;\r\n      self.__minDecelerationScrollTop =\r\n        Math.floor(scrollTop / clientHeight) * clientHeight;\r\n      self.__maxDecelerationScrollLeft =\r\n        Math.ceil(scrollLeft / clientWidth) * clientWidth;\r\n      self.__maxDecelerationScrollTop =\r\n        Math.ceil(scrollTop / clientHeight) * clientHeight;\r\n    } else {\r\n      self.__minDecelerationScrollLeft = 0;\r\n      self.__minDecelerationScrollTop = 0;\r\n      self.__maxDecelerationScrollLeft = self.__maxScrollLeft;\r\n      self.__maxDecelerationScrollTop = self.__maxScrollTop;\r\n    }\r\n\r\n    // Wrap class method\r\n    var step = function(percent, now, render) {\r\n      self.__stepThroughDeceleration(render);\r\n    };\r\n\r\n    // How much velocity is required to keep the deceleration running\r\n    var minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.001;\r\n\r\n    // Detect whether it's still worth to continue animating steps\r\n    // If we are already slow enough to not being user perceivable anymore, we stop the whole process here.\r\n    var verify = function() {\r\n      var shouldContinue =\r\n        Math.abs(self.__decelerationVelocityX) >=\r\n          minVelocityToKeepDecelerating ||\r\n        Math.abs(self.__decelerationVelocityY) >= minVelocityToKeepDecelerating;\r\n      if (!shouldContinue) {\r\n        self.__didDecelerationComplete = true;\r\n      }\r\n      return shouldContinue;\r\n    };\r\n\r\n    var completed = function() {\r\n      if (!self.__isDecelerating) {\r\n        return;\r\n      }\r\n      self.__isDecelerating = false;\r\n      if (self.__didDecelerationComplete) {\r\n        self.__scrollComplete();\r\n      }\r\n\r\n      // Animate to grid when snapping is active, otherwise just fix out-of-boundary positions\r\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);\r\n    };\r\n\r\n    // Start animation and switch on flag\r\n    self.__isDecelerating = core.effect.Animate.start(step, verify, completed);\r\n  },\r\n\r\n  /**\r\n   * Called on every step of the animation\r\n   *\r\n   * @param inMemory {Boolean?false} Whether to not render the current step, but keep it in memory only. Used internally only!\r\n   */\r\n  __stepThroughDeceleration: function(render) {\r\n    var self = this;\r\n\r\n    //\r\n    // COMPUTE NEXT SCROLL POSITION\r\n    //\r\n\r\n    // Add deceleration to scroll position\r\n    var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;\r\n    var scrollTop = self.__scrollTop + self.__decelerationVelocityY;\r\n\r\n    //\r\n    // HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE\r\n    //\r\n\r\n    if (!self.options.bouncing) {\r\n      var scrollLeftFixed = Math.max(\r\n        Math.min(self.__maxDecelerationScrollLeft, scrollLeft),\r\n        self.__minDecelerationScrollLeft\r\n      );\r\n      if (scrollLeftFixed !== scrollLeft) {\r\n        scrollLeft = scrollLeftFixed;\r\n        self.__decelerationVelocityX = 0;\r\n      }\r\n\r\n      var scrollTopFixed = Math.max(\r\n        Math.min(self.__maxDecelerationScrollTop, scrollTop),\r\n        self.__minDecelerationScrollTop\r\n      );\r\n      if (scrollTopFixed !== scrollTop) {\r\n        scrollTop = scrollTopFixed;\r\n        self.__decelerationVelocityY = 0;\r\n      }\r\n    }\r\n\r\n    //\r\n    // UPDATE SCROLL POSITION\r\n    //\r\n\r\n    if (render) {\r\n      self.__publish(scrollLeft, scrollTop, self.__zoomLevel);\r\n    } else {\r\n      self.__scrollLeft = scrollLeft;\r\n      self.__scrollTop = scrollTop;\r\n    }\r\n\r\n    //\r\n    // SLOW DOWN\r\n    //\r\n\r\n    // Slow down velocity on every iteration\r\n    if (!self.options.paging) {\r\n      // This is the factor applied to every iteration of the animation\r\n      // to slow down the process. This should emulate natural behavior where\r\n      // objects slow down when the initiator of the movement is removed\r\n      var frictionFactor = 0.95;\r\n\r\n      self.__decelerationVelocityX *= frictionFactor;\r\n      self.__decelerationVelocityY *= frictionFactor;\r\n    }\r\n\r\n    //\r\n    // BOUNCING SUPPORT\r\n    //\r\n\r\n    if (self.options.bouncing) {\r\n      var scrollOutsideX = 0;\r\n      var scrollOutsideY = 0;\r\n\r\n      // This configures the amount of change applied to deceleration/acceleration when reaching boundaries\r\n      var penetrationDeceleration = self.options.penetrationDeceleration;\r\n      var penetrationAcceleration = self.options.penetrationAcceleration;\r\n\r\n      // Check limits\r\n      if (scrollLeft < self.__minDecelerationScrollLeft) {\r\n        scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;\r\n      } else if (scrollLeft > self.__maxDecelerationScrollLeft) {\r\n        scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;\r\n      }\r\n\r\n      if (scrollTop < self.__minDecelerationScrollTop) {\r\n        scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;\r\n      } else if (scrollTop > self.__maxDecelerationScrollTop) {\r\n        scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;\r\n      }\r\n\r\n      // Slow down until slow enough, then flip back to snap position\r\n      if (scrollOutsideX !== 0) {\r\n        if (scrollOutsideX * self.__decelerationVelocityX <= 0) {\r\n          self.__decelerationVelocityX +=\r\n            scrollOutsideX * penetrationDeceleration;\r\n        } else {\r\n          self.__decelerationVelocityX =\r\n            scrollOutsideX * penetrationAcceleration;\r\n        }\r\n      }\r\n\r\n      if (scrollOutsideY !== 0) {\r\n        if (scrollOutsideY * self.__decelerationVelocityY <= 0) {\r\n          self.__decelerationVelocityY +=\r\n            scrollOutsideY * penetrationDeceleration;\r\n        } else {\r\n          self.__decelerationVelocityY =\r\n            scrollOutsideY * penetrationAcceleration;\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n// Copy over members to prototype\r\nfor (var key in members) {\r\n  Scroller.prototype[key] = members[key];\r\n}\r\n","import Scroller from '../../third-party/scroller';\r\nimport { render } from '../../third-party/scroller/render';\r\nimport { listenContainer } from '../../third-party/scroller/listener';\r\n\r\n/**\r\n * @description refresh and load callback\r\n */\r\nfunction createStateCallbacks(type, stageName, vm, tipDom) {\r\n  const listeners = vm.$listeners;\r\n\r\n  let activateCallback = () => {\r\n    vm.vuescroll.state[stageName] = 'active';\r\n  };\r\n\r\n  let deactivateCallback = () => {\r\n    vm.vuescroll.state[stageName] = 'deactive';\r\n  };\r\n\r\n  let startCallback = () => {\r\n    vm.vuescroll.state[stageName] = 'start';\r\n    setTimeout(() => {\r\n      vm.scroller.finishRefreshOrLoad();\r\n    }, 2000);\r\n  };\r\n\r\n  let beforeDeactivateCallback = done => {\r\n    vm.vuescroll.state[stageName] = 'beforeDeactive';\r\n    setTimeout(function() {\r\n      done();\r\n    }, 500);\r\n  };\r\n  /* istanbul ignore if */\r\n  if (listeners[type + '-activate']) {\r\n    activateCallback = () => {\r\n      vm.vuescroll.state[stageName] = 'active';\r\n      vm.$emit(type + '-activate', vm, tipDom);\r\n    };\r\n  }\r\n  /* istanbul ignore if */\r\n  if (listeners[type + '-before-deactivate']) {\r\n    beforeDeactivateCallback = done => {\r\n      vm.vuescroll.state[stageName] = 'beforeDeactive';\r\n      vm.$emit(type + '-before-deactivate', vm, tipDom, done.bind(vm.scroller));\r\n    };\r\n  }\r\n  /* istanbul ignore if */\r\n  if (listeners[type + '-deactivate']) {\r\n    deactivateCallback = () => {\r\n      vm.vuescroll.state[stageName] = 'deactive';\r\n      vm.$emit(type + '-deactivate', vm, tipDom);\r\n    };\r\n  }\r\n  /* istanbul ignore if */\r\n  if (listeners[type + '-start']) {\r\n    startCallback = () => {\r\n      vm.vuescroll.state[stageName] = 'start';\r\n      vm.$emit(\r\n        type + '-start',\r\n        vm,\r\n        tipDom,\r\n        vm.scroller.finishRefreshOrLoad.bind(vm.scroller)\r\n      );\r\n    };\r\n  }\r\n\r\n  return {\r\n    activateCallback,\r\n    deactivateCallback,\r\n    startCallback,\r\n    beforeDeactivateCallback\r\n  };\r\n}\r\n\r\nexport default {\r\n  methods: {\r\n    // update scrollbar's size and pos  while in slide mode.\r\n    updateScroller() {\r\n      const clientWidth = this.$el.clientWidth;\r\n      const clientHeight = this.$el.clientHeight;\r\n      let contentWidth = this.scrollPanelElm.scrollWidth;\r\n      let contentHeight = this.scrollPanelElm.scrollHeight;\r\n      let refreshHeight = 0;\r\n      let loadHeight = 0;\r\n      // If the refresh option is true,let's  give a \"margin-top\" style to\r\n      // the refresh-tip dom. let it to be invisible when doesn't trigger\r\n      // refresh.\r\n      if (this.mergedOptions.vuescroll.pullRefresh.enable) {\r\n        const refreshDom =\r\n          this.$refs['refreshDom'].elm || this.$refs['refreshDom'];\r\n        refreshHeight = refreshDom.offsetHeight;\r\n        if (!refreshDom.style.marginTop) {\r\n          refreshDom.style.marginTop = -refreshHeight + 'px';\r\n        }\r\n      }\r\n      if (this.mergedOptions.vuescroll.pushLoad.enable) {\r\n        const loadDom = this.$refs['loadDom'].elm || this.$refs['loadDom'];\r\n        loadHeight = loadDom.offsetHeight;\r\n        //  hide the trailing load dom..\r\n        contentHeight -= loadHeight;\r\n      }\r\n      this.scroller.setDimensions(\r\n        clientWidth,\r\n        clientHeight,\r\n        contentWidth,\r\n        contentHeight,\r\n        false\r\n      );\r\n    },\r\n    registryScroller() {\r\n      const preventDefault = this.mergedOptions.vuescroll.scroller\r\n        .preventDefault;\r\n      const paging = this.mergedOptions.vuescroll.paging;\r\n      const snapping = this.mergedOptions.vuescroll.snapping.enable;\r\n      // disale zooming when refresh or load enabled\r\n      let zooming =\r\n        !this.refreshLoad &&\r\n        !paging &&\r\n        !snapping &&\r\n        this.mergedOptions.vuescroll.zooming;\r\n      const { scrollingY, scrollingX } = this.mergedOptions.scrollPanel;\r\n      // hadnle for scroll complete\r\n      const scrollingComplete = () => {\r\n        this.updateBarStateAndEmitEvent('handle-scroll-complete');\r\n      };\r\n      // Initialize Scroller\r\n      this.scroller = new Scroller(render(this.scrollPanelElm, window, 'px'), {\r\n        ...this.mergedOptions.vuescroll.scroller,\r\n        zooming,\r\n        scrollingY,\r\n        scrollingX: scrollingX && !this.refreshLoad,\r\n        animationDuration: this.mergedOptions.scrollPanel.speed,\r\n        paging,\r\n        snapping,\r\n        scrollingComplete\r\n      });\r\n      // if snapping enabled\r\n      // we should set snap size\r\n      if (snapping) {\r\n        this.scroller.setSnapSize(\r\n          this.mergedOptions.vuescroll.snapping.width,\r\n          this.mergedOptions.vuescroll.snapping.height\r\n        );\r\n      }\r\n      var rect = this.$el.getBoundingClientRect();\r\n      this.scroller.setPosition(\r\n        rect.left + this.$el.clientLeft,\r\n        rect.top + this.$el.clientTop\r\n      );\r\n      const cb = listenContainer(\r\n        this.$el,\r\n        this.scroller,\r\n        eventType => {\r\n          // Thie is to dispatch the event from the scroller.\r\n          // to let vuescroll refresh the dom\r\n          switch (eventType) {\r\n          case 'mousedown':\r\n            this.vuescroll.state.isDragging = true;\r\n            break;\r\n          case 'onscroll':\r\n            this.handleScroll(false);\r\n            break;\r\n          case 'mouseup':\r\n            this.vuescroll.state.isDragging = false;\r\n            break;\r\n          }\r\n        },\r\n        zooming,\r\n        preventDefault\r\n      );\r\n      // registry refresh\r\n      if (this.mergedOptions.vuescroll.pullRefresh.enable) {\r\n        this.registryEvent('refresh');\r\n      }\r\n      // registry load\r\n      if (this.mergedOptions.vuescroll.pushLoad.enable) {\r\n        this.registryEvent('load');\r\n      }\r\n      this.updateScroller();\r\n      return cb;\r\n    },\r\n    updateSlideModeBarState() {\r\n      // update slide mode scrollbars' state\r\n      let heightPercentage, widthPercentage;\r\n      const vuescroll = this.$el;\r\n      const scroller = this.scroller;\r\n      let outerLeft = 0;\r\n      let outerTop = 0;\r\n      const clientWidth = this.$el.clientHeight;\r\n      const clientHeight = this.$el.clientHeight;\r\n      const contentWidth = clientWidth + this.scroller.__maxScrollLeft;\r\n      const contentHeight = clientHeight + this.scroller.__maxScrollTop;\r\n      const __enableScrollX =\r\n        clientWidth < contentWidth && this.mergedOptions.scrollPanel.scrollingX;\r\n      const __enableScrollY =\r\n        clientHeight < contentHeight &&\r\n        this.mergedOptions.scrollPanel.scrollingY;\r\n      // out of horizontal bountry\r\n      if (__enableScrollX) {\r\n        /* istanbul ignore if */\r\n        if (scroller.__scrollLeft < 0) {\r\n          outerLeft = -scroller.__scrollLeft;\r\n        } /* istanbul ignore next */ else if (\r\n          scroller.__scrollLeft > scroller.__maxScrollLeft\r\n        ) {\r\n          outerLeft = scroller.__scrollLeft - scroller.__maxScrollLeft;\r\n        }\r\n      }\r\n      // out of vertical bountry\r\n      if (__enableScrollY) {\r\n        if (scroller.__scrollTop < 0) {\r\n          outerTop = -scroller.__scrollTop;\r\n        } else if (scroller.__scrollTop > scroller.__maxScrollTop) {\r\n          outerTop = scroller.__scrollTop - scroller.__maxScrollTop;\r\n        }\r\n      }\r\n      heightPercentage = (clientHeight * 100) / (contentHeight + outerTop);\r\n      widthPercentage = (clientWidth * 100) / (contentWidth + outerLeft);\r\n      const scrollTop = Math.min(\r\n        Math.max(0, scroller.__scrollTop),\r\n        scroller.__maxScrollTop\r\n      );\r\n      const scrollLeft = Math.min(\r\n        Math.max(0, scroller.__scrollLeft),\r\n        scroller.__maxScrollLeft\r\n      );\r\n      this.bar.vBar.state.posValue =\r\n        ((scrollTop + outerTop) * 100) / vuescroll.clientHeight;\r\n      this.bar.hBar.state.posValue =\r\n        ((scrollLeft + outerLeft) * 100) / vuescroll.clientWidth;\r\n      /* istanbul ignore if */\r\n      if (scroller.__scrollLeft < 0) {\r\n        this.bar.hBar.state.posValue = 0;\r\n      }\r\n      if (scroller.__scrollTop < 0) {\r\n        this.bar.vBar.state.posValue = 0;\r\n      }\r\n      this.bar.vBar.state.size =\r\n        heightPercentage < 100 ? heightPercentage + '%' : 0;\r\n      this.bar.hBar.state.size =\r\n        widthPercentage < 100 ? widthPercentage + '%' : 0;\r\n    },\r\n    registryEvent(type) {\r\n      const domName = type == 'refresh' ? 'refreshDom' : 'loadDom';\r\n      const activateFunc =\r\n        type == 'refresh'\r\n          ? this.scroller.activatePullToRefresh\r\n          : this.scroller.activatePushToLoad;\r\n      const stageName = type == 'refresh' ? 'refreshStage' : 'loadStage';\r\n      const tipDom = this.$refs[domName].elm || this.$refs[domName];\r\n      const cbs = createStateCallbacks(type, stageName, this, tipDom);\r\n      const height = tipDom.offsetHeight;\r\n      activateFunc.bind(this.scroller)(height, cbs);\r\n    }\r\n  }\r\n};\r\n","export default {\r\n  vertical: {\r\n    size: 'height',\r\n    opsSize: 'width',\r\n    posName: 'top',\r\n    opposName: 'bottom',\r\n    page: 'pageY',\r\n    scroll: 'scrollTop',\r\n    scrollSize: 'scrollHeight',\r\n    offset: 'offsetHeight',\r\n    client: 'clientY',\r\n    axis: 'Y'\r\n  },\r\n  horizontal: {\r\n    size: 'width',\r\n    opsSize: 'height',\r\n    posName: 'left',\r\n    opposName: 'right',\r\n    page: 'pageX',\r\n    scroll: 'scrollLeft',\r\n    scrollSize: 'scrollWidth',\r\n    offset: 'offsetWidth',\r\n    client: 'clientX',\r\n    axis: 'X'\r\n  }\r\n};\r\n","import scrollMap from '../../shared/scroll-map';\r\nimport { eventCenter, isSupportTouch, getRealParent } from '../../util';\r\n\r\nconst colorCache = {};\r\nconst rgbReg = /rgb\\(/;\r\nconst extractRgbColor = /rgb\\((.*)\\)/;\r\n\r\n/* istanbul ignore next */\r\nfunction createMouseEvent(ctx) {\r\n  const parent = getRealParent(ctx);\r\n\r\n  function mousedown(e) {\r\n    e.stopImmediatePropagation();\r\n    document.onselectstart = () => false;\r\n    ctx.axisStartPos =\r\n      e[ctx.bar.client] -\r\n      ctx.$refs['inner'].getBoundingClientRect()[ctx.bar.posName];\r\n    // tell parent that the mouse has been down.\r\n    ctx.$emit('setBarClick', true);\r\n    eventCenter(document, 'mousemove', mousemove);\r\n    eventCenter(document, 'mouseup', mouseup);\r\n  }\r\n  function mousemove(e) {\r\n    if (!ctx.axisStartPos) {\r\n      return;\r\n    }\r\n    const delta =\r\n      e[ctx.bar.client] - ctx.$el.getBoundingClientRect()[ctx.bar.posName];\r\n    const percent = (delta - ctx.axisStartPos) / ctx.$el[ctx.bar.offset];\r\n    parent.scrollTo(\r\n      {\r\n        [ctx.bar.axis.toLowerCase()]:\r\n          parent.$refs['scrollPanel'].$el[ctx.bar.scrollSize] * percent\r\n      },\r\n      false\r\n    );\r\n  }\r\n  function mouseup() {\r\n    ctx.$emit('setBarClick', false);\r\n    document.onselectstart = null;\r\n    parent.hideBar();\r\n    ctx.axisStartPos = 0;\r\n    eventCenter(document, 'mousemove', mousemove, false, 'off');\r\n    eventCenter(document, 'mouseup', mouseup, false, 'off');\r\n  }\r\n\r\n  return mousedown;\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction createTouchEvent(ctx) {\r\n  function touchstart(e) {\r\n    e.stopImmediatePropagation();\r\n    e.preventDefault();\r\n    document.onselectstart = () => false;\r\n    ctx.axisStartPos =\r\n      e.touches[0][ctx.bar.client] -\r\n      ctx.$refs['inner'].getBoundingClientRect()[ctx.bar.posName];\r\n    // tell parent that the mouse has been down.\r\n    ctx.$emit('setBarClick', true);\r\n    eventCenter(document, 'touchmove', touchmove);\r\n    eventCenter(document, 'touchend', touchend);\r\n  }\r\n  function touchmove(e) {\r\n    if (!ctx.axisStartPos) {\r\n      return;\r\n    }\r\n    const delta =\r\n      e.touches[0][ctx.bar.client] -\r\n      ctx.$el.getBoundingClientRect()[ctx.bar.posName];\r\n    const percent = (delta - ctx.axisStartPos) / ctx.$el[ctx.bar.offset];\r\n    parent.scrollTo(\r\n      {\r\n        [ctx.bar.axis.toLowerCase()]:\r\n          parent.$refs['scrollPanel'].$el[ctx.bar.scrollSize] * percent\r\n      },\r\n      false\r\n    );\r\n  }\r\n  function touchend() {\r\n    ctx.$emit('setBarClick', false);\r\n    document.onselectstart = null;\r\n    ctx.$parent.hideBar();\r\n    ctx.axisStartPos = 0;\r\n    eventCenter(document, 'touchmove', touchmove, false, 'off');\r\n    eventCenter(document, 'touchend', touchend, false, 'off');\r\n  }\r\n  return touchstart;\r\n}\r\n\r\nfunction getRgbAColor(color, opacity) {\r\n  const id = color + '&' + opacity;\r\n  if (colorCache[id]) {\r\n    return colorCache[id];\r\n  }\r\n\r\n  const div = document.createElement('div');\r\n  div.style.background = color;\r\n  document.body.appendChild(div);\r\n  const computedColor = window.getComputedStyle(div).backgroundColor;\r\n  document.body.removeChild(div);\r\n\r\n  /* istanbul ignore if */\r\n  if (!rgbReg.test(computedColor)) {\r\n    return color;\r\n  }\r\n\r\n  return (colorCache[id] = `rgba(${\r\n    extractRgbColor.exec(computedColor)[1]\r\n  }, ${opacity})`);\r\n}\r\n\r\n/* istanbul ignore next */\r\nfunction handleClickTrack(e) {\r\n  const ctx = this;\r\n  const parent = getRealParent(this);\r\n  const { client, offset, posName, axis } = ctx.bar;\r\n  const inner = ctx.$refs['inner'];\r\n  const barOffset = inner[offset];\r\n  const percent =\r\n    (e[client] -\r\n      e.currentTarget.getBoundingClientRect()[posName] -\r\n      barOffset / 2) /\r\n    e.currentTarget[offset];\r\n\r\n  parent.scrollTo({\r\n    [axis.toLowerCase()]: percent * 100 + '%'\r\n  });\r\n}\r\n\r\nexport default {\r\n  name: 'bar',\r\n  props: {\r\n    ops: {\r\n      type: Object,\r\n      required: true\r\n    },\r\n    state: {\r\n      type: Object,\r\n      required: true\r\n    },\r\n    type: {\r\n      type: String,\r\n      required: true\r\n    }\r\n  },\r\n  computed: {\r\n    bar() {\r\n      return scrollMap[this.type];\r\n    }\r\n  },\r\n  render(h) {\r\n    const vm = this;\r\n    const railBackgroundColor = getRgbAColor(\r\n      vm.ops.rail.background,\r\n      vm.ops.rail.opacity\r\n    );\r\n    let style = {\r\n      [vm.bar.size]: vm.state.size,\r\n      background: vm.ops.bar.background,\r\n      opacity: vm.state.opacity,\r\n      transform: `translate${scrollMap[vm.type].axis}(${vm.state.posValue}%)`\r\n    };\r\n    const bar = {\r\n      style: style,\r\n      class: `vuescroll-${vm.type}-bar`,\r\n      ref: 'inner',\r\n      on: {}\r\n    };\r\n\r\n    /* istanbul ignore if */\r\n    if (vm.ops.bar.hover) {\r\n      bar.on['mouseenter'] = () => {\r\n        vm.$el.style.background = vm.ops.hover;\r\n      };\r\n      bar.on['mouseleave'] = () => {\r\n        vm.$el.style.background = vm.ops.background;\r\n      };\r\n    }\r\n    /* istanbul ignore if */\r\n    if (isSupportTouch()) {\r\n      bar.on['touchstart'] = createTouchEvent(this);\r\n    } else {\r\n      bar.on['mousedown'] = createMouseEvent(this);\r\n    }\r\n\r\n    const rail = {\r\n      class: `vuescroll-${vm.type}-rail`,\r\n      style: {\r\n        borderRadius: vm.ops.rail[vm.bar.opsSize],\r\n        background: railBackgroundColor,\r\n        [vm.bar.opsSize]: vm.ops.rail[vm.bar.opsSize],\r\n        [vm.ops.rail.pos]: '2px'\r\n      },\r\n      on: {\r\n        click(e) /* istanbul ignore next */ {\r\n          handleClickTrack.call(vm, e);\r\n        }\r\n      }\r\n    };\r\n\r\n    return (\r\n      <div {...rail}>\r\n        <div {...bar} />\r\n      </div>\r\n    );\r\n  }\r\n};\r\n\r\n/**\r\n * create bars\r\n *\r\n * @param {any} size\r\n * @param {any} type\r\n */\r\nexport function createBar(h, vm, type) {\r\n  const axis = type === 'vertical' ? 'Y' : 'X';\r\n  const barType = `${type.charAt(0)}Bar`;\r\n  const railType = `${type.charAt(0)}Rail`;\r\n\r\n  if (\r\n    !vm.bar[barType].state.size ||\r\n    !vm.mergedOptions.scrollPanel['scrolling' + axis] ||\r\n    vm.mode == 'pure-native' ||\r\n    (vm.refreshLoad && type !== 'vertical' && vm.mode === 'slide')\r\n  ) {\r\n    return null;\r\n  }\r\n\r\n  const barData = {\r\n    props: {\r\n      type: type,\r\n      ops: {\r\n        bar: vm.mergedOptions.bar[barType],\r\n        rail: vm.mergedOptions.rail[railType]\r\n      },\r\n      state: vm.bar[barType].state\r\n    },\r\n    on: {\r\n      setBarClick: vm.setBarClick\r\n    },\r\n    ref: `${type}Bar`\r\n  };\r\n\r\n  return <bar {...barData} />;\r\n}\r\n","// begin importing\r\nimport {\r\n  getGutter,\r\n  isSupportGivenStyle,\r\n  isIE,\r\n  insertChildrenIntoSlot,\r\n  getRealParent\r\n} from '../../util';\r\nimport { createContent } from './vuescroll-content';\r\n// vueScrollPanel\r\nexport default {\r\n  name: 'scrollPanel',\r\n  props: { ops: { type: Object, required: true } },\r\n  methods: {\r\n    // trigger scrollPanel options initialScrollX,\r\n    // initialScrollY\r\n    updateInitialScroll() {\r\n      let x = 0;\r\n      let y = 0;\r\n      const parent = getRealParent(this);\r\n      if (this.ops.initialScrollX) {\r\n        x = this.ops.initialScrollX;\r\n      }\r\n      if (this.ops.initialScrollY) {\r\n        y = this.ops.initialScrollY;\r\n      }\r\n      if (x || y) {\r\n        parent.scrollTo({ x, y });\r\n      }\r\n    }\r\n  },\r\n  mounted() {\r\n    setTimeout(() => {\r\n      if (!this._isDestroyed) {\r\n        this.updateInitialScroll();\r\n      }\r\n    }, 0);\r\n  },\r\n  render(h) {\r\n    // eslint-disable-line\r\n    let data = {\r\n      class: ['vuescroll-panel']\r\n    };\r\n    const parent = getRealParent(this);\r\n    const customPanel = parent.$slots['scroll-panel'];\r\n    if (customPanel) {\r\n      return insertChildrenIntoSlot(h, customPanel, this.$slots.default, data);\r\n    }\r\n    return <div {...data}>{[this.$slots.default]}</div>;\r\n  }\r\n};\r\n\r\n/**\r\n * create a scrollPanel\r\n *\r\n * @param {any} size\r\n * @param {any} vm\r\n * @returns\r\n */\r\nexport function createPanel(h, vm) {\r\n  // scrollPanel data start\r\n  const scrollPanelData = {\r\n    ref: 'scrollPanel',\r\n    style: {},\r\n    class: [],\r\n    nativeOn: {\r\n      scroll: vm.handleScroll\r\n    },\r\n    props: {\r\n      ops: vm.mergedOptions.scrollPanel\r\n    }\r\n  };\r\n  // set overflow only if the in native mode\r\n  if (vm.mode == 'native') {\r\n    // dynamic set overflow scroll\r\n    // feat: #11\r\n    if (vm.mergedOptions.scrollPanel.scrollingY) {\r\n      scrollPanelData.style['overflowY'] = vm.bar.vBar.state.size\r\n        ? 'scroll'\r\n        : '';\r\n    } else {\r\n      scrollPanelData.style['overflowY'] = 'hidden';\r\n    }\r\n    if (vm.mergedOptions.scrollPanel.scrollingX) {\r\n      scrollPanelData.style['overflowX'] = vm.bar.hBar.state.size\r\n        ? 'scroll'\r\n        : '';\r\n    } else {\r\n      scrollPanelData.style['overflowX'] = 'hidden';\r\n    }\r\n    let gutter = getGutter();\r\n    /* istanbul ignore if */\r\n    if (!gutter && vm.mergedOptions.vuescroll.mode != 'pure-native') {\r\n      scrollPanelData.class.push('__hidebar');\r\n    } else {\r\n      // hide system bar by use a negative value px\r\n      // gutter should be 0 when manually disable scrollingX #14\r\n      if (vm.bar.vBar.state.size && vm.mergedOptions.scrollPanel.scrollingY) {\r\n        scrollPanelData.style.marginRight = `-${gutter}px`;\r\n      }\r\n      if (vm.bar.hBar.state.size && vm.mergedOptions.scrollPanel.scrollingX) {\r\n        scrollPanelData.style.height = `calc(100% + ${gutter}px)`;\r\n      }\r\n    }\r\n    // clear legency styles of slide mode...\r\n    scrollPanelData.style.transformOrigin = '';\r\n    scrollPanelData.style.transform = '';\r\n  } else if (vm.mode == 'slide') {\r\n    scrollPanelData.class.push('__slide');\r\n    let width = isSupportGivenStyle('width', 'fit-content');\r\n    if (width) {\r\n      scrollPanelData.style['width'] = width;\r\n    } /* istanbul ignore next */ else {\r\n      // fallback to inline block while\r\n      // doesn't support 'fit-content',\r\n      // this may cause some issues, but this\r\n      // can make `resize` event work...\r\n      scrollPanelData['display'] = 'inline-block';\r\n    }\r\n  } else if (vm.mode == 'pure-native') {\r\n    scrollPanelData.style['width'] = '100%';\r\n    if (vm.mergedOptions.scrollPanel.scrollingY) {\r\n      scrollPanelData.style['overflowY'] = 'auto';\r\n    } else {\r\n      scrollPanelData.style['overflowY'] = 'hidden';\r\n    }\r\n    if (vm.mergedOptions.scrollPanel.scrollingX) {\r\n      scrollPanelData.style['overflowX'] = 'auto';\r\n    } else {\r\n      scrollPanelData.style['overflowX'] = 'hidden';\r\n    }\r\n  }\r\n  return (\r\n    <scrollPanel {...scrollPanelData}>{createPanelChildren(vm, h)}</scrollPanel>\r\n  );\r\n}\r\n\r\nfunction createPanelChildren(vm, h) {\r\n  if (vm.mode == 'native') {\r\n    return [createContent(h, vm)];\r\n  } else if (vm.mode == 'slide') {\r\n    let renderChildren = [vm.$slots.default];\r\n    // handle for refresh\r\n    if (vm.mergedOptions.vuescroll.pullRefresh.enable) {\r\n      // use default refresh dom\r\n      let refreshDom = null;\r\n      refreshDom = createTipDom(h, vm, 'refresh');\r\n      renderChildren.unshift(\r\n        <div class=\"vuescroll-refresh\" ref=\"refreshDom\" key=\"refshDom\">\r\n          {[refreshDom, vm.pullRefreshTip]}\r\n        </div>\r\n      );\r\n    }\r\n    // handle for load\r\n    if (vm.mergedOptions.vuescroll.pushLoad.enable) {\r\n      let loadDom = null;\r\n      loadDom = createTipDom(h, vm, 'load');\r\n      // no slot load elm, use default\r\n      renderChildren.push(\r\n        <div class=\"vuescroll-load\" ref=\"loadDom\" key=\"loadDom\">\r\n          {[loadDom, vm.pushLoadTip]}\r\n        </div>\r\n      );\r\n    }\r\n    return renderChildren;\r\n  } else if (vm.mode == 'pure-native') {\r\n    return [vm.$slots.default];\r\n  }\r\n}\r\n// create load or refresh tip dom\r\nfunction createTipDom(h, vm, type) {\r\n  const stage = vm.vuescroll.state[`${type}Stage`];\r\n  let dom = null;\r\n  /* istanbul ignore if */\r\n  if ((dom = vm.$slots[`${type}-${stage}`])) {\r\n    return dom[0];\r\n  }\r\n  switch (stage) {\r\n  case 'deactive':\r\n    dom = (\r\n      <svg\r\n        version=\"1.1\"\r\n        xmlns=\"http://www.w3.org/2000/svg\"\r\n        xmlnsXlink=\"http://www.w3.org/1999/xlink\"\r\n        x=\"0px\"\r\n        y=\"0px\"\r\n        viewBox=\"0 0 1000 1000\"\r\n        enable-background=\"new 0 0 1000 1000\"\r\n        xmlSpace=\"preserve\"\r\n      >\r\n        <metadata> Svg Vector Icons : http://www.sfont.cn </metadata>\r\n        <g>\r\n          <g transform=\"matrix(1 0 0 -1 0 1008)\">\r\n            <path d=\"M10,543l490,455l490-455L885,438L570,735.5V18H430v717.5L115,438L10,543z\" />\r\n          </g>\r\n        </g>\r\n      </svg>\r\n    );\r\n    break;\r\n  case 'start':\r\n    // IE seems not supporting animateTransform\r\n    /* istanbul ignore if */\r\n    if (isIE()) {\r\n      dom = null;\r\n      break;\r\n    }\r\n    dom = (\r\n      <svg\r\n        version=\"1.1\"\r\n        id=\"loader-1\"\r\n        xmlns=\"http://www.w3.org/2000/svg\"\r\n        xmlnsXlink=\"http://www.w3.org/1999/xlink\"\r\n        x=\"0px\"\r\n        y=\"0px\"\r\n        viewBox=\"0 0 50 50\"\r\n        style=\"enable-background:new 0 0 50 50;\"\r\n        xmlSpace=\"preserve\"\r\n      >\r\n        <path\r\n          fill=\"#000\"\r\n          d=\"M43.935,25.145c0-10.318-8.364-18.683-18.683-18.683c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615c8.072,0,14.615,6.543,14.615,14.615H43.935z\"\r\n        >\r\n          <animateTransform\r\n            attributeType=\"xml\"\r\n            attributeName=\"transform\"\r\n            type=\"rotate\"\r\n            from=\"0 25 25\"\r\n            to=\"360 25 25\"\r\n            dur=\"0.6s\"\r\n            repeatCount=\"indefinite\"\r\n          />\r\n        </path>\r\n      </svg>\r\n    );\r\n    break;\r\n  case 'active':\r\n    dom = (\r\n      <svg\r\n        version=\"1.1\"\r\n        xmlns=\"http://www.w3.org/2000/svg\"\r\n        xmlnsXlink=\"http://www.w3.org/1999/xlink\"\r\n        x=\"0px\"\r\n        y=\"0px\"\r\n        viewBox=\"0 0 1000 1000\"\r\n        enable-background=\"new 0 0 1000 1000\"\r\n        xmlSpace=\"preserve\"\r\n      >\r\n        <metadata> Svg Vector Icons : http://www.sfont.cn </metadata>\r\n        <g>\r\n          <g transform=\"matrix(1 0 0 -1 0 1008)\">\r\n            <path d=\"M500,18L10,473l105,105l315-297.5V998h140V280.5L885,578l105-105L500,18z\" />\r\n          </g>\r\n        </g>\r\n      </svg>\r\n    );\r\n    break;\r\n  }\r\n  return dom;\r\n}\r\n","import {\r\n  deepMerge,\r\n  isSupportGivenStyle,\r\n  insertChildrenIntoSlot\r\n} from '../../util';\r\n// scrollContent\r\nexport default {\r\n  name: 'scrollContent',\r\n  functional: true,\r\n  props: {\r\n    ops: { type: Object },\r\n    state: {\r\n      type: Object,\r\n      default() {\r\n        return {};\r\n      }\r\n    }\r\n  },\r\n  render(h, { props, slots, parent }) {\r\n    let style = deepMerge(props.state.style, {});\r\n    style.position = 'relative';\r\n    let width = isSupportGivenStyle('width', 'fit-content');\r\n    if (width) {\r\n      style.width = width;\r\n    } /* istanbul ignore next */ else {\r\n      // fallback to inline block while\r\n      // doesn't support 'fit-content',\r\n      // this may cause some issues, but this\r\n      // can make `resize` event work...\r\n      style['display'] = 'inline-block';\r\n    }\r\n    style.boxSizing = 'border-box';\r\n    if (props.ops.padding) {\r\n      style[props.ops.paddPos] = props.ops.paddValue;\r\n    }\r\n\r\n    const propsData = {\r\n      style: style,\r\n      ref: 'scrollContent',\r\n      class: 'vuescroll-content'\r\n    };\r\n    const customContent = parent.$slots['scroll-content'];\r\n    if (customContent) {\r\n      return insertChildrenIntoSlot(\r\n        h,\r\n        customContent,\r\n        slots().default,\r\n        propsData\r\n      );\r\n    }\r\n    return <div {...propsData}>{slots().default}</div>;\r\n  }\r\n};\r\n\r\n/**\r\n * create scroll content\r\n *\r\n * @param {any} size\r\n * @param {any} vm\r\n * @returns\r\n */\r\nexport function createContent(h, vm) {\r\n  // scrollContent data\r\n  const scrollContentData = {\r\n    props: {\r\n      ops: vm.mergedOptions.scrollContent\r\n    }\r\n  };\r\n  return (\r\n    <scrollContent {...scrollContentData}>{[vm.$slots.default]}</scrollContent>\r\n  );\r\n}\r\n","import { listenResize } from '../third-party/resize-detector';\r\nimport hackLifecycle from '../mixins/hack-lifecycle';\r\nimport api from '../mixins/api';\r\nimport nativeMode from '../mixins/mode/native-mode';\r\nimport slideMode from '../mixins/mode/slide-mode';\r\n\r\nimport bar, { createBar } from './child-components/vuescroll-bar';\r\nimport scrollContent from './child-components/vuescroll-content';\r\nimport scrollPanel, { createPanel } from './child-components/vuescroll-panel';\r\n\r\nimport { smallChangeArray } from '../shared/constants';\r\nimport {\r\n  isChildInParent,\r\n  isSupportTouch,\r\n  insertChildrenIntoSlot\r\n} from '../util';\r\n\r\nfunction findValuesByMode(mode, vm) {\r\n  let axis = {};\r\n  switch (mode) {\r\n  case 'native':\r\n  case 'pure-native':\r\n    axis = {\r\n      x: vm.scrollPanelElm.scrollLeft,\r\n      y: vm.scrollPanelElm.scrollTop\r\n    };\r\n    break;\r\n  case 'slide':\r\n    axis = { x: vm.scroller.__scrollLeft, y: vm.scroller.__scrollTop };\r\n    break;\r\n  }\r\n  return axis;\r\n}\r\n\r\nconst vueScrollCore = {\r\n  name: 'vueScroll',\r\n  components: { bar, scrollContent, scrollPanel },\r\n  props: {\r\n    ops: { type: Object }\r\n  },\r\n  mixins: [hackLifecycle, api, nativeMode, slideMode],\r\n  mounted() {\r\n    if (!this.renderError) {\r\n      this.initVariables();\r\n\r\n      this.initWatchOpsChange();\r\n\r\n      this.refreshInternalStatus();\r\n\r\n      this.$nextTick(() => {\r\n        if (!this._isDestroyed) {\r\n          // update again to make sure bar's size is correct.\r\n          this.updateBarStateAndEmitEvent();\r\n          this.scrollToAnchor();\r\n        }\r\n      }, 0);\r\n    }\r\n  },\r\n  beforeDestroy() {\r\n    // remove registryed resize\r\n    if (this.destroyParentDomResize) {\r\n      this.destroyParentDomResize();\r\n      this.destroyParentDomResize = null;\r\n    }\r\n    if (this.destroyResize) {\r\n      this.destroyResize();\r\n      this.destroyResize = null;\r\n    }\r\n  },\r\n  data() {\r\n    return {\r\n      /**\r\n       * @description\r\n       * In state props of each components, we store the states of each\r\n       * components, and in mergedOptions props, we store the options\r\n       * that are megred from user-defined options to default options.\r\n       * @author wangyi7099\r\n       * @returns\r\n       */\r\n      vuescroll: {\r\n        state: {\r\n          isDragging: false,\r\n          isClickingBar: false,\r\n          pointerLeave: true,\r\n          internalScrollTop: 0,\r\n          internalScrollLeft: 0,\r\n          posX: null,\r\n          posY: null,\r\n          refreshStage: 'deactive',\r\n          loadStage: 'deactive',\r\n          height: '100%',\r\n          width: '100%'\r\n        }\r\n      },\r\n      bar: {\r\n        vBar: {\r\n          state: {\r\n            posValue: 0,\r\n            size: 0,\r\n            opacity: 0\r\n          }\r\n        },\r\n        hBar: {\r\n          state: {\r\n            posValue: 0,\r\n            size: 0,\r\n            opacity: 0\r\n          }\r\n        },\r\n        renderError: false\r\n      }\r\n    };\r\n  },\r\n  render(h) {\r\n    let vm = this;\r\n    if (vm.renderError) {\r\n      return <div>{[vm.$slots['default']]}</div>;\r\n    }\r\n    // vuescroll data\r\n    const vuescrollData = {\r\n      style: {\r\n        height: vm.vuescroll.state.height,\r\n        width: vm.vuescroll.state.width,\r\n        padding: 0\r\n      },\r\n      class: 'vuescroll'\r\n    };\r\n    if (!isSupportTouch()) {\r\n      vuescrollData.on = {\r\n        mouseenter() {\r\n          vm.vuescroll.state.pointerLeave = false;\r\n          vm.updateBarStateAndEmitEvent();\r\n        },\r\n        mouseleave() {\r\n          vm.vuescroll.state.pointerLeave = true;\r\n          vm.hideBar();\r\n        },\r\n        mousemove() /* istanbul ignore next */ {\r\n          vm.vuescroll.state.pointerLeave = false;\r\n          vm.updateBarStateAndEmitEvent();\r\n        }\r\n      };\r\n    } /* istanbul ignore next */ else {\r\n      vuescrollData.on = {\r\n        touchstart() {\r\n          vm.vuescroll.state.pointerLeave = false;\r\n          vm.updateBarStateAndEmitEvent();\r\n        },\r\n        touchend() {\r\n          vm.vuescroll.state.pointerLeave = true;\r\n          vm.hideBar();\r\n        },\r\n        touchmove() /* istanbul ignore next */ {\r\n          vm.vuescroll.state.pointerLeave = false;\r\n          vm.updateBarStateAndEmitEvent();\r\n        }\r\n      };\r\n    }\r\n    const customContainer = this.$slots['scroll-container'];\r\n    const ch = [\r\n      createPanel(h, vm),\r\n      createBar(h, vm, 'vertical'),\r\n      createBar(h, vm, 'horizontal')\r\n    ];\r\n\r\n    if (customContainer) {\r\n      return insertChildrenIntoSlot(h, customContainer, ch, vuescrollData);\r\n    }\r\n    return <div {...vuescrollData}>{ch}</div>;\r\n  },\r\n  computed: {\r\n    scrollPanelElm() {\r\n      return this.$refs['scrollPanel']._isVue\r\n        ? this.$refs['scrollPanel'].$el\r\n        : this.$refs['scrollPanel'];\r\n    },\r\n    scrollContentElm() {\r\n      return this.$refs['scrollContent']._isVue\r\n        ? this.$refs['scrollContent'].$el\r\n        : this.$refs['scrollContent'];\r\n    },\r\n    mode() {\r\n      return this.mergedOptions.vuescroll.mode;\r\n    },\r\n    pullRefreshTip() {\r\n      return this.mergedOptions.vuescroll.pullRefresh.tips[\r\n        this.vuescroll.state.refreshStage\r\n      ];\r\n    },\r\n    pushLoadTip() {\r\n      return this.mergedOptions.vuescroll.pushLoad.tips[\r\n        this.vuescroll.state.loadStage\r\n      ];\r\n    },\r\n    refreshLoad() {\r\n      return (\r\n        this.mergedOptions.vuescroll.pullRefresh.enable ||\r\n        this.mergedOptions.vuescroll.pushLoad.enable\r\n      );\r\n    }\r\n  },\r\n  methods: {\r\n    updateBarStateAndEmitEvent(eventType, nativeEvent = null) {\r\n      if (this.mode == 'native' || this.mode == 'pure-native') {\r\n        this.updateNativeModeBarState();\r\n      } else if (this.mode == 'slide') {\r\n        if (!this.scroller) {\r\n          return;\r\n        }\r\n        this.updateSlideModeBarState();\r\n      }\r\n      if (eventType) {\r\n        this.emitEvent(eventType, nativeEvent);\r\n      }\r\n      this.showAndDefferedHideBar();\r\n    },\r\n    updateMode() {\r\n      const x = this.vuescroll.state.internalScrollLeft;\r\n      const y = this.vuescroll.state.internalScrollTop;\r\n      if (this.destroyScroller) {\r\n        this.scroller.stop();\r\n        this.destroyScroller();\r\n        this.destroyScroller = null;\r\n      }\r\n      if (this.mode == 'slide') {\r\n        this.destroyScroller = this.registryScroller();\r\n      } else if (this.mode == 'native' || this.mode == 'pure-native') {\r\n        // remove the legacy transform style attribute\r\n        this.scrollPanelElm.style.transform = '';\r\n        this.scrollPanelElm.style.transformOrigin = '';\r\n      }\r\n      // keep the last-mode's position.\r\n      this.scrollTo({ x, y }, false, true /* force */);\r\n    },\r\n    handleScroll(nativeEvent) {\r\n      this.recordCurrentPos();\r\n      this.updateBarStateAndEmitEvent('handle-scroll', nativeEvent);\r\n    },\r\n    setBarClick(val) {\r\n      /* istanbul ignore next */\r\n      this.vuescroll.state.isClickingBar = val;\r\n    },\r\n    showAndDefferedHideBar() {\r\n      this.showBar();\r\n      if (this.timeoutId) {\r\n        clearTimeout(this.timeoutId);\r\n        this.timeoutId = 0;\r\n      }\r\n      this.timeoutId = setTimeout(() => {\r\n        this.timeoutId = 0;\r\n        this.hideBar();\r\n      }, this.mergedOptions.bar.showDelay);\r\n    },\r\n    /**\r\n     *  emit user registry event\r\n     */\r\n    emitEvent(eventType, nativeEvent = null) {\r\n      let {\r\n        scrollHeight,\r\n        scrollWidth,\r\n        clientHeight,\r\n        clientWidth,\r\n        scrollTop,\r\n        scrollLeft\r\n      } = this.scrollPanelElm;\r\n      const vertical = {\r\n        type: 'vertical'\r\n      };\r\n      const horizontal = {\r\n        type: 'horizontal'\r\n      };\r\n      if (this.mode == 'slide') {\r\n        scrollHeight = this.scroller.__contentHeight;\r\n        scrollWidth = this.scroller.__contentWidth;\r\n        scrollTop = this.scroller.__scrollTop;\r\n        scrollLeft = this.scroller.__scrollLeft;\r\n        clientHeight = this.$el.clientHeight;\r\n        clientWidth = this.$el.clientWidth;\r\n      }\r\n      vertical['process'] = Math.min(\r\n        scrollTop / (scrollHeight - clientHeight),\r\n        1\r\n      );\r\n      horizontal['process'] = Math.min(\r\n        scrollLeft / (scrollWidth - clientWidth),\r\n        1\r\n      );\r\n      vertical['barSize'] = this.bar.vBar.state.size;\r\n      horizontal['barSize'] = this.bar.hBar.state.size;\r\n      vertical['scrollTop'] = scrollTop;\r\n      horizontal['scrollLeft'] = scrollLeft;\r\n      vertical['directionY'] = this.vuescroll.state.posY;\r\n      horizontal['directionX'] = this.vuescroll.state.posX;\r\n      this.$emit(eventType, vertical, horizontal, nativeEvent);\r\n    },\r\n    showBar() {\r\n      this.bar.vBar.state.opacity = this.mergedOptions.bar.vBar.opacity;\r\n      this.bar.hBar.state.opacity = this.mergedOptions.bar.hBar.opacity;\r\n    },\r\n    hideBar() {\r\n      // when in non-native mode dragging content\r\n      // in slide mode, just return\r\n      /* istanbul ignore next */\r\n      if (this.vuescroll.state.isDragging) {\r\n        return;\r\n      }\r\n      // add isClickingBar condition\r\n      // to prevent from hiding bar while dragging the bar\r\n      if (\r\n        !this.mergedOptions.bar.vBar.keepShow &&\r\n        !this.vuescroll.state.isClickingBar &&\r\n        this.vuescroll.state.pointerLeave\r\n      ) {\r\n        this.bar.vBar.state.opacity = 0;\r\n      }\r\n      if (\r\n        !this.mergedOptions.bar.hBar.keepShow &&\r\n        !this.vuescroll.state.isClickingBar &&\r\n        this.vuescroll.state.pointerLeave\r\n      ) {\r\n        this.bar.hBar.state.opacity = 0;\r\n      }\r\n    },\r\n    registryResize() {\r\n      /* istanbul ignore next */\r\n      if (this.destroyResize) {\r\n        // when toggling the mode\r\n        // we should clean the flag-object.\r\n        this.destroyResize();\r\n      }\r\n      let contentElm = null;\r\n      if (this.mode == 'slide' || this.mode == 'pure-native') {\r\n        contentElm = this.scrollPanelElm;\r\n      } else if (this.mode == 'native') {\r\n        // scrollContent maybe a component or a pure-dom\r\n        contentElm = this.scrollContentElm;\r\n      }\r\n      const handleWindowResize = () => /* istanbul ignore next */ {\r\n        this.updateBarStateAndEmitEvent();\r\n        if (this.mode == 'slide') {\r\n          this.updateScroller();\r\n        }\r\n      };\r\n      const handleDomResize = () => {\r\n        let currentSize = {};\r\n        if (this.mode == 'slide') {\r\n          this.updateScroller();\r\n          currentSize['width'] = this.scroller.__contentWidth;\r\n          currentSize['height'] = this.scroller.__contentHeight;\r\n        } else if (this.mode == 'native' || this.mode == 'pure-native') {\r\n          currentSize['width'] = this.scrollPanelElm.scrollWidth;\r\n          currentSize['height'] = this.scrollPanelElm.scrollHeight;\r\n        }\r\n        this.updateBarStateAndEmitEvent('handle-resize', currentSize);\r\n      };\r\n      window.addEventListener('resize', handleWindowResize, false);\r\n      const destroyDomResize = listenResize(contentElm, handleDomResize);\r\n      const destroyWindowResize = () => {\r\n        window.removeEventListener('resize', handleWindowResize, false);\r\n      };\r\n\r\n      this.destroyResize = () => {\r\n        destroyWindowResize();\r\n        destroyDomResize();\r\n      };\r\n    },\r\n    registryParentResize() {\r\n      this.destroyParentDomResize = listenResize(\r\n        this.$el.parentNode,\r\n        this.useNumbericSize\r\n      );\r\n    },\r\n    useNumbericSize() {\r\n      const parentElm = this.$el.parentNode;\r\n      const { position } = parentElm.style;\r\n      if (!position || position == 'static') {\r\n        this.$el.parentNode.style.position = 'relative';\r\n      }\r\n      this.vuescroll.state.height = parentElm.offsetHeight + 'px';\r\n      this.vuescroll.state.width = parentElm.offsetWidth + 'px';\r\n    },\r\n    usePercentSize() {\r\n      this.vuescroll.state.height = '100%';\r\n      this.vuescroll.state.width = '100%';\r\n    },\r\n    // set its size to be equal to its parentNode\r\n    setVsSize() {\r\n      if (this.mergedOptions.vuescroll.sizeStrategy == 'number') {\r\n        this.useNumbericSize();\r\n        this.registryParentResize();\r\n      } else if (this.mergedOptions.vuescroll.sizeStrategy == 'percent') {\r\n        if (this.destroyParentDomResize) {\r\n          this.destroyParentDomResize();\r\n          this.destroyParentDomResize = null;\r\n        }\r\n        this.usePercentSize();\r\n      }\r\n    },\r\n    recordCurrentPos() {\r\n      let mode = this.mode;\r\n      if (this.mode !== this.lastMode) {\r\n        mode = this.lastMode;\r\n        this.lastMode = this.mode;\r\n      }\r\n      const state = this.vuescroll.state;\r\n      let axis = findValuesByMode(mode, this);\r\n      const oldX = state.internalScrollLeft;\r\n      const oldY = state.internalScrollTop;\r\n      state.posX =\r\n        oldX - axis.x > 0 ? 'right' : oldX - axis.x < 0 ? 'left' : null;\r\n      state.posY = oldY - axis.y > 0 ? 'up' : oldY - axis.y < 0 ? 'down' : null;\r\n      state.internalScrollLeft = axis.x;\r\n      state.internalScrollTop = axis.y;\r\n    },\r\n    refreshInternalStatus() {\r\n      // 1.set vuescroll height or width according to\r\n      // sizeStrategy\r\n      this.setVsSize();\r\n      // 2. registry resize event\r\n      this.registryResize();\r\n      // 3. registry scroller if mode is 'slide'\r\n      // or remove 'transform origin' is the mode is not `slide`\r\n      this.updateMode();\r\n      // 4. update scrollbar's height/width\r\n      this.updateBarStateAndEmitEvent();\r\n    },\r\n    initWatchOpsChange() {\r\n      const watchOpts = {\r\n        deep: true,\r\n        sync: true\r\n      };\r\n      this.$watch(\r\n        'mergedOptions',\r\n        () => {\r\n          // record current position\r\n          this.recordCurrentPos();\r\n          setTimeout(() => {\r\n            if (this.isSmallChangeThisTick == true) {\r\n              this.isSmallChangeThisTick = false;\r\n              this.updateBarStateAndEmitEvent();\r\n              return;\r\n            }\r\n            this.refreshInternalStatus();\r\n          }, 0);\r\n        },\r\n        watchOpts\r\n      );\r\n\r\n      smallChangeArray.forEach(opts => {\r\n        this.$watch(\r\n          opts,\r\n          () => {\r\n            // when small changes changed,\r\n            // we need not to updateMode or registryResize\r\n            this.isSmallChangeThisTick = true;\r\n          },\r\n          watchOpts\r\n        );\r\n      });\r\n    },\r\n    // scrollTo hash-anchor while mounted\r\n    scrollToAnchor() /* istanbul ignore next */ {\r\n      const validateHashSelector = function(hash) {\r\n        return /^#[a-zA-Z_]\\d*$/.test(hash);\r\n      };\r\n      let hash = window.location.hash;\r\n      if (\r\n        !hash ||\r\n        ((hash = hash.slice(hash.lastIndexOf('#'))) &&\r\n          !validateHashSelector(hash))\r\n      ) {\r\n        return;\r\n      }\r\n      const elm = document.querySelector(hash);\r\n      if (\r\n        !isChildInParent(elm, this.$el) ||\r\n        this.mergedOptions.scrollPanel.initialScrollY ||\r\n        this.mergedOptions.scrollPanel.initialScrollX\r\n      ) {\r\n        return;\r\n      }\r\n      this.scrollIntoView(elm);\r\n    },\r\n    initVariables() {\r\n      this.lastMode = this.mode;\r\n      this.$el._isVuescroll = true;\r\n    }\r\n  }\r\n};\r\n\r\nexport default vueScrollCore;\r\n","import {getPrefix} from '../../util';\r\n\r\n/* DOM-based rendering (Uses 3D when available, falls back on margin when transform not available) */\r\nexport function render(content, global, suffix, value) {\r\n  var x = null;\r\n  var y = null;\r\n\r\n  if (typeof content == 'string') {\r\n    y = content == 'vertical' ? (x = 0) || value : (x = value) && 0;\r\n  }\r\n\r\n  var vendorPrefix = getPrefix(global);\r\n\r\n  var helperElem = document.createElement('div');\r\n  var undef;\r\n\r\n  var perspectiveProperty = vendorPrefix + 'Perspective';\r\n  var transformProperty = 'transform'; //vendorPrefix + 'Transform';\r\n\r\n  if (helperElem.style[perspectiveProperty] !== undef) {\r\n    if (typeof content == 'string') {\r\n      return {\r\n        [transformProperty]:\r\n          'translate3d(' + x + suffix + ',' + y + suffix + ',0)'\r\n      };\r\n    }\r\n    return function(left, top, zoom) {\r\n      content.style[transformProperty] =\r\n        'translate3d(' +\r\n        -left +\r\n        suffix +\r\n        ',' +\r\n        -top +\r\n        suffix +\r\n        ',0) scale(' +\r\n        zoom +\r\n        ')';\r\n    };\r\n  } else if (helperElem.style[transformProperty] !== undef) {\r\n    if (typeof content == 'string') {\r\n      return {\r\n        [transformProperty]: 'translate(' + x + suffix + ',' + y + suffix + ')'\r\n      };\r\n    }\r\n    return function(left, top, zoom) {\r\n      content.style[transformProperty] =\r\n        'translate(' +\r\n        -left +\r\n        suffix +\r\n        ',' +\r\n        -top +\r\n        suffix +\r\n        ') scale(' +\r\n        zoom +\r\n        ')';\r\n    };\r\n  }\r\n}\r\n","export function listenContainer(\r\n  container,\r\n  scroller,\r\n  eventCallback,\r\n  zooming,\r\n  preventDefault\r\n) {\r\n  let destroy = null;\r\n  // for touch\r\n  function touchstart(e) {\r\n    // Don't react if initial down happens on a form element\r\n    if (\r\n      e.touches[0] &&\r\n      e.touches[0].target &&\r\n      e.touches[0].target.tagName.match(/input|textarea|select/i)\r\n    ) {\r\n      return;\r\n    }\r\n    eventCallback('mousedown');\r\n    scroller.doTouchStart(e.touches, e.timeStamp);\r\n    if (preventDefault) {\r\n      e.preventDefault();\r\n    }\r\n    // here , we want to manully prevent default, so we\r\n    // set passive to false\r\n    // see https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener\r\n    document.addEventListener('touchmove', touchmove, { passive: false });\r\n  }\r\n  function touchmove(e) {\r\n    eventCallback('mousemove');\r\n    scroller.doTouchMove(e.touches, e.timeStamp, e.scale);\r\n    e.preventDefault();\r\n  }\r\n  function touchend(e) {\r\n    eventCallback('mouseup');\r\n    scroller.doTouchEnd(e.timeStamp);\r\n    document.removeEventListener('touchmove', touchmove);\r\n  }\r\n  function touchcancel(e) {\r\n    scroller.doTouchEnd(e.timeStamp);\r\n  }\r\n\r\n  // for mouse\r\n  function mousedownEvent(e) {\r\n    if (e.target.tagName.match(/input|textarea|select/i)) {\r\n      return;\r\n    }\r\n    eventCallback('mousedown');\r\n    scroller.doTouchStart(\r\n      [\r\n        {\r\n          pageX: e.pageX,\r\n          pageY: e.pageY\r\n        }\r\n      ],\r\n      e.timeStamp\r\n    );\r\n\r\n    if (preventDefault) {\r\n      e.preventDefault();\r\n    }\r\n\r\n    mousedown = true;\r\n  }\r\n  function mousemove(e) {\r\n    if (!mousedown) {\r\n      return;\r\n    }\r\n    eventCallback('mousemove');\r\n    scroller.doTouchMove(\r\n      [\r\n        {\r\n          pageX: e.pageX,\r\n          pageY: e.pageY\r\n        }\r\n      ],\r\n      e.timeStamp\r\n    );\r\n\r\n    mousedown = true;\r\n  }\r\n  function mouseup(e) {\r\n    if (!mousedown) {\r\n      return;\r\n    }\r\n    eventCallback('mouseup');\r\n    scroller.doTouchEnd(e.timeStamp);\r\n\r\n    mousedown = false;\r\n  }\r\n  function zoomHandle(e) {\r\n    scroller.doMouseZoom(\r\n      e.detail ? e.detail * -120 : e.wheelDelta,\r\n      e.timeStamp,\r\n      e.pageX,\r\n      e.pageY\r\n    );\r\n  }\r\n  if ('ontouchstart' in window) {\r\n    container.addEventListener('touchstart', touchstart, false);\r\n\r\n    document.addEventListener('touchend', touchend, false);\r\n\r\n    document.addEventListener('touchcancel', touchcancel, false);\r\n\r\n    destroy = function() {\r\n      container.removeEventListener('touchstart', touchstart, false);\r\n\r\n      document.removeEventListener('touchend', touchend, false);\r\n\r\n      document.removeEventListener('touchcancel', touchcancel, false);\r\n    };\r\n  } else {\r\n    var mousedown = false;\r\n\r\n    container.addEventListener('mousedown', mousedownEvent, false);\r\n\r\n    document.addEventListener('mousemove', mousemove, false);\r\n\r\n    document.addEventListener('mouseup', mouseup, false);\r\n    if (zooming) {\r\n      container.addEventListener(\r\n        navigator.userAgent.indexOf('Firefox') > -1\r\n          ? 'DOMMouseScroll'\r\n          : 'mousewheel',\r\n        zoomHandle,\r\n        false\r\n      );\r\n    }\r\n    // container.addEventListener(navigator.userAgent.indexOf(\"Firefox\") > -1 ? \"DOMMouseScroll\" :  \"mousewheel\", function(e) {\r\n    //     scroller.doMouseZoom(e.detail ? (e.detail * -120) : e.wheelDelta, e.timeStamp, e.pageX, e.pageY);\r\n    // }, false);\r\n    destroy = function() {\r\n      container.removeEventListener('mousedown', mousedownEvent, false);\r\n      document.removeEventListener('mousemove', mousemove, false);\r\n      document.removeEventListener('mouseup', mouseup, false);\r\n      container.removeEventListener(\r\n        navigator.userAgent.indexOf('Firefox') > -1\r\n          ? 'DOMMouseScroll'\r\n          : 'mousewheel',\r\n        zoomHandle,\r\n        false\r\n      );\r\n    };\r\n  }\r\n  // handle __publish event\r\n  scroller.onScroll = () => {\r\n    eventCallback('onscroll');\r\n  };\r\n  return destroy;\r\n}\r\n","import Vue from 'vue';\r\nimport vuescroll from './components/vuescroll';\r\nimport GCF from './shared/global-config';\r\nimport { deepMerge } from './util';\r\nimport { refreshAll } from './mixins/api';\r\n\r\nimport './style/vuescroll.scss';\r\n\r\nconst Vuescroll = {\r\n  install(Vue) {\r\n    // registry vuescroll\r\n    Vue.component(vuescroll.name, vuescroll);\r\n    Vue.prototype.$vuescrollConfig = deepMerge(GCF, {});\r\n  },\r\n  version: '__version__',\r\n  refreshAll\r\n};\r\n\r\n/* istanbul ignore if */\r\nif (typeof window !== 'undefined' && window.Vue) {\r\n  Vue.use(Vuescroll);\r\n}\r\n\r\nexport default Vuescroll;\r\n"],"names":["deepCopy","source","target","key","_typeof","deepMerge","from","to","defineReactive","souceKey","getter","defineProperty","scrollBarWidth","eventCenter","dom","eventName","hander","capture","addEventListener","removeEventListener","error","msg","warn","isChildInParent","child","parent","flag","parentNode","nodeType","_isVuescroll","pxValueReg","extractNumberFromPx","value","_return","exec","isSupportTouch","window","getPrefix","global","engine","docStyle","document","documentElement","style","opera","Object","prototype","toString","call","navigator","cpuClass","isSupportGivenStyle","property","compatibleValue","testElm","createElement","isIE","agent","userAgent","toLowerCase","indexOf","insertChildrenIntoSlot","h","parentVnode","childVNode","data","tag","componentOptions","_data","nativeOn","on","props","propsData","getRealParent","ctx","$parent","_isVuescrollRoot","listenResize","element","callback","hasResized","OBJECT_STYLE","objWrap","cssText","object","type","tabIndex","onload","contentDocument","defaultView","isResizeElm","appendChild","removeChild","injectObject","modes","NOOP","smallChangeArray","undefined","vm","this","$options","name","_gfc","$vuescrollConfig","ops","GCF","keys","forEach","mergedOptions","scrollContent","rail","vRail","pos","width","renderError","shouldStopRender","vuescroll","scrollPanel","mode","paging","snapping","enable","pullRefresh","pushLoad","initialScrollY","initialScrollX","String","match","validateOptions","createEasingFunction","easing","easingPattern","time","pattern","Date","now","running","counter","core","effect","Animate","requestFrame","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","isNative","test","root","requests","rafHandle","intervalHandle","lastActive","callbackHandle","setInterval","currentRequests","hasOwnProperty","id","cleared","stepCallback","verifyCallback","completedCallback","duration","easingMethod","start","lastFrame","percent","dropCounter","body","newRunning","usedId","step","virtual","render","droppedFrames","Math","round","j","min","vsInstances","getNumericValue","distance","size","number","_uid","x","y","animate","force","state","internalScrollLeft","scrollPanelElm","scrollWidth","internalScrollTop","scrollHeight","internalScrollTo","dx","dy","factor","originLeft","originTop","scroller","zoomBy","level","zoomTo","getCurrentPage","dest","goToPage","isRefresh","isLoad","triggerRefreshOrLoad","left","top","height","parentLeft","parentTop","parentHeight","parentWidth","children","scrollContentElm","domFragment","i","length","item","getBoundingClientRect","_this","$el","push","destX","destY","elm","deltaX","deltaY","speed","scrollingComplete","startLocationY","startLocationX","positionX","positionY","percentage","floor","abs","$refs","scrollLeft","scrollTop","updateBarStateAndEmitEvent","scrollTo","parentElm","querySelector","diffX","diffY","scrollBy","refreshInternalStatus","isPercent","sizeStrategy","clientWidth","clientHeight","heightPercentage","widthPercentage","bar","vBar","posValue","hBar","animatingMethod","noAnimatingMethod","Scroller","options","__callback","animatingEasing","noAnimatingEasing","members","contentWidth","contentHeight","trye","self","__clientWidth","__clientHeight","__contentWidth","__contentHeight","__computeScrollMax","__scrollLeft","__scrollTop","__clientLeft","__clientTop","__snapWidth","__snapHeight","activateCallback","deactivateCallback","startCallback","beforeDeactivateCallback","__refreshHeight","__refreshActivate","__refreshBeforeDeactivate","__refreshDeactivate","__refreshStart","__loadHeight","__loadActivate","__loadBeforeDeactivate","__loadDeactivate","__loadStart","wasDecelerating","__isDecelerating","stop","__publish","__zoomLevel","__refreshActive","__maxScrollTop","__loadActive","__maxScrollLeft","zooming","Error","__zoomComplete","oldLevel","max","maxZoom","minZoom","zoom","scrollingX","scrollingY","__isTracking","startLeft","__isAnimating","__scheduledLeft","startTop","__scheduledTop","__computePage","__currentPageX","__currentPageY","isNaN","wheelDelta","timeStamp","pageX","pageY","change","touches","valueOf","currentTouchLeft","currentTouchTop","__interruptedAnimation","isSingleTouch","__initialTouchLeft","__initialTouchTop","__zoomLevelStart","__lastTouchLeft","__lastTouchTop","__lastTouchMove","__lastScale","__enableScrollX","__enableScrollY","__didDecelerationComplete","__isDragging","__isSingleTouch","__positions","scale","positions","moveX","moveY","currentTouchLeftRel","currentTouchTopRel","speedMultiplier","maxScrollLeft","bouncing","maxScrollTop","splice","minimumTrackingForScroll","locking","distanceX","distanceY","animating","endPos","startPos","timeOffset","movedLeft","movedTop","__decelerationVelocityX","__decelerationVelocityY","minVelocityToStartDeceleration","__startDeceleration","__scrollComplete","__disable","wasAnimating","__scheduledZoom","oldLeft","oldTop","oldZoom","diffLeft","diffTop","diffZoom","onScroll","renderedFramesPerSecond","animationId","wasFinished","animationDuration","zoomLevel","__totalXPage","ceil","__totalYPage","__minDecelerationScrollLeft","__minDecelerationScrollTop","__maxDecelerationScrollLeft","__maxDecelerationScrollTop","minVelocityToKeepDecelerating","__stepThroughDeceleration","shouldContinue","scrollLeftFixed","scrollTopFixed","scrollOutsideX","scrollOutsideY","penetrationDeceleration","penetrationAcceleration","colorCache","rgbReg","extractRgbColor","createBar","axis","barType","charAt","railType","refreshLoad","setBarClick","createPanel","scrollPanelData","handleScroll","gutter","Vue","$isServer","outer","visibility","position","widthNoScroll","offsetWidth","overflow","inner","widthWithScroll","getGutter","marginRight","class","transformOrigin","transform","$slots","default","renderChildren","refreshDom","createTipDom","unshift","ref","pullRefreshTip","loadDom","pushLoadTip","createPanelChildren","stage","d","vueScrollCore","scrollMap","railBackgroundColor","color","opacity","div","background","computedColor","getComputedStyle","backgroundColor","getRgbAColor","hover","touchmove","e","axisStartPos","client","posName","offset","scrollSize","touchend","$emit","onselectstart","hideBar","stopImmediatePropagation","preventDefault","createTouchEvent","mousemove","mouseup","createMouseEvent","opsSize","barOffset","currentTarget","slots","boxSizing","padding","paddPos","paddValue","customContent","required","_isDestroyed","updateInitialScroll","customPanel","hackLifecycle","api","nativeMode","refreshHeight","offsetHeight","marginTop","setDimensions","content","suffix","vendorPrefix","helperElem","perspectiveProperty","transformProperty","undef","setSnapSize","rect","setPosition","clientLeft","clientTop","cb","container","eventCallback","destroy","touchstart","tagName","doTouchStart","passive","doTouchMove","doTouchEnd","touchcancel","mousedownEvent","mousedown","zoomHandle","doMouseZoom","detail","listenContainer","eventType","isDragging","registryEvent","updateScroller","outerLeft","outerTop","stageName","tipDom","listeners","domName","activateFunc","activatePullToRefresh","activatePushToLoad","cbs","$listeners","finishRefreshOrLoad","done","bind","initVariables","initWatchOpsChange","$nextTick","scrollToAnchor","destroyParentDomResize","destroyResize","vuescrollData","pointerLeave","customContainer","ch","_isVue","tips","refreshStage","loadStage","nativeEvent","updateNativeModeBarState","updateSlideModeBarState","emitEvent","showAndDefferedHideBar","destroyScroller","registryScroller","recordCurrentPos","val","isClickingBar","showBar","timeoutId","setTimeout","showDelay","vertical","horizontal","posY","posX","keepShow","contentElm","handleWindowResize","_this3","destroyDomResize","currentSize","useNumbericSize","registryParentResize","usePercentSize","lastMode","findValuesByMode","oldX","oldY","setVsSize","registryResize","updateMode","watchOpts","$watch","_this4","isSmallChangeThisTick","opts","hash","location","slice","lastIndexOf","scrollIntoView","Vuescroll","component","vs","refresh","use"],"mappings":"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"}