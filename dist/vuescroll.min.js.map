{"version":3,"file":"vuescroll.min.js","sources":["../src/util/index.js","../src/core/mixins/native-mode.js","../src/third-party/easingPattern/index.js","../src/third-party/scroller/animate.js","../src/third-party/scroller/requestAnimationFrame.js","../src/shared/constants.js","../src/third-party/scroller/index.js","../src/core/mixins/slide-mode.js","../src/shared/global-config.js","../src/core/mixins/hack-lifecycle.js","../src/core/mixins/api.js","../src/shared/scroll-map.js","../src/core/children/vuescroll-bar.js","../src/core/children/vuescroll-panel.js","../src/third-party/resize-detector/index.js","../src/core/vuescroll.js","../src/core/children/vuescroll-content.js","../src/third-party/scroller/render.js","../src/third-party/scroller/listener.js","../src/index.js"],"sourcesContent":["import Vue from 'vue';\n\n/* istanbul ignore next */\nexport const isServer = () => Vue.prototype.$isServer;\n\nexport function deepCopy(source, target) {\n  target = (typeof target === 'object' && target) || {};\n  for (var key in source) {\n    target[key] =\n      typeof source[key] === 'object'\n        ? deepCopy(source[key], (target[key] = {}))\n        : source[key];\n  }\n  return target;\n}\n\nexport function deepMerge(from, to, force) {\n  to = to || {};\n  for (var key in from) {\n    if (typeof from[key] === 'object') {\n      if (typeof to[key] === 'undefined') {\n        to[key] = {};\n        deepCopy(from[key], to[key]);\n      } else {\n        deepMerge(from[key], to[key]);\n      }\n    } else {\n      if (typeof to[key] === 'undefined' || force) to[key] = from[key];\n    }\n  }\n  return to;\n}\n\nexport function defineReactive(target, key, source, souceKey) {\n  let getter = null;\n  /* istanbul ignore if */\n  if (!source[key] && typeof source !== 'function') {\n    return;\n  }\n  souceKey = souceKey || key;\n  if (typeof source === 'function') {\n    getter = source;\n  }\n  Object.defineProperty(target, key, {\n    get:\n      getter ||\n      function() {\n        return source[souceKey];\n      },\n    configurable: true\n  });\n}\n\nlet scrollBarWidth;\n\nexport function getGutter() {\n  /* istanbul ignore next */\n  if (isServer()) return 0;\n  if (scrollBarWidth !== undefined) return scrollBarWidth;\n  const outer = document.createElement('div');\n  outer.style.visibility = 'hidden';\n  outer.style.width = '100px';\n  outer.style.position = 'absolute';\n  outer.style.top = '-9999px';\n  document.body.appendChild(outer);\n\n  const widthNoScroll = outer.offsetWidth;\n  outer.style.overflow = 'scroll';\n  const inner = document.createElement('div');\n  inner.style.width = '100%';\n  outer.appendChild(inner);\n\n  const widthWithScroll = inner.offsetWidth;\n  outer.parentNode.removeChild(outer);\n  scrollBarWidth = widthNoScroll - widthWithScroll;\n  return scrollBarWidth;\n}\n\nexport function eventCenter(\n  dom,\n  eventName,\n  hander,\n  capture = false,\n  type = 'on'\n) {\n  type == 'on'\n    ? dom.addEventListener(eventName, hander, capture)\n    : dom.removeEventListener(eventName, hander, capture);\n}\n\nexport const error = msg => {\n  console.error(`[vuescroll] ${msg}`);\n};\nexport const warn = msg => {\n  console.warn(`[vuescroll] ${msg}`);\n};\n\nexport function isChildInParent(child, parent) {\n  let flag = false;\n  if (!child || !parent) {\n    return flag;\n  }\n  while (\n    child.parentNode !== parent &&\n    child.parentNode.nodeType !== 9 &&\n    !child.parentNode._isVuescroll\n  ) {\n    child = child.parentNode;\n  }\n  if (child.parentNode == parent) {\n    flag = true;\n  }\n  return flag;\n}\n\nconst pxValueReg = /(.*?)px/;\nexport function extractNumberFromPx(value) {\n  const _return = pxValueReg.exec(value);\n  return _return && _return[1];\n}\n\nfunction _isSupportTouch() {\n  return 'ontouchstart' in window;\n}\nexport function isSupportTouch() {\n  /* istanbul ignore if */\n  if (isServer()) return false;\n  return _isSupportTouch();\n}\n\nexport function getPrefix(global) {\n  var docStyle = document.documentElement.style;\n  var engine;\n  /* istanbul ignore if */\n  if (\n    global.opera &&\n    Object.prototype.toString.call(opera) === '[object Opera]'\n  ) {\n    engine = 'presto';\n  } /* istanbul ignore next */ else if ('MozAppearance' in docStyle) {\n    engine = 'gecko';\n  } else if ('WebkitAppearance' in docStyle) {\n    engine = 'webkit';\n  } /* istanbul ignore next */ else if (\n    typeof navigator.cpuClass === 'string'\n  ) {\n    engine = 'trident';\n  }\n  var vendorPrefix = {\n    trident: 'ms',\n    gecko: 'moz',\n    webkit: 'webkit',\n    presto: 'O'\n  }[engine];\n  return vendorPrefix;\n}\n\nexport function _isSupportGivenStyle(property, value) {\n  const compatibleValue = `-${getPrefix(window)}-${value}`;\n  const testElm = document.createElement('div');\n  testElm.style[property] = compatibleValue;\n  if (testElm.style[property] == compatibleValue) {\n    return compatibleValue;\n  }\n  /* istanbul ignore next */\n  return false;\n}\nexport function isSupportGivenStyle(property, value) {\n  /* istanbul ignore if */\n  if (isServer()) return false;\n  return _isSupportGivenStyle(property, value);\n}\n\nexport function _isIE() /* istanbul ignore next */ {\n  var agent = navigator.userAgent.toLowerCase();\n  return (\n    agent.indexOf('msie') !== -1 ||\n    agent.indexOf('trident') !== -1 ||\n    agent.indexOf(' edge/') !== -1\n  );\n}\nexport function isIE() {\n  /* istanbul ignore if */\n  if (isServer()) return false;\n  return _isIE();\n}\n\nexport function insertChildrenIntoSlot(h, parentVnode, childVNode, data) {\n  parentVnode = parentVnode[0] ? parentVnode[0] : parentVnode;\n\n  const isComponent = !!parentVnode.componentOptions;\n\n  const tag = isComponent ? parentVnode.componentOptions.tag : parentVnode.tag;\n\n  const _data = parentVnode.componentOptions || parentVnode.data || {};\n\n  if (isComponent) {\n    data.nativeOn = data.on;\n    _data.props = _data.propsData;\n\n    delete data.on;\n    delete data.propsData;\n  }\n\n  return h(\n    tag,\n    {\n      ...data,\n      ..._data\n    },\n    childVNode\n  );\n}\n\nexport function getRealParent(ctx) {\n  let parent = ctx.$parent;\n\n  if (!parent._isVuescrollRoot && parent) {\n    parent = parent.$parent;\n  }\n\n  return parent;\n}\n","import { extractNumberFromPx } from '../../util';\n\nexport default {\n  methods: {\n    updateNativeModeBarState() {\n      const scrollPanel = this.scrollPanelElm;\n      const vuescroll = this.$el;\n      const isPercent = this.mergedOptions.vuescroll.sizeStrategy == 'percent';\n\n      const clientWidth = isPercent\n        ? vuescroll.clientWidth\n        : extractNumberFromPx(this.vuescroll.state.width);\n      const clientHeight = isPercent\n        ? vuescroll.clientHeight\n        : extractNumberFromPx(this.vuescroll.state.height);\n\n      let heightPercentage = (clientHeight * 100) / scrollPanel.scrollHeight;\n      let widthPercentage = (clientWidth * 100) / scrollPanel.scrollWidth;\n\n      this.bar.vBar.state.posValue =\n        (scrollPanel.scrollTop * 100) / clientHeight;\n      this.bar.hBar.state.posValue =\n        (scrollPanel.scrollLeft * 100) / clientWidth;\n\n      this.bar.vBar.state.size =\n        heightPercentage < 100 ? heightPercentage + '%' : 0;\n      this.bar.hBar.state.size =\n        widthPercentage < 100 ? widthPercentage + '%' : 0;\n    }\n  }\n};\n","/**\n *  Compatible to scroller's animation function\n */\nexport function createEasingFunction(easing, easingPattern) {\n  return function(time) {\n    return easingPattern(easing, time);\n  };\n}\n\n/**\n * Calculate the easing pattern\n * @link https://github.com/cferdinandi/smooth-scroll/blob/master/src/js/smooth-scroll.js\n * modified by wangyi7099\n * @param {String} type Easing pattern\n * @param {Number} time Time animation should take to complete\n * @returns {Number}\n */\nexport function easingPattern(easing, time) {\n  let pattern = null;\n  /* istanbul ignore next */\n  {\n    // Default Easing Patterns\n    if (easing === 'easeInQuad') pattern = time * time; // accelerating from zero velocity\n    if (easing === 'easeOutQuad') pattern = time * (2 - time); // decelerating to zero velocity\n    if (easing === 'easeInOutQuad')\n      pattern = time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time; // acceleration until halfway, then deceleration\n    if (easing === 'easeInCubic') pattern = time * time * time; // accelerating from zero velocity\n    if (easing === 'easeOutCubic') pattern = --time * time * time + 1; // decelerating to zero velocity\n    if (easing === 'easeInOutCubic')\n      pattern =\n        time < 0.5\n          ? 4 * time * time * time\n          : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1; // acceleration until halfway, then deceleration\n    if (easing === 'easeInQuart') pattern = time * time * time * time; // accelerating from zero velocity\n    if (easing === 'easeOutQuart') pattern = 1 - --time * time * time * time; // decelerating to zero velocity\n    if (easing === 'easeInOutQuart')\n      pattern =\n        time < 0.5\n          ? 8 * time * time * time * time\n          : 1 - 8 * --time * time * time * time; // acceleration until halfway, then deceleration\n    if (easing === 'easeInQuint') pattern = time * time * time * time * time; // accelerating from zero velocity\n    if (easing === 'easeOutQuint')\n      pattern = 1 + --time * time * time * time * time; // decelerating to zero velocity\n    if (easing === 'easeInOutQuint')\n      pattern =\n        time < 0.5\n          ? 16 * time * time * time * time * time\n          : 1 + 16 * --time * time * time * time * time; // acceleration until halfway, then deceleration\n  }\n  return pattern || time; // no easing, no acceleration\n}\n","/*\n * Scroller\n * http://github.com/zynga/scroller\n *\n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n *\n * Based on the work of: Unify Project (unify-project.org)\n * http://unify-project.org\n * Copyright 2011, Deutsche Telekom AG\n * License: MIT + Apache (V2)\n */\n\n/**\n * Generic animation class with support for dropped frames both optional easing and duration.\n *\n * Optional duration is useful when the lifetime is defined by another condition than time\n * e.g. speed of an animating object, etc.\n *\n * Dropped frame logic allows to keep using the same updater logic independent from the actual\n * rendering. This eases a lot of cases where it might be pretty complex to break down a state\n * based on the pure time difference.\n */\nimport { requestAnimationFrame } from './requestAnimationFrame';\n\nvar time =\n  Date.now ||\n  function() {\n    return +new Date();\n  };\nvar desiredFrames = 60;\nvar millisecondsPerSecond = 1000;\nvar running = {};\nvar counter = 1;\n\nconst core = { effect: {} };\nlet global = null;\n\nif (typeof window !== 'undefined') {\n  global = window;\n} else {\n  global = {};\n}\n\ncore.effect.Animate = {\n  /**\n   * A requestAnimationFrame wrapper / polyfill.\n   *\n   * @param callback {Function} The callback to be invoked before the next repaint.\n   * @param root {HTMLElement} The root element for the repaint\n   */\n  requestAnimationFrame: requestAnimationFrame(global),\n  /**\n   * Stops the given animation.\n   *\n   * @param id {Integer} Unique animation ID\n   * @return {Boolean} Whether the animation was stopped (aka, was running before)\n   */\n  stop: function(id) {\n    var cleared = running[id] != null;\n    if (cleared) {\n      running[id] = null;\n    }\n\n    return cleared;\n  },\n\n  /**\n   * Whether the given animation is still running.\n   *\n   * @param id {Integer} Unique animation ID\n   * @return {Boolean} Whether the animation is still running\n   */\n  isRunning: function(id) {\n    return running[id] != null;\n  },\n\n  /**\n   * Start the animation.\n   *\n   * @param stepCallback {Function} Pointer to function which is executed on every step.\n   *   Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`\n   * @param verifyCallback {Function} Executed before every animation step.\n   *   Signature of the method should be `function() { return continueWithAnimation; }`\n   * @param completedCallback {Function}\n   *   Signature of the method should be `function(droppedFrames, finishedAnimation) {}`\n   * @param duration {Integer} Milliseconds to run the animation\n   * @param easingMethod {Function} Pointer to easing function\n   *   Signature of the method should be `function(percent) { return modifiedValue; }`\n   * @param root {Element ? document.body} Render root, when available. Used for internal\n   *   usage of requestAnimationFrame.\n   * @return {Integer} Identifier of animation. Can be used to stop it any time.\n   */\n  start: function(\n    stepCallback,\n    verifyCallback,\n    completedCallback,\n    duration,\n    easingMethod,\n    root\n  ) {\n    var start = time();\n    var lastFrame = start;\n    var percent = 0;\n    var dropCounter = 0;\n    var id = counter++;\n\n    if (!root) {\n      root = document.body;\n    }\n\n    // Compacting running db automatically every few new animations\n    if (id % 20 === 0) {\n      var newRunning = {};\n      for (var usedId in running) {\n        newRunning[usedId] = true;\n      }\n      running = newRunning;\n    }\n\n    // This is the internal step method which is called every few milliseconds\n    var step = function(virtual) {\n      // Normalize virtual value\n      var render = virtual !== true;\n\n      // Get current time\n      var now = time();\n\n      // Verification is executed before next animation step\n      if (!running[id] || (verifyCallback && !verifyCallback(id))) {\n        running[id] = null;\n        completedCallback &&\n          completedCallback(\n            desiredFrames -\n              dropCounter / ((now - start) / millisecondsPerSecond),\n            id,\n            false\n          );\n        return;\n      }\n\n      // For the current rendering to apply let's update omitted steps in memory.\n      // This is important to bring internal state variables up-to-date with progress in time.\n      if (render) {\n        var droppedFrames =\n          Math.round(\n            (now - lastFrame) / (millisecondsPerSecond / desiredFrames)\n          ) - 1;\n        for (var j = 0; j < Math.min(droppedFrames, 4); j++) {\n          step(true);\n          dropCounter++;\n        }\n      }\n\n      // Compute percent value\n      if (duration) {\n        percent = (now - start) / duration;\n        if (percent > 1) {\n          percent = 1;\n        }\n      }\n\n      // Execute step callback, then...\n      var value = easingMethod ? easingMethod(percent) : percent;\n      if (\n        (stepCallback(value, now, render) === false || percent === 1) &&\n        render\n      ) {\n        running[id] = null;\n        completedCallback &&\n          completedCallback(\n            desiredFrames -\n              dropCounter / ((now - start) / millisecondsPerSecond),\n            id,\n            percent === 1 || duration == null\n          );\n      } else if (render) {\n        lastFrame = now;\n        core.effect.Animate.requestAnimationFrame(step, root);\n      }\n    };\n\n    // Mark as running\n    running[id] = true;\n\n    // Init first step\n    core.effect.Animate.requestAnimationFrame(step, root);\n\n    // Return unique animation ID\n    return id;\n  }\n};\n\nexport { core };\n","export function requestAnimationFrame(global) {\n  // Check for request animation Frame support\n  var requestFrame =\n    global.requestAnimationFrame ||\n    global.webkitRequestAnimationFrame ||\n    global.mozRequestAnimationFrame ||\n    global.oRequestAnimationFrame;\n  var isNative = !!requestFrame;\n\n  if (\n    requestFrame &&\n    !/requestAnimationFrame\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}/i.test(\n      requestFrame.toString()\n    )\n  ) {\n    isNative = false;\n  }\n\n  if (isNative) {\n    return function(callback, root) {\n      requestFrame(callback, root);\n    };\n  }\n\n  var TARGET_FPS = 60;\n  var requests = {};\n  var rafHandle = 1;\n  var intervalHandle = null;\n  var lastActive = +new Date();\n\n  return function(callback) {\n    var callbackHandle = rafHandle++;\n\n    // Store callback\n    requests[callbackHandle] = callback;\n    requestCount++;\n\n    // Create timeout at first request\n    if (intervalHandle === null) {\n      intervalHandle = setInterval(function() {\n        var time = +new Date();\n        var currentRequests = requests;\n\n        // Reset data structure before executing callbacks\n        requests = {};\n        requestCount = 0;\n\n        for (var key in currentRequests) {\n          if (currentRequests.hasOwnProperty(key)) {\n            currentRequests[key](time);\n            lastActive = time;\n          }\n        }\n\n        // Disable the timeout when nothing happens for a certain\n        // period of time\n        if (time - lastActive > 2500) {\n          clearInterval(intervalHandle);\n          intervalHandle = null;\n        }\n      }, 1000 / TARGET_FPS);\n    }\n\n    return callbackHandle;\n  };\n}\n","// all modes\nexport const modes = ['slide', 'native'];\n// do nothing\nexport const NOOP = () => {};\n// some small changes.\nexport const smallChangeArray = [\n  'mergedOptions.vuescroll.pullRefresh.tips',\n  'mergedOptions.vuescroll.pushLoad.tips',\n  'mergedOptions.rail',\n  'mergedOptions.bar'\n];\n","/*\n * Scroller\n * http://github.com/zynga/scroller\n *\n * modified by wangyi7099\n * \n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n *\n * Based on the work of: Unify Project (unify-project.org)\n * http://unify-project.org\n * Copyright 2011, Deutsche Telekom AG\n * License: MIT + Apache (V2)\n */\nimport { easingPattern, createEasingFunction } from '../easingPattern';\nimport { core } from './animate';\nimport { NOOP } from '../../shared/constants';\n\nvar animatingMethod = null;\n\nvar noAnimatingMethod = null;\n\nexport default function Scroller(callback, options) {\n  this.__callback = callback;\n\n  this.options = {\n    /** Enable scrolling on x-axis */\n    scrollingX: true,\n\n    /** Enable scrolling on y-axis */\n    scrollingY: true,\n\n    /** Enable animations for deceleration, snap back, zooming and scrolling */\n    animating: true,\n\n    /** duration for animations triggered by scrollTo/zoomTo */\n    animationDuration: 250,\n\n    /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\n    bouncing: true,\n\n    /** Enable locking to the main axis if user moves only slightly on one of them at start */\n    locking: true,\n\n    /** Enable pagination mode (switching between full page content panes) */\n    paging: false,\n\n    /** Enable snapping of content to a configured pixel grid */\n    snapping: false,\n\n    /** Enable zooming of content via API, fingers and mouse wheel */\n    zooming: false,\n\n    /** Minimum zoom level */\n    minZoom: 0.5,\n\n    /** Maximum zoom level */\n    maxZoom: 3,\n\n    /** Multiply or decrease scrolling speed **/\n    speedMultiplier: 1,\n\n    /** Callback that is fired on the later of touch end or deceleration end,\n\t\t\t\tprovided that another scrolling action has not begun. Used to know\n\t\t\t\twhen to fade out a scrollbar. */\n    scrollingComplete: NOOP,\n\n    animatingEasing: 'easeOutCubic',\n\n    noAnimatingEasing: 'easeInOutCubic',\n\n    /** This configures the amount of change applied to deceleration when reaching boundaries  **/\n    penetrationDeceleration: 0.03,\n\n    /** This configures the amount of change applied to acceleration when reaching boundaries  **/\n    penetrationAcceleration: 0.08\n  };\n\n  for (var key in options) {\n    this.options[key] = options[key];\n  }\n\n  animatingMethod = createEasingFunction(\n    this.options.animatingEasing,\n    easingPattern\n  );\n  noAnimatingMethod = createEasingFunction(\n    this.options.noAnimatingEasing,\n    easingPattern\n  );\n}\n\nvar members = {\n  /*\n\t---------------------------------------------------------------------------\n\t\tINTERNAL FIELDS :: STATUS\n\t---------------------------------------------------------------------------\n\t*/\n\n  /** {Boolean} Whether only a single finger is used in touch handling */\n  __isSingleTouch: false,\n\n  /** {Boolean} Whether a touch event sequence is in progress */\n  __isTracking: false,\n\n  /** {Boolean} Whether a deceleration animation went to completion. */\n  __didDecelerationComplete: false,\n\n  /**\n   * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when\n   * a gesturestart event happens. This has higher priority than dragging.\n   */\n  __isGesturing: false,\n\n  /**\n   * {Boolean} Whether the user has moved by such a distance that we have enabled\n   * dragging mode. Hint: It's only enabled after some pixels of movement to\n   * not interrupt with clicks etc.\n   */\n  __isDragging: false,\n\n  /**\n   * {Boolean} Not touching and dragging anymore, and smoothly animating the\n   * touch sequence using deceleration.\n   */\n  __isDecelerating: false,\n\n  /**\n   * {Boolean} Smoothly animating the currently configured change\n   */\n  __isAnimating: false,\n\n  /*\n\t---------------------------------------------------------------------------\n\t\tINTERNAL FIELDS :: DIMENSIONS\n\t---------------------------------------------------------------------------\n\t*/\n\n  /** {Integer} Available outer left position (from document perspective) */\n  __clientLeft: 0,\n\n  /** {Integer} Available outer top position (from document perspective) */\n  __clientTop: 0,\n\n  /** {Integer} Available outer width */\n  __clientWidth: 0,\n\n  /** {Integer} Available outer height */\n  __clientHeight: 0,\n\n  /** {Integer} Outer width of content */\n  __contentWidth: 0,\n\n  /** {Integer} Outer height of content */\n  __contentHeight: 0,\n\n  /** {Integer} Snapping width for content */\n  __snapWidth: 100,\n\n  /** {Integer} Snapping height for content */\n  __snapHeight: 100,\n\n  /** {Integer} Height to assign to refresh area */\n  __refreshHeight: null,\n  /** {Integer} Height to assign to refresh area */\n  __loadHeight: null,\n  /** {Boolean} Whether the refresh process is enabled when the event is released now */\n  __refreshActive: false,\n\n  /** {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release */\n  __refreshActivate: null,\n\n  __refreshBeforeDeactivate: null,\n\n  /** {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled */\n  __refreshDeactivate: null,\n\n  /** {Function} Callback to execute to start the actual refresh. Call {@link #refreshFinish} when done */\n  __refreshStart: null,\n\n  __loadActive: null,\n\n  __loadActivate: null,\n\n  __loadBeforeDeactivate: null,\n\n  __loadDeactivate: null,\n\n  __loadStart: null,\n  /** {Number} Zoom level */\n  __zoomLevel: 1,\n\n  /** {Number} Scroll position on x-axis */\n  __scrollLeft: 0,\n\n  /** {Number} Scroll position on y-axis */\n  __scrollTop: 0,\n\n  /** {Integer} Maximum allowed scroll position on x-axis */\n  __maxScrollLeft: 0,\n\n  /** {Integer} Maximum allowed scroll position on y-axis */\n  __maxScrollTop: 0,\n\n  /* {Number} Scheduled left position (final position when animating) */\n  __scheduledLeft: 0,\n\n  /* {Number} Scheduled top position (final position when animating) */\n  __scheduledTop: 0,\n\n  /* {Number} Scheduled zoom level (final scale when animating) */\n  __scheduledZoom: 0,\n\n  /**\n   * current page\n   */\n  __currentPageX: null,\n\n  __currentPageY: null,\n\n  /**\n   * total page\n   */\n  __totalXPage: null,\n\n  __totalYPage: null,\n  /*\n\t---------------------------------------------------------------------------\n\t\tINTERNAL FIELDS :: LAST POSITIONS\n\t---------------------------------------------------------------------------\n\t*/\n  /** whether the scroller is disabled or not */\n  __disable: false,\n  /** {Number} Left position of finger at start */\n  __lastTouchLeft: null,\n\n  /** {Number} Top position of finger at start */\n  __lastTouchTop: null,\n\n  /** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */\n  __lastTouchMove: null,\n\n  /** {Array} List of positions, uses three indexes for each state: left, top, timestamp */\n  __positions: null,\n\n  /*\n\t---------------------------------------------------------------------------\n\t\tINTERNAL FIELDS :: DECELERATION SUPPORT\n\t---------------------------------------------------------------------------\n\t*/\n\n  /** {Integer} Minimum left scroll position during deceleration */\n  __minDecelerationScrollLeft: null,\n\n  /** {Integer} Minimum top scroll position during deceleration */\n  __minDecelerationScrollTop: null,\n\n  /** {Integer} Maximum left scroll position during deceleration */\n  __maxDecelerationScrollLeft: null,\n\n  /** {Integer} Maximum top scroll position during deceleration */\n  __maxDecelerationScrollTop: null,\n\n  /** {Number} Current factor to modify horizontal scroll position with on every step */\n  __decelerationVelocityX: null,\n\n  /** {Number} Current factor to modify vertical scroll position with on every step */\n  __decelerationVelocityY: null,\n\n  /*\n\t---------------------------------------------------------------------------\n\t\tPUBLIC API\n\t---------------------------------------------------------------------------\n\t*/\n\n  /**\n   * Configures the dimensions of the client (outer) and content (inner) elements.\n   * Requires the available space for the outer element and the outer size of the inner element.\n   * All values which are falsy (null or zero etc.) are ignored and the old value is kept.\n   *\n   * @param clientWidth {Integer ? null} Inner width of outer element\n   * @param clientHeight {Integer ? null} Inner height of outer element\n   * @param contentWidth {Integer ? null} Outer width of inner element\n   * @param contentHeight {Integer ? null} Outer height of inner element\n   */\n  setDimensions: function(\n    clientWidth,\n    clientHeight,\n    contentWidth,\n    contentHeight,\n    animate,\n    noScroll = false\n  ) {\n    var self = this;\n\n    // Only update values which are defined\n    if (clientWidth === +clientWidth) {\n      self.__clientWidth = clientWidth;\n    }\n\n    if (clientHeight === +clientHeight) {\n      self.__clientHeight = clientHeight;\n    }\n\n    if (contentWidth === +contentWidth) {\n      self.__contentWidth = contentWidth;\n    }\n\n    if (contentHeight === +contentHeight) {\n      self.__contentHeight = contentHeight;\n    }\n\n    // Refresh maximums\n    self.__computeScrollMax();\n\n    if (!noScroll) {\n      // Refresh scroll position\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, animate);\n    }\n  },\n\n  /**\n   * Sets the client coordinates in relation to the document.\n   *\n   * @param left {Integer ? 0} Left position of outer element\n   * @param top {Integer ? 0} Top position of outer element\n   */\n  setPosition: function(left, top) {\n    var self = this;\n\n    self.__clientLeft = left || 0;\n    self.__clientTop = top || 0;\n  },\n\n  /**\n   * Configures the snapping (when snapping is active)\n   *\n   * @param width {Integer} Snapping width\n   * @param height {Integer} Snapping height\n   */\n  setSnapSize: function(width, height) {\n    var self = this;\n\n    self.__snapWidth = width;\n    self.__snapHeight = height;\n  },\n\n  /**\n   * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever\n   * the user event is released during visibility of this zone. This was introduced by some apps on iOS like\n   * the official Twitter client.\n   *\n   * @param height {Integer} Height of pull-to-refresh zone on top of rendered list\n   * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.\n   * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.\n   * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.\n   */\n  activatePullToRefresh: function(\n    height,\n    {\n      activateCallback,\n      deactivateCallback,\n      startCallback,\n      beforeDeactivateCallback\n    }\n  ) {\n    var self = this;\n\n    self.__refreshHeight = height;\n    self.__refreshActivate = activateCallback;\n    self.__refreshBeforeDeactivate = beforeDeactivateCallback;\n    self.__refreshDeactivate = deactivateCallback;\n    self.__refreshStart = startCallback;\n  },\n  activatePushToLoad: function(\n    height,\n    {\n      activateCallback,\n      deactivateCallback,\n      startCallback,\n      beforeDeactivateCallback\n    }\n  ) {\n    var self = this;\n\n    self.__loadHeight = height;\n    self.__loadActivate = activateCallback;\n    self.__loadBeforeDeactivate = beforeDeactivateCallback;\n    self.__loadDeactivate = deactivateCallback;\n    self.__loadStart = startCallback;\n  },\n\n  /**\n   * Starts pull-to-refresh manually.\n   */\n  triggerRefreshOrLoad: function(type = 'refresh') {\n    var wasDecelerating = this.__isDecelerating;\n    if (wasDecelerating) {\n      core.effect.Animate.stop(wasDecelerating);\n      this.__isDecelerating = false;\n    }\n    // Use publish instead of scrollTo to allow scrolling to out of boundary position\n    // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n    if (type == 'refresh') {\n      this.__publish(\n        this.__scrollLeft,\n        -this.__refreshHeight,\n        this.__zoomLevel,\n        true\n      );\n      if (this.__refreshStart) {\n        this.__refreshStart();\n        this.__refreshActive = true;\n      }\n    } else {\n      this.__publish(\n        this.__scrollLeft,\n        this.__maxScrollTop + this.__loadHeight,\n        this.__zoomLevel,\n        true\n      );\n      if (this.__loadStart) {\n        this.__loadStart();\n        this.__loadActive = true;\n      }\n    }\n  },\n\n  /**\n   * Signalizes that pull-to-refresh is finished.\n   */\n  finishRefreshOrLoad: function() {\n    var self = this;\n\n    if (self.__refreshBeforeDeactivate && self.__refreshActive) {\n      self.__refreshActive = false;\n      self.__refreshBeforeDeactivate(function() {\n        if (self.__refreshDeactivate) {\n          self.__refreshDeactivate();\n        }\n        self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n      });\n    } else if (self.__refreshDeactivate && self.__refreshActive) {\n      self.__refreshActive = false;\n      self.__refreshDeactivate();\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n    }\n\n    if (self.__loadBeforeDeactivate && self.__loadActive) {\n      self.__loadActive = false;\n      self.__loadBeforeDeactivate(function() {\n        if (self.__loadDeactivate) {\n          self.__loadDeactivate();\n        }\n        self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n      });\n    } else if (self.__loadDeactivate && self.__loadActive) {\n      self.__loadActive = false;\n      self.__loadDeactivate();\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n    }\n  },\n\n  /**\n   * Returns the scroll position and zooming values\n   *\n   * @return {Map} `left` and `top` scroll position and `zoom` level\n   */\n  getValues: function() {\n    var self = this;\n\n    return {\n      left: self.__scrollLeft,\n      top: self.__scrollTop,\n      zoom: self.__zoomLevel\n    };\n  },\n\n  /**\n   * Returns the maximum scroll values\n   *\n   * @return {Map} `left` and `top` maximum scroll values\n   */\n  getScrollMax: function() {\n    var self = this;\n\n    return {\n      left: self.__maxScrollLeft,\n      top: self.__maxScrollTop\n    };\n  },\n\n  /**\n   * Zooms to the given level. Supports optional animation. Zooms\n   * the center when no coordinates are given.\n   *\n   * @param level {Number} Level to zoom to\n   * @param animate {Boolean ? false} Whether to use animation\n   * @param originLeft {Number ? null} Zoom in at given left coordinate\n   * @param originTop {Number ? null} Zoom in at given top coordinate\n   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n   */\n  zoomTo: function(level, animate, originLeft, originTop, callback) {\n    var self = this;\n\n    if (!self.options.zooming) {\n      throw new Error('Zooming is not enabled!');\n    }\n\n    // Add callback if exists\n    if (callback) {\n      self.__zoomComplete = callback;\n    }\n\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      core.effect.Animate.stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n    }\n\n    var oldLevel = self.__zoomLevel;\n\n    // Normalize input origin to center of viewport if not defined\n    if (originLeft == null) {\n      originLeft = self.__clientWidth / 2;\n    }\n\n    if (originTop == null) {\n      originTop = self.__clientHeight / 2;\n    }\n\n    // Limit level according to configuration\n    level = Math.max(\n      Math.min(level, self.options.maxZoom),\n      self.options.minZoom\n    );\n\n    // Recompute maximum values while temporary tweaking maximum scroll ranges\n    self.__computeScrollMax(level);\n\n    // Recompute left and top coordinates based on new zoom level\n    var left =\n      ((originLeft + self.__scrollLeft) * level) / oldLevel - originLeft;\n    var top = ((originTop + self.__scrollTop) * level) / oldLevel - originTop;\n\n    // Limit x-axis\n    if (left > self.__maxScrollLeft) {\n      left = self.__maxScrollLeft;\n    } else if (left < 0) {\n      left = 0;\n    }\n\n    // Limit y-axis\n    if (top > self.__maxScrollTop) {\n      top = self.__maxScrollTop;\n    } else if (top < 0) {\n      top = 0;\n    }\n\n    // Push values out\n    self.__publish(left, top, level, animate);\n  },\n\n  /**\n   * Zooms the content by the given factor.\n   *\n   * @param factor {Number} Zoom by given factor\n   * @param animate {Boolean ? false} Whether to use animation\n   * @param originLeft {Number ? 0} Zoom in at given left coordinate\n   * @param originTop {Number ? 0} Zoom in at given top coordinate\n   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n   */\n  zoomBy: function(factor, animate, originLeft, originTop, callback) {\n    var self = this;\n\n    self.zoomTo(\n      self.__zoomLevel * factor,\n      animate,\n      originLeft,\n      originTop,\n      callback\n    );\n  },\n\n  /**\n   * Scrolls to the given position. Respect limitations and snapping automatically.\n   *\n   * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>\n   * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>\n   * @param animate {Boolean?false} Whether the scrolling should happen using an animation\n   * @param zoom {Number?null} Zoom level to go to\n   */\n  scrollTo: function(left, top, animate, zoom, force) {\n    var self = this;\n\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      core.effect.Animate.stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n    }\n\n    // Correct coordinates based on new zoom level\n    if (zoom != null && zoom !== self.__zoomLevel) {\n      if (!self.options.zooming) {\n        throw new Error('Zooming is not enabled!');\n      }\n\n      left *= zoom;\n      top *= zoom;\n\n      // Recompute maximum values while temporary tweaking maximum scroll ranges\n      self.__computeScrollMax(zoom);\n    } else {\n      // Keep zoom when not defined\n      zoom = self.__zoomLevel;\n    }\n\n    if (!self.options.scrollingX && !force) {\n      left = self.__scrollLeft;\n    } else {\n      if (self.options.paging) {\n        left = Math.round(left / self.__clientWidth) * self.__clientWidth;\n      } else if (self.options.snapping) {\n        left = Math.round(left / self.__snapWidth) * self.__snapWidth;\n      }\n    }\n\n    if (!self.options.scrollingY && !force) {\n      top = self.__scrollTop;\n    } else {\n      if (self.options.paging) {\n        top = Math.round(top / self.__clientHeight) * self.__clientHeight;\n      } else if (self.options.snapping) {\n        top = Math.round(top / self.__snapHeight) * self.__snapHeight;\n      }\n    }\n\n    // Limit for allowed ranges\n    left = Math.max(Math.min(self.__maxScrollLeft, left), 0);\n    top = Math.max(Math.min(self.__maxScrollTop, top), 0);\n    // Don't animate when no change detected, still call publish to make sure\n    // that rendered position is really in-sync with internal data\n    if (left === self.__scrollLeft && top === self.__scrollTop) {\n      animate = false;\n    }\n\n    // Publish new values\n    if (!self.__isTracking) {\n      self.__publish(left, top, zoom, animate);\n    }\n  },\n\n  /**\n   * Scroll by the given offset\n   *\n   * @param left {Number ? 0} Scroll x-axis by given offset\n   * @param top {Number ? 0} Scroll x-axis by given offset\n   * @param animate {Boolean ? false} Whether to animate the given change\n   */\n  scrollBy: function(left, top, animate) {\n    var self = this;\n\n    var startLeft = self.__isAnimating\n      ? self.__scheduledLeft\n      : self.__scrollLeft;\n    var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;\n\n    self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);\n  },\n  getCurrentPage() {\n    this.__computePage();\n    return {\n      x: this.__currentPageX,\n      y: this.__currentPageY\n    };\n  },\n\n  goToPage({ x, y }, animate) {\n    if (isNaN(x)) {\n      x = 1;\n    }\n    if (isNaN(y)) {\n      y = 1;\n    }\n    this.scrollTo(\n      (x - 1) * this.__clientWidth,\n      (y - 1) * this.__clientHeight,\n      animate\n    );\n  },\n\n  /*\n\t---------------------------------------------------------------------------\n\t\tEVENT CALLBACKS\n\t---------------------------------------------------------------------------\n\t*/\n\n  /**\n   * Mouse wheel handler for zooming support\n   */\n  doMouseZoom: function(wheelDelta, timeStamp, pageX, pageY) {\n    var self = this;\n    var change = wheelDelta > 0 ? 0.97 : 1.03;\n\n    return self.zoomTo(\n      self.__zoomLevel * change,\n      false,\n      pageX - self.__clientLeft,\n      pageY - self.__clientTop\n    );\n  },\n\n  /**\n   * Touch start handler for scrolling support\n   */\n  doTouchStart: function(touches, timeStamp) {\n    // Array-like check is enough here\n    if (touches.length == null) {\n      throw new Error('Invalid touch list: ' + touches);\n    }\n\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== 'number') {\n      throw new Error('Invalid timestamp value: ' + timeStamp);\n    }\n\n    var self = this;\n\n    // Reset interruptedAnimation flag\n    self.__interruptedAnimation = true;\n\n    // Stop deceleration\n    if (self.__isDecelerating) {\n      core.effect.Animate.stop(self.__isDecelerating);\n      self.__isDecelerating = false;\n      self.__interruptedAnimation = true;\n    }\n\n    // Stop animation\n    if (self.__isAnimating) {\n      core.effect.Animate.stop(self.__isAnimating);\n      self.__isAnimating = false;\n      self.__interruptedAnimation = true;\n    }\n\n    // Use center point when dealing with two fingers\n    var currentTouchLeft, currentTouchTop;\n    var isSingleTouch = touches.length === 1;\n    if (isSingleTouch) {\n      currentTouchLeft = touches[0].pageX;\n      currentTouchTop = touches[0].pageY;\n    } else {\n      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n    }\n\n    // Store initial positions\n    self.__initialTouchLeft = currentTouchLeft;\n    self.__initialTouchTop = currentTouchTop;\n\n    // Store current zoom level\n    self.__zoomLevelStart = self.__zoomLevel;\n\n    // Store initial touch positions\n    self.__lastTouchLeft = currentTouchLeft;\n    self.__lastTouchTop = currentTouchTop;\n\n    // Store initial move time stamp\n    self.__lastTouchMove = timeStamp;\n\n    // Reset initial scale\n    self.__lastScale = 1;\n\n    // Reset locking flags\n    self.__enableScrollX = !isSingleTouch && self.options.scrollingX;\n    self.__enableScrollY = !isSingleTouch && self.options.scrollingY;\n\n    // Reset tracking flag\n    self.__isTracking = true;\n\n    // Reset deceleration complete flag\n    self.__didDecelerationComplete = false;\n\n    // Dragging starts directly with two fingers, otherwise lazy with an offset\n    self.__isDragging = !isSingleTouch;\n\n    // Some features are  in multi touch scenarios\n    self.__isSingleTouch = isSingleTouch;\n\n    // Clearing data structure\n    self.__positions = [];\n  },\n\n  /**\n   * Touch move handler for scrolling support\n   */\n  doTouchMove: function(touches, timeStamp, scale) {\n    // Array-like check is enough here\n    if (touches.length == null) {\n      throw new Error('Invalid touch list: ' + touches);\n    }\n\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== 'number') {\n      throw new Error('Invalid timestamp value: ' + timeStamp);\n    }\n\n    var self = this;\n\n    // Ignore event when tracking is not enabled (event might be outside of element)\n    if (!self.__isTracking) {\n      return;\n    }\n\n    var currentTouchLeft, currentTouchTop;\n\n    // Compute move based around of center of fingers\n    if (touches.length === 2) {\n      currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n      currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n    } else {\n      currentTouchLeft = touches[0].pageX;\n      currentTouchTop = touches[0].pageY;\n    }\n\n    var positions = self.__positions;\n\n    // Are we already is dragging mode?\n    if (self.__isDragging) {\n      // Compute move distance\n      var moveX = currentTouchLeft - self.__lastTouchLeft;\n      var moveY = currentTouchTop - self.__lastTouchTop;\n\n      // Read previous scroll position and zooming\n      var scrollLeft = self.__scrollLeft;\n      var scrollTop = self.__scrollTop;\n      var level = self.__zoomLevel;\n\n      // Work with scaling\n      if (scale != null && self.options.zooming) {\n        var oldLevel = level;\n\n        // Recompute level based on previous scale and new scale\n        level = (level / self.__lastScale) * scale;\n\n        // Limit level according to configuration\n        level = Math.max(\n          Math.min(level, self.options.maxZoom),\n          self.options.minZoom\n        );\n\n        // Only do further compution when change happened\n        if (oldLevel !== level) {\n          // Compute relative event position to container\n          var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;\n          var currentTouchTopRel = currentTouchTop - self.__clientTop;\n\n          // Recompute left and top coordinates based on new zoom level\n          scrollLeft =\n            ((currentTouchLeftRel + scrollLeft) * level) / oldLevel -\n            currentTouchLeftRel;\n          scrollTop =\n            ((currentTouchTopRel + scrollTop) * level) / oldLevel -\n            currentTouchTopRel;\n\n          // Recompute max scroll values\n          self.__computeScrollMax(level);\n        }\n      }\n\n      if (self.__enableScrollX) {\n        scrollLeft -= moveX * this.options.speedMultiplier;\n        var maxScrollLeft = self.__maxScrollLeft;\n\n        if (scrollLeft > maxScrollLeft || scrollLeft < 0) {\n          // Slow down on the edges\n          if (self.options.bouncing) {\n            scrollLeft += (moveX / 2) * this.options.speedMultiplier;\n          } else if (scrollLeft > maxScrollLeft) {\n            scrollLeft = maxScrollLeft;\n          } else {\n            scrollLeft = 0;\n          }\n        }\n      }\n\n      // Compute new vertical scroll position\n      if (self.__enableScrollY) {\n        scrollTop -= moveY * this.options.speedMultiplier;\n        var maxScrollTop = self.__maxScrollTop;\n\n        if (scrollTop > maxScrollTop || scrollTop < 0) {\n          // Slow down on the edges\n          if (self.options.bouncing) {\n            scrollTop += (moveY / 2) * this.options.speedMultiplier;\n\n            // Support pull-to-refresh (only when only y is scrollable)\n            if (\n              !self.__enableScrollX &&\n              (self.__refreshHeight != null || self.__loadHeight != null)\n            ) {\n              if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {\n                self.__refreshActive = true;\n                if (self.__refreshActivate) {\n                  self.__refreshActivate();\n                }\n              } else if (\n                self.__refreshActive &&\n                scrollTop > -self.__refreshHeight\n              ) {\n                self.__refreshActive = false;\n                if (self.__refreshDeactivate) {\n                  self.__refreshDeactivate();\n                }\n              }\n              // handle for push-load\n              else if (\n                !self.__loadActive &&\n                scrollTop >= self.__maxScrollTop + self.__loadHeight &&\n                self.__loadHeight > 0\n              ) {\n                self.__loadActive = true;\n                if (self.__loadActivate) {\n                  self.__loadActivate();\n                }\n              } else if (\n                self.__loadActive &&\n                scrollTop < self.__maxScrollTop + self.__loadHeight\n              ) {\n                self.__loadActive = false;\n                if (self.__loadDeactivate) {\n                  self.__loadDeactivate();\n                }\n              }\n            }\n          } else if (scrollTop > maxScrollTop) {\n            scrollTop = maxScrollTop;\n          } else {\n            scrollTop = 0;\n          }\n        }\n      }\n\n      // Keep list from growing infinitely (holding min 10, max 20 measure points)\n      if (positions.length > 60) {\n        positions.splice(0, 30);\n      }\n\n      // Track scroll movement for decleration\n      positions.push(scrollLeft, scrollTop, timeStamp);\n\n      // Sync scroll position\n      self.__publish(scrollLeft, scrollTop, level);\n\n      // Otherwise figure out whether we are switching into dragging mode now.\n    } else {\n      var minimumTrackingForScroll = self.options.locking ? 3 : 0;\n      var minimumTrackingForDrag = 5;\n\n      var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);\n      var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);\n\n      self.__enableScrollX =\n        self.options.scrollingX && distanceX >= minimumTrackingForScroll;\n      self.__enableScrollY =\n        self.options.scrollingY && distanceY >= minimumTrackingForScroll;\n\n      positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);\n\n      self.__isDragging =\n        (self.__enableScrollX || self.__enableScrollY) &&\n        (distanceX >= minimumTrackingForDrag ||\n          distanceY >= minimumTrackingForDrag);\n      if (self.__isDragging) {\n        self.__interruptedAnimation = false;\n      }\n    }\n\n    // Update last touch positions and time stamp for next event\n    self.__lastTouchLeft = currentTouchLeft;\n    self.__lastTouchTop = currentTouchTop;\n    self.__lastTouchMove = timeStamp;\n    self.__lastScale = scale;\n  },\n\n  /**\n   * Touch end handler for scrolling support\n   */\n  doTouchEnd: function(timeStamp) {\n    if (timeStamp instanceof Date) {\n      timeStamp = timeStamp.valueOf();\n    }\n    if (typeof timeStamp !== 'number') {\n      throw new Error('Invalid timestamp value: ' + timeStamp);\n    }\n\n    var self = this;\n\n    // Ignore event when tracking is not enabled (no touchstart event on element)\n    // This is required as this listener ('touchmove') sits on the document and not on the element itself.\n    if (!self.__isTracking) {\n      return;\n    }\n\n    // Not touching anymore (when two finger hit the screen there are two touch end events)\n    self.__isTracking = false;\n\n    // Be sure to reset the dragging flag now. Here we also detect whether\n    // the finger has moved fast enough to switch into a deceleration animation.\n    if (self.__isDragging) {\n      // Reset dragging flag\n      self.__isDragging = false;\n\n      // Start deceleration\n      // Verify that the last move detected was in some relevant time frame\n      if (\n        self.__isSingleTouch &&\n        self.options.animating &&\n        timeStamp - self.__lastTouchMove <= 100\n      ) {\n        // Then figure out what the scroll position was about 100ms ago\n        var positions = self.__positions;\n        var endPos = positions.length - 1;\n        var startPos = endPos;\n\n        // Move pointer to position measured 100ms ago\n        for (\n          var i = endPos;\n          i > 0 && positions[i] > self.__lastTouchMove - 100;\n          i -= 3\n        ) {\n          startPos = i;\n        }\n\n        // If start and stop position is identical in a 100ms timeframe,\n        // we cannot compute any useful deceleration.\n        if (startPos !== endPos) {\n          // Compute relative movement between these two points\n          var timeOffset = positions[endPos] - positions[startPos];\n          var movedLeft = self.__scrollLeft - positions[startPos - 2];\n          var movedTop = self.__scrollTop - positions[startPos - 1];\n\n          // Based on 50ms compute the movement to apply for each render step\n          self.__decelerationVelocityX = (movedLeft / timeOffset) * (1000 / 60);\n          self.__decelerationVelocityY = (movedTop / timeOffset) * (1000 / 60);\n\n          // How much velocity is required to start the deceleration\n          var minVelocityToStartDeceleration =\n            self.options.paging || self.options.snapping ? 4 : 1;\n\n          // Verify that we have enough velocity to start deceleration\n          if (\n            Math.abs(self.__decelerationVelocityX) >\n              minVelocityToStartDeceleration ||\n            Math.abs(self.__decelerationVelocityY) >\n              minVelocityToStartDeceleration\n          ) {\n            // Deactivate pull-to-refresh when decelerating\n            if (!self.__refreshActive && !self.__loadActive) {\n              self.__startDeceleration(timeStamp);\n            }\n          } else {\n            self.__scrollComplete();\n          }\n        } else {\n          self.__scrollComplete();\n        }\n      } else if (timeStamp - self.__lastTouchMove > 100) {\n        self.__scrollComplete();\n      }\n    }\n\n    // If this was a slower move it is per default non decelerated, but this\n    // still means that we want snap back to the bounds which is done here.\n    // This is placed outside the condition above to improve edge case stability\n    // e.g. touchend fired without enabled dragging. This should normally do not\n    // have modified the scroll positions or even showed the scrollbars though.\n    if (!self.__isDecelerating) {\n      if (self.__refreshActive && self.__refreshStart) {\n        // Use publish instead of scrollTo to allow scrolling to out of boundary position\n        // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n        self.__publish(\n          self.__scrollLeft,\n          -self.__refreshHeight,\n          self.__zoomLevel,\n          true\n        );\n\n        if (self.__refreshStart) {\n          self.__refreshStart();\n        }\n      } else if (self.__loadActive && self.__loadStart) {\n        // Use publish instead of scrollTo to allow scrolling to out of boundary position\n        // We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n        self.__publish(\n          self.__scrollLeft,\n          self.__maxScrollTop + self.__loadHeight,\n          self.__zoomLevel,\n          true\n        );\n\n        if (self.__loadStart) {\n          self.__loadStart();\n        }\n      } else {\n        if (self.__interruptedAnimation || self.__isDragging) {\n          self.__scrollComplete();\n        }\n        self.scrollTo(\n          self.__scrollLeft,\n          self.__scrollTop,\n          true,\n          self.__zoomLevel\n        );\n\n        // Directly signalize deactivation (nothing todo on refresh?)\n        if (self.__refreshActive) {\n          self.__refreshActive = false;\n          if (self.__refreshDeactivate) {\n            self.__refreshDeactivate();\n          }\n        } else if (self.__loadActive) {\n          self.__loadActive = false;\n          if (self.__loadDeactivate) {\n            self.__loadDeactivate();\n          }\n        }\n      }\n    }\n\n    // Fully cleanup list\n    self.__positions.length = 0;\n  },\n\n  /** Handle for scroll/publish */\n  onScroll: NOOP,\n\n  stop: function() {\n    var self = this;\n\n    self.__disable = true;\n  },\n  start: function() {\n    self.__disable = true;\n  },\n  /*\n\t---------------------------------------------------------------------------\n\t\tPRIVATE API\n\t---------------------------------------------------------------------------\n\t*/\n\n  /**\n   * Applies the scroll position to the content element\n   *\n   * @param left {Number} Left scroll position\n   * @param top {Number} Top scroll position\n   * @param animate {Boolean?false} Whether animation should be used to move to the new coordinates\n   */\n  __publish: function(left, top, zoom, animate) {\n    var self = this;\n    if (self.__disable) {\n      return;\n    }\n    if (isNaN(left)) {\n      left = this.__scrollLeft;\n    }\n    if (isNaN(top)) {\n      top = this.__scrollTop;\n    }\n    // Remember whether we had an animation, then we try to continue based on the current \"drive\" of the animation\n    var wasAnimating = self.__isAnimating;\n    if (wasAnimating) {\n      core.effect.Animate.stop(wasAnimating);\n      self.__isAnimating = false;\n    }\n\n    if (animate && self.options.animating) {\n      // Keep scheduled positions for scrollBy/zoomBy functionality\n      self.__scheduledLeft = left;\n      self.__scheduledTop = top;\n      self.__scheduledZoom = zoom;\n\n      var oldLeft = self.__scrollLeft;\n      var oldTop = self.__scrollTop;\n      var oldZoom = self.__zoomLevel;\n\n      var diffLeft = left - oldLeft;\n      var diffTop = top - oldTop;\n      var diffZoom = zoom - oldZoom;\n\n      var step = function(percent, now, render) {\n        if (render) {\n          self.__scrollLeft = oldLeft + diffLeft * percent;\n          self.__scrollTop = oldTop + diffTop * percent;\n          self.__zoomLevel = oldZoom + diffZoom * percent;\n\n          // Push values out\n          if (self.__callback) {\n            self.__callback(\n              self.__scrollLeft,\n              self.__scrollTop,\n              self.__zoomLevel\n            );\n            self.onScroll();\n          }\n        }\n      };\n\n      var verify = function(id) {\n        return self.__isAnimating === id;\n      };\n\n      var completed = function(\n        renderedFramesPerSecond,\n        animationId,\n        wasFinished\n      ) {\n        if (animationId === self.__isAnimating) {\n          self.__isAnimating = false;\n        }\n        if (self.__didDecelerationComplete || wasFinished) {\n          self.__scrollComplete();\n        }\n\n        if (self.options.zooming) {\n          self.__computeScrollMax();\n          if (self.__zoomComplete) {\n            self.__zoomComplete();\n            self.__zoomComplete = null;\n          }\n        }\n      };\n\n      // When continuing based on previous animation we choose an ease-out animation instead of ease-in-out\n      self.__isAnimating = core.effect.Animate.start(\n        step,\n        verify,\n        completed,\n        self.options.animationDuration,\n        wasAnimating ? animatingMethod : noAnimatingMethod\n      );\n    } else {\n      self.__scheduledLeft = self.__scrollLeft = left;\n      self.__scheduledTop = self.__scrollTop = top;\n      self.__scheduledZoom = self.__zoomLevel = zoom;\n\n      // Push values out\n      if (self.__callback) {\n        self.__callback(left, top, zoom);\n        self.onScroll();\n      }\n\n      // Fix max scroll ranges\n      if (self.options.zooming) {\n        self.__computeScrollMax();\n        if (self.__zoomComplete) {\n          self.__zoomComplete();\n          self.__zoomComplete = null;\n        }\n      }\n    }\n  },\n\n  /**\n   * Recomputes scroll minimum values based on client dimensions and content dimensions.\n   */\n  __computeScrollMax: function(zoomLevel) {\n    var self = this;\n\n    if (zoomLevel == null) {\n      zoomLevel = self.__zoomLevel;\n    }\n\n    self.__maxScrollLeft = Math.max(\n      self.__contentWidth * zoomLevel - self.__clientWidth,\n      0\n    );\n    self.__maxScrollTop = Math.max(\n      self.__contentHeight * zoomLevel - self.__clientHeight,\n      0\n    );\n  },\n  /** compute current page total page */\n  __computePage: function() {\n    var self = this;\n    var clientWidth = self.__clientWidth;\n    var clientHeight = self.__clientHeight;\n    var left = self.__scrollLeft;\n    var top = self.__scrollTop;\n    self.__totalXPage = Math.ceil(self.__contentWidth / clientWidth);\n    self.__currentPageX = Math.ceil(left / clientWidth + 1);\n    self.__totalYPage = Math.ceil(self.__contentHeight / clientHeight);\n    self.__currentPageY = Math.ceil(top / clientHeight + 1);\n  },\n  /** complete scroll*/\n  __scrollComplete: function() {\n    var self = this;\n    self.options.scrollingComplete();\n  },\n  /*\n\t---------------------------------------------------------------------------\n\t\tANIMATION (DECELERATION) SUPPORT\n\t---------------------------------------------------------------------------\n\t*/\n\n  /**\n   * Called when a touch sequence end and the speed of the finger was high enough\n   * to switch into deceleration mode.\n   */\n  __startDeceleration: function() {\n    var self = this;\n\n    if (self.options.paging) {\n      var scrollLeft = Math.max(\n        Math.min(self.__scrollLeft, self.__maxScrollLeft),\n        0\n      );\n      var scrollTop = Math.max(\n        Math.min(self.__scrollTop, self.__maxScrollTop),\n        0\n      );\n      var clientWidth = self.__clientWidth;\n      var clientHeight = self.__clientHeight;\n\n      // We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.\n      // Each page should have exactly the size of the client area.\n      self.__minDecelerationScrollLeft =\n        Math.floor(scrollLeft / clientWidth) * clientWidth;\n      self.__minDecelerationScrollTop =\n        Math.floor(scrollTop / clientHeight) * clientHeight;\n      self.__maxDecelerationScrollLeft =\n        Math.ceil(scrollLeft / clientWidth) * clientWidth;\n      self.__maxDecelerationScrollTop =\n        Math.ceil(scrollTop / clientHeight) * clientHeight;\n    } else {\n      self.__minDecelerationScrollLeft = 0;\n      self.__minDecelerationScrollTop = 0;\n      self.__maxDecelerationScrollLeft = self.__maxScrollLeft;\n      self.__maxDecelerationScrollTop = self.__maxScrollTop;\n    }\n\n    // Wrap class method\n    var step = function(percent, now, render) {\n      self.__stepThroughDeceleration(render);\n    };\n\n    // How much velocity is required to keep the deceleration running\n    var minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.001;\n\n    // Detect whether it's still worth to continue animating steps\n    // If we are already slow enough to not being user perceivable anymore, we stop the whole process here.\n    var verify = function() {\n      var shouldContinue =\n        Math.abs(self.__decelerationVelocityX) >=\n          minVelocityToKeepDecelerating ||\n        Math.abs(self.__decelerationVelocityY) >= minVelocityToKeepDecelerating;\n      if (!shouldContinue) {\n        self.__didDecelerationComplete = true;\n      }\n      return shouldContinue;\n    };\n\n    var completed = function() {\n      if (!self.__isDecelerating) {\n        return;\n      }\n      self.__isDecelerating = false;\n      if (self.__didDecelerationComplete) {\n        self.__scrollComplete();\n      }\n\n      // Animate to grid when snapping is active, otherwise just fix out-of-boundary positions\n      self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);\n    };\n\n    // Start animation and switch on flag\n    self.__isDecelerating = core.effect.Animate.start(step, verify, completed);\n  },\n\n  /**\n   * Called on every step of the animation\n   *\n   * @param inMemory {Boolean?false} Whether to not render the current step, but keep it in memory only. Used internally only!\n   */\n  __stepThroughDeceleration: function(render) {\n    var self = this;\n\n    //\n    // COMPUTE NEXT SCROLL POSITION\n    //\n\n    // Add deceleration to scroll position\n    var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;\n    var scrollTop = self.__scrollTop + self.__decelerationVelocityY;\n\n    //\n    // HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE\n    //\n\n    if (!self.options.bouncing) {\n      var scrollLeftFixed = Math.max(\n        Math.min(self.__maxDecelerationScrollLeft, scrollLeft),\n        self.__minDecelerationScrollLeft\n      );\n      if (scrollLeftFixed !== scrollLeft) {\n        scrollLeft = scrollLeftFixed;\n        self.__decelerationVelocityX = 0;\n      }\n\n      var scrollTopFixed = Math.max(\n        Math.min(self.__maxDecelerationScrollTop, scrollTop),\n        self.__minDecelerationScrollTop\n      );\n      if (scrollTopFixed !== scrollTop) {\n        scrollTop = scrollTopFixed;\n        self.__decelerationVelocityY = 0;\n      }\n    }\n\n    //\n    // UPDATE SCROLL POSITION\n    //\n\n    if (render) {\n      self.__publish(scrollLeft, scrollTop, self.__zoomLevel);\n    } else {\n      self.__scrollLeft = scrollLeft;\n      self.__scrollTop = scrollTop;\n    }\n\n    //\n    // SLOW DOWN\n    //\n\n    // Slow down velocity on every iteration\n    if (!self.options.paging) {\n      // This is the factor applied to every iteration of the animation\n      // to slow down the process. This should emulate natural behavior where\n      // objects slow down when the initiator of the movement is removed\n      var frictionFactor = 0.95;\n\n      self.__decelerationVelocityX *= frictionFactor;\n      self.__decelerationVelocityY *= frictionFactor;\n    }\n\n    //\n    // BOUNCING SUPPORT\n    //\n\n    if (self.options.bouncing) {\n      var scrollOutsideX = 0;\n      var scrollOutsideY = 0;\n\n      // This configures the amount of change applied to deceleration/acceleration when reaching boundaries\n      var penetrationDeceleration = self.options.penetrationDeceleration;\n      var penetrationAcceleration = self.options.penetrationAcceleration;\n\n      // Check limits\n      if (scrollLeft < self.__minDecelerationScrollLeft) {\n        scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;\n      } else if (scrollLeft > self.__maxDecelerationScrollLeft) {\n        scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;\n      }\n\n      if (scrollTop < self.__minDecelerationScrollTop) {\n        scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;\n      } else if (scrollTop > self.__maxDecelerationScrollTop) {\n        scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;\n      }\n\n      // Slow down until slow enough, then flip back to snap position\n      if (scrollOutsideX !== 0) {\n        if (scrollOutsideX * self.__decelerationVelocityX <= 0) {\n          self.__decelerationVelocityX +=\n            scrollOutsideX * penetrationDeceleration;\n        } else {\n          self.__decelerationVelocityX =\n            scrollOutsideX * penetrationAcceleration;\n        }\n      }\n\n      if (scrollOutsideY !== 0) {\n        if (scrollOutsideY * self.__decelerationVelocityY <= 0) {\n          self.__decelerationVelocityY +=\n            scrollOutsideY * penetrationDeceleration;\n        } else {\n          self.__decelerationVelocityY =\n            scrollOutsideY * penetrationAcceleration;\n        }\n      }\n    }\n  }\n};\n\n// Copy over members to prototype\nfor (var key in members) {\n  Scroller.prototype[key] = members[key];\n}\n","import Scroller from '../../third-party/scroller';\nimport { render } from '../../third-party/scroller/render';\nimport { listenContainer } from '../../third-party/scroller/listener';\n\n/**\n * @description refresh and load callback\n */\nfunction createStateCallbacks(type, stageName, vm, tipDom) {\n  const listeners = vm.$listeners;\n\n  let activateCallback = () => {\n    vm.vuescroll.state[stageName] = 'active';\n  };\n\n  let deactivateCallback = () => {\n    vm.vuescroll.state[stageName] = 'deactive';\n  };\n\n  let startCallback = () => {\n    vm.vuescroll.state[stageName] = 'start';\n    setTimeout(() => {\n      vm.scroller.finishRefreshOrLoad();\n    }, 2000);\n  };\n\n  let beforeDeactivateCallback = done => {\n    vm.vuescroll.state[stageName] = 'beforeDeactive';\n    setTimeout(function() {\n      done();\n    }, 500);\n  };\n  /* istanbul ignore if */\n  if (listeners[type + '-activate']) {\n    activateCallback = () => {\n      vm.vuescroll.state[stageName] = 'active';\n      vm.$emit(type + '-activate', vm, tipDom);\n    };\n  }\n  /* istanbul ignore if */\n  if (listeners[type + '-before-deactivate']) {\n    beforeDeactivateCallback = done => {\n      vm.vuescroll.state[stageName] = 'beforeDeactive';\n      vm.$emit(type + '-before-deactivate', vm, tipDom, done.bind(vm.scroller));\n    };\n  }\n  /* istanbul ignore if */\n  if (listeners[type + '-deactivate']) {\n    deactivateCallback = () => {\n      vm.vuescroll.state[stageName] = 'deactive';\n      vm.$emit(type + '-deactivate', vm, tipDom);\n    };\n  }\n  /* istanbul ignore if */\n  if (listeners[type + '-start']) {\n    startCallback = () => {\n      vm.vuescroll.state[stageName] = 'start';\n      vm.$emit(\n        type + '-start',\n        vm,\n        tipDom,\n        vm.scroller.finishRefreshOrLoad.bind(vm.scroller)\n      );\n    };\n  }\n\n  return {\n    activateCallback,\n    deactivateCallback,\n    startCallback,\n    beforeDeactivateCallback\n  };\n}\n\nexport default {\n  methods: {\n    // Update:\n    // 1. update height/width\n    // 2. update refresh or load\n    updateScroller() {\n      this.updateDimesion();\n      this.registryRefreshLoad();\n    },\n    updateDimesion() {\n      const clientWidth = this.$el.clientWidth;\n      const clientHeight = this.$el.clientHeight;\n      let contentWidth = this.scrollPanelElm.scrollWidth;\n      let contentHeight = this.scrollPanelElm.scrollHeight;\n      let refreshHeight = 0;\n      let loadHeight = 0;\n      // If the refresh option is true,let's  give a \"margin-top\" style to\n      // the refresh-tip dom. let it to be invisible when doesn't trigger\n      // refresh.\n      if (this.mergedOptions.vuescroll.pullRefresh.enable) {\n        const refreshDom =\n          this.$refs['refreshDom'].elm || this.$refs['refreshDom'];\n        refreshHeight = refreshDom.offsetHeight;\n        if (!refreshDom.style.marginTop) {\n          refreshDom.style.marginTop = -refreshHeight + 'px';\n        }\n      }\n      if (this.mergedOptions.vuescroll.pushLoad.enable) {\n        const enableLoad = this.isEnableLoad();\n        if (enableLoad) {\n          const loadDom = this.$refs['loadDom'].elm || this.$refs['loadDom'];\n          loadHeight = loadDom.offsetHeight;\n          //  hide the trailing load dom..\n          contentHeight -= loadHeight;\n        }\n      }\n      if (this.scroller) {\n        this.scroller.setDimensions(\n          clientWidth,\n          clientHeight,\n          contentWidth,\n          contentHeight,\n          false\n        );\n      }\n    },\n    registryRefreshLoad() {\n      // registry refresh\n      if (this.mergedOptions.vuescroll.pullRefresh.enable) {\n        this.registryEvent('refresh');\n      }\n      // registry load\n      if (this.mergedOptions.vuescroll.pushLoad.enable) {\n        this.registryEvent('load');\n      }\n    },\n    registryScroller() {\n      const preventDefault = this.mergedOptions.vuescroll.scroller\n        .preventDefault;\n      const paging = this.mergedOptions.vuescroll.paging;\n      const snapping = this.mergedOptions.vuescroll.snapping.enable;\n      // disale zooming when refresh or load enabled\n      let zooming =\n        !this.refreshLoad &&\n        !paging &&\n        !snapping &&\n        this.mergedOptions.vuescroll.zooming;\n      const { scrollingY, scrollingX } = this.mergedOptions.scrollPanel;\n\n      const scrollingComplete = this.scrollingComplete.bind(this);\n\n      // Initialize Scroller\n      this.scroller = new Scroller(render(this.scrollPanelElm, window, 'px'), {\n        ...this.mergedOptions.vuescroll.scroller,\n        zooming,\n        scrollingY,\n        scrollingX: scrollingX && !this.refreshLoad,\n        animationDuration: this.mergedOptions.scrollPanel.speed,\n        paging,\n        snapping,\n        scrollingComplete\n      });\n\n      // Set snap\n      if (snapping) {\n        this.scroller.setSnapSize(\n          this.mergedOptions.vuescroll.snapping.width,\n          this.mergedOptions.vuescroll.snapping.height\n        );\n      }\n      var rect = this.$el.getBoundingClientRect();\n      this.scroller.setPosition(\n        rect.left + this.$el.clientLeft,\n        rect.top + this.$el.clientTop\n      );\n\n      // Get destroy callback\n      const cb = listenContainer(\n        this.$el,\n        this.scroller,\n        eventType => {\n          // Thie is to dispatch the event from the scroller.\n          // to let vuescroll refresh the dom\n          switch (eventType) {\n          case 'mousedown':\n            this.vuescroll.state.isDragging = true;\n            break;\n          case 'onscroll':\n            this.handleScroll(false);\n            break;\n          case 'mouseup':\n            this.vuescroll.state.isDragging = false;\n            break;\n          }\n        },\n        zooming,\n        preventDefault\n      );\n\n      this.updateScroller();\n\n      return cb;\n    },\n    updateSlideModeBarState() {\n      // update slide mode scrollbars' state\n      let heightPercentage, widthPercentage;\n      const vuescroll = this.$el;\n      const scroller = this.scroller;\n\n      let outerLeft = 0;\n      let outerTop = 0;\n\n      const clientWidth = this.$el.clientHeight;\n      const clientHeight = this.$el.clientHeight;\n\n      const contentWidth = clientWidth + this.scroller.__maxScrollLeft;\n      const contentHeight = clientHeight + this.scroller.__maxScrollTop;\n\n      const __enableScrollX =\n        clientWidth < contentWidth && this.mergedOptions.scrollPanel.scrollingX;\n      const __enableScrollY =\n        clientHeight < contentHeight &&\n        this.mergedOptions.scrollPanel.scrollingY;\n\n      // We should take the the height or width that is\n      // out of horizontal bountry  into the total length\n      if (__enableScrollX) {\n        /* istanbul ignore if */\n        if (scroller.__scrollLeft < 0) {\n          outerLeft = -scroller.__scrollLeft;\n        } /* istanbul ignore next */ else if (\n          scroller.__scrollLeft > scroller.__maxScrollLeft\n        ) {\n          outerLeft = scroller.__scrollLeft - scroller.__maxScrollLeft;\n        }\n      }\n      // out of vertical bountry\n      if (__enableScrollY) {\n        if (scroller.__scrollTop < 0) {\n          outerTop = -scroller.__scrollTop;\n        } else if (scroller.__scrollTop > scroller.__maxScrollTop) {\n          outerTop = scroller.__scrollTop - scroller.__maxScrollTop;\n        }\n      }\n\n      heightPercentage = (clientHeight * 100) / (contentHeight + outerTop);\n      widthPercentage = (clientWidth * 100) / (contentWidth + outerLeft);\n\n      const scrollTop = Math.min(\n        Math.max(0, scroller.__scrollTop),\n        scroller.__maxScrollTop\n      );\n      const scrollLeft = Math.min(\n        Math.max(0, scroller.__scrollLeft),\n        scroller.__maxScrollLeft\n      );\n\n      this.bar.vBar.state.posValue =\n        ((scrollTop + outerTop) * 100) / vuescroll.clientHeight;\n      this.bar.hBar.state.posValue =\n        ((scrollLeft + outerLeft) * 100) / vuescroll.clientWidth;\n\n      /* istanbul ignore if */\n      if (scroller.__scrollLeft < 0) {\n        this.bar.hBar.state.posValue = 0;\n      }\n      if (scroller.__scrollTop < 0) {\n        this.bar.vBar.state.posValue = 0;\n      }\n\n      this.bar.vBar.state.size =\n        heightPercentage < 100 ? heightPercentage + '%' : 0;\n      this.bar.hBar.state.size =\n        widthPercentage < 100 ? widthPercentage + '%' : 0;\n    },\n    registryEvent(type) {\n      const domName = type == 'refresh' ? 'refreshDom' : 'loadDom';\n      const activateFunc =\n        type == 'refresh'\n          ? this.scroller.activatePullToRefresh\n          : this.scroller.activatePushToLoad;\n      const stageName = type == 'refresh' ? 'refreshStage' : 'loadStage';\n      const tipDom = this.$refs[domName].elm || this.$refs[domName];\n      const cbs = createStateCallbacks(type, stageName, this, tipDom);\n      const height = tipDom.offsetHeight;\n\n      activateFunc.bind(this.scroller)(height, cbs);\n    }\n  }\n};\n","import { modes } from './constants';\nimport { error, warn } from '../util';\n\nexport default {\n  // vuescroll\n  vuescroll: {\n    mode: 'native',\n    // vuescroll's size(height/width) should be a percent(100%)\n    // or be a number that is equal to its parentNode's width or\n    // height ?\n    sizeStrategy: 'percent',\n    /** Whether to detect dom resize or not */\n    detectResize: true,\n    // pullRefresh or pushLoad is only for the slide mode...\n    pullRefresh: {\n      enable: false,\n      tips: {\n        deactive: 'Pull to Refresh',\n        active: 'Release to Refresh',\n        start: 'Refreshing...',\n        beforeDeactive: 'Refresh Successfully!'\n      }\n    },\n    pushLoad: {\n      enable: false,\n      tips: {\n        deactive: 'Push to Load',\n        active: 'Release to Load',\n        start: 'Loading...',\n        beforeDeactive: 'Load Successfully!'\n      }\n    },\n    paging: false,\n    zooming: true,\n    snapping: {\n      enable: false,\n      width: 100,\n      height: 100\n    },\n    /* shipped scroll options */\n    scroller: {\n      /** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\n      bouncing: true,\n      /** Enable locking to the main axis if user moves only slightly on one of them at start */\n      locking: true,\n      /** Minimum zoom level */\n      minZoom: 0.5,\n      /** Maximum zoom level */\n      maxZoom: 3,\n      /** Multiply or decrease scrolling speed **/\n      speedMultiplier: 1,\n      /** This configures the amount of change applied to deceleration when reaching boundaries  **/\n      penetrationDeceleration: 0.03,\n      /** This configures the amount of change applied to acceleration when reaching boundaries  **/\n      penetrationAcceleration: 0.08,\n      /** Whether call e.preventDefault event when sliding the content or not */\n      preventDefault: true\n    }\n  },\n  scrollPanel: {\n    // when component mounted.. it will automatically scrolls.\n    initialScrollY: false,\n    initialScrollX: false,\n    // feat: #11\n    scrollingX: true,\n    scrollingY: true,\n    speed: 300,\n    easing: undefined\n  },\n  //\n  scrollContent: {\n    padding: false\n  },\n  //\n  rail: {\n    background: '#01a99a',\n    opacity: 0,\n    /** Rail's size(Height/Width) , default -> 6px */\n    size: '6px'\n  },\n  bar: {\n    /** How long to hide bar after mouseleave, default -> 500 */\n    showDelay: 500,\n    /** Whether to show bar on scrolling, default -> true */\n    onlyShowBarOnScroll: true,\n    /** Whether to keep show or not, default -> false */\n    keepShow: false,\n    /** Bar's background , default -> #00a650 */\n    background: '#c1c1c1',\n    /** Bar's opacity, default -> 1  */\n    opacity: 1,\n    /** Styles when you hover scrollbar, it will merge into the current style */\n    hoverStyle: false\n  }\n};\n/**\n * validate the options\n *\n * @export\n * @param {any} ops\n */\nexport function validateOptions(ops) {\n  let shouldStopRender = false;\n  const { vuescroll, scrollPanel } = ops;\n  const { vBar, hBar } = ops.bar;\n  const { vRail, hRail } = ops.rail;\n\n  // validate modes\n  if (!~modes.indexOf(vuescroll.mode)) {\n    error(\n      `Unknown mode: ${\n        vuescroll.mode\n      },the vuescroll's option \"mode\" should be one of the ${modes}`\n    );\n    shouldStopRender = true;\n  }\n\n  // validate pushLoad, pullReresh, snapping\n  if (\n    vuescroll.paging == vuescroll.snapping.enable &&\n    vuescroll.paging &&\n    (vuescroll.pullRefresh || vuescroll.pushLoad)\n  ) {\n    error(\n      'paging, snapping, (pullRefresh with pushLoad) can only one of them to be true.'\n    );\n  }\n\n  // validate scrollPanel\n  const initialScrollY = scrollPanel['initialScrollY'];\n  const initialScrollX = scrollPanel['initialScrollX'];\n\n  if (initialScrollY && !String(initialScrollY).match(/^\\d+(\\.\\d+)?(%)?$/)) {\n    warn(\n      'The prop `initialScrollY` or `initialScrollX` should be a percent number like `10%` or an exact number that greater than or equal to 0 like `100`.'\n    );\n  }\n  if (initialScrollX && !String(initialScrollX).match(/^\\d+(\\.\\d+)?(%)?$/)) {\n    warn(\n      'The prop `initialScrollY` or `initialScrollX` should be a percent number like `10%` or an exact number that greater than or equal to 0 like `100`.'\n    );\n  }\n\n  // validate deprecated vBar/hBar vRail/hRail\n  if (vBar || hBar || vRail || hRail) {\n    warn(\n      'The options: vRail, hRail, vBar, hBar have been deprecated since v4.7.0,' +\n        'please use corresponing rail/bar instead!'\n    );\n  }\n\n  return shouldStopRender;\n}\n","import GCF, { validateOptions } from '../../shared/global-config';\nimport { deepMerge, defineReactive } from '../../util';\n\n/**\n * hack the lifeCycle\n *\n * to merge the global data into user-define data\n */\nfunction hackPropsData() {\n  const vm = this;\n  if (vm.$options.name === 'vueScroll') {\n    const _gfc = deepMerge(vm.$vuescrollConfig, {});\n    const ops = deepMerge(GCF, _gfc);\n    vm.$options.propsData.ops = vm.$options.propsData.ops || {};\n    Object.keys(vm.$options.propsData.ops).forEach(key => {\n      {\n        defineReactive(vm.mergedOptions, key, vm.$options.propsData.ops);\n      }\n    });\n    // from ops to mergedOptions\n    deepMerge(ops, vm.mergedOptions);\n\n    defineReactive(vm.mergedOptions.scrollContent, 'paddingValue', () => {\n      return vm.mergedOptions.rail.size;\n    });\n  }\n}\nexport default {\n  data() {\n    return {\n      shouldStopRender: false,\n      mergedOptions: {\n        vuescroll: {},\n        scrollPanel: {},\n        scrollContent: {},\n        rail: {},\n        bar: {}\n      }\n    };\n  },\n  created() {\n    hackPropsData.call(this);\n\n    this._isVuescrollRoot = true;\n\n    this.renderError = validateOptions(this.mergedOptions);\n  }\n};\n","import {\n  createEasingFunction,\n  easingPattern\n} from '../../third-party/easingPattern';\nimport { core } from '../../third-party/scroller/animate';\nimport { warn, isChildInParent } from '../../util';\n\nconst vsInstances = {};\n\nexport function refreshAll() {\n  for (let vs in vsInstances) {\n    vsInstances[vs].refresh();\n  }\n}\n\nfunction getNumericValue(distance, size) {\n  let number;\n  if (!(number = /(-?\\d+(?:\\.\\d+?)?)%$/.exec(distance))) {\n    number = distance - 0;\n  } else {\n    number = number[1] - 0;\n    number = (size * number) / 100;\n  }\n  return number;\n}\n\nfunction goScrolling(elm, deltaX, deltaY, speed, easing, scrollingComplete) {\n  const startLocationY = elm['scrollTop'];\n  const startLocationX = elm['scrollLeft'];\n  let positionX = startLocationX;\n  let positionY = startLocationY;\n  /**\n   * keep the limit of scroll delta.\n   */\n  /* istanbul ignore next */\n  if (startLocationY + deltaY < 0) {\n    deltaY = -startLocationY;\n  }\n  const scrollHeight = elm['scrollHeight'];\n  if (startLocationY + deltaY > scrollHeight) {\n    deltaY = scrollHeight - startLocationY;\n  }\n  if (startLocationX + deltaX < 0) {\n    deltaX = -startLocationX;\n  }\n  if (startLocationX + deltaX > elm['scrollWidth']) {\n    deltaX = elm['scrollWidth'] - startLocationX;\n  }\n\n  const easingMethod = createEasingFunction(easing, easingPattern);\n\n  const stepCallback = percentage => {\n    positionX = startLocationX + deltaX * percentage;\n    positionY = startLocationY + deltaY * percentage;\n    elm['scrollTop'] = Math.floor(positionY);\n    elm['scrollLeft'] = Math.floor(positionX);\n  };\n\n  const verifyCallback = () => {\n    return (\n      Math.abs(positionY - startLocationY) <= Math.abs(deltaY) ||\n      Math.abs(positionX - startLocationX) <= Math.abs(deltaX)\n    );\n  };\n\n  core.effect.Animate.start(\n    stepCallback,\n    verifyCallback,\n    scrollingComplete,\n    speed,\n    easingMethod\n  );\n}\n\nexport default {\n  mounted() {\n    vsInstances[this._uid] = this;\n  },\n  beforeDestroy() {\n    delete vsInstances[this._uid];\n  },\n  methods: {\n    // public api\n    scrollTo({ x, y }, animate = true, force = false) {\n      if (typeof x === 'undefined') {\n        x = this.vuescroll.state.internalScrollLeft || 0;\n      } else {\n        x = getNumericValue(x, this.scrollPanelElm.scrollWidth);\n      }\n      if (typeof y === 'undefined') {\n        y = this.vuescroll.state.internalScrollTop || 0;\n      } else {\n        y = getNumericValue(y, this.scrollPanelElm.scrollHeight);\n      }\n      this.internalScrollTo(x, y, animate, force);\n    },\n    scrollBy({ dx = 0, dy = 0 }, animate = true) {\n      let {\n        internalScrollLeft = 0,\n        internalScrollTop = 0\n      } = this.vuescroll.state;\n      if (dx) {\n        internalScrollLeft += getNumericValue(\n          dx,\n          this.scrollPanelElm.scrollWidth\n        );\n      }\n      if (dy) {\n        internalScrollTop += getNumericValue(\n          dy,\n          this.scrollPanelElm.scrollHeight\n        );\n      }\n      this.internalScrollTo(internalScrollLeft, internalScrollTop, animate);\n    },\n    zoomBy(factor, animate, originLeft, originTop, callback) {\n      if (this.mode != 'slide') {\n        warn('zoomBy and zoomTo are only for slide mode!');\n        return;\n      }\n      this.scroller.zoomBy(factor, animate, originLeft, originTop, callback);\n    },\n    zoomTo(level, animate = false, originLeft, originTop, callback) {\n      if (this.mode != 'slide') {\n        warn('zoomBy and zoomTo are only for slide mode!');\n        return;\n      }\n      this.scroller.zoomTo(level, animate, originLeft, originTop, callback);\n    },\n    getCurrentPage() {\n      if (this.mode != 'slide' || !this.mergedOptions.vuescroll.paging) {\n        warn(\n          'getCurrentPage and goToPage are only for slide mode and paging is enble!'\n        );\n        return;\n      }\n      return this.scroller.getCurrentPage();\n    },\n    goToPage(dest, animate = false) {\n      if (this.mode != 'slide' || !this.mergedOptions.vuescroll.paging) {\n        warn(\n          'getCurrentPage and goToPage are only for slide mode and paging is enble!'\n        );\n        return;\n      }\n      this.scroller.goToPage(dest, animate);\n    },\n    triggerRefreshOrLoad(type) {\n      if (this.mode != 'slide') {\n        warn('You can only use triggerRefreshOrLoad in slide mode!');\n        return;\n      }\n\n      const isRefresh = this.mergedOptions.vuescroll.pullRefresh.enable;\n      const isLoad = this.mergedOptions.vuescroll.pushLoad.enable;\n\n      if (type == 'refresh' && !isRefresh) {\n        warn('refresh must be enabled!');\n        return;\n      } else if (type == 'load' && !isLoad) {\n        warn('load must be enabled and content\\'s height > container\\'s height!');\n        return;\n      } else if (type !== 'refresh' && type !== 'load') {\n        warn('param must be one of load and refresh!');\n        return;\n      }\n\n      /* istanbul ignore if */\n      if (this.vuescroll.state[`${type}Stage`] == 'start') {\n        return;\n      }\n\n      this.scroller.triggerRefreshOrLoad(type);\n\n      return true;\n    },\n    getCurrentviewDom() {\n      const parent =\n        this.mode == 'slide' ? this.scrollPanelElm : this.scrollContentElm;\n      const children = parent.children;\n      const domFragment = [];\n\n      const isCurrentview = dom => {\n        const { left, top, width, height } = dom.getBoundingClientRect();\n        const {\n          left: parentLeft,\n          top: parentTop,\n          height: parentHeight,\n          width: parentWidth\n        } = this.$el.getBoundingClientRect();\n        if (\n          left - parentLeft + width > 0 &&\n          left - parentLeft < parentWidth &&\n          top - parentTop + height > 0 &&\n          top - parentTop < parentHeight\n        ) {\n          return true;\n        }\n        return false;\n      };\n\n      for (let i = 0; i < children.length; i++) {\n        const dom = children.item(i);\n\n        if (isCurrentview(dom) && !dom.isResizeElm) {\n          domFragment.push(dom);\n        }\n      }\n\n      return domFragment;\n    },\n    // private api\n    internalScrollTo(destX, destY, animate, force) {\n      if (this.mode == 'native') {\n        if (animate) {\n          // hadnle for scroll complete\n          const scrollingComplete = this.scrollingComplete.bind(this);\n\n          goScrolling(\n            this.$refs['scrollPanel'].$el,\n            destX - this.$refs['scrollPanel'].$el.scrollLeft,\n            destY - this.$refs['scrollPanel'].$el.scrollTop,\n            this.mergedOptions.scrollPanel.speed,\n            this.mergedOptions.scrollPanel.easing,\n            scrollingComplete\n          );\n        } else {\n          this.$refs['scrollPanel'].$el.scrollTop = destY;\n          this.$refs['scrollPanel'].$el.scrollLeft = destX;\n        }\n      }\n      // for non-native we use scroller's scorllTo\n      else if (this.mode == 'slide') {\n        this.scroller.scrollTo(destX, destY, animate, undefined, force);\n      }\n    },\n    scrollIntoView(elm, animate = true) {\n      const parentElm = this.$el;\n\n      if (typeof elm === 'string') {\n        elm = parentElm.querySelector(elm);\n      }\n\n      if (!isChildInParent(elm, parentElm)) {\n        warn(\n          'The element or selector you passed is not the element of Vuescroll, please pass the element that is in Vuescroll to scrollIntoView API. '\n        );\n        return;\n      }\n\n      // parent elm left, top\n      const { left, top } = this.$el.getBoundingClientRect();\n      // child elm left, top\n      const { left: childLeft, top: childTop } = elm.getBoundingClientRect();\n\n      const diffX = left - childLeft;\n      const diffY = top - childTop;\n\n      this.scrollBy(\n        {\n          dx: -diffX,\n          dy: -diffY\n        },\n        animate\n      );\n    },\n    refresh() {\n      this.refreshInternalStatus();\n    },\n    // Get the times you have scrolled!\n    getScrollingTimes() {\n      return this.vuescroll.state.scrollingTimes;\n    },\n    // Clear the times you have scrolled!\n    clearScrollingTimes() {\n      this.vuescroll.state.scrollingTimes = 0;\n    }\n  }\n};\n","export default {\n  vertical: {\n    size: 'height',\n    opsSize: 'width',\n    posName: 'top',\n    opposName: 'bottom',\n    page: 'pageY',\n    scroll: 'scrollTop',\n    scrollSize: 'scrollHeight',\n    offset: 'offsetHeight',\n    client: 'clientY',\n    axis: 'Y'\n  },\n  horizontal: {\n    size: 'width',\n    opsSize: 'height',\n    posName: 'left',\n    opposName: 'right',\n    page: 'pageX',\n    scroll: 'scrollLeft',\n    scrollSize: 'scrollWidth',\n    offset: 'offsetWidth',\n    client: 'clientX',\n    axis: 'X'\n  }\n};\n","import scrollMap from '../../shared/scroll-map';\nimport {\n  eventCenter,\n  isSupportTouch,\n  getRealParent,\n  deepMerge\n} from '../../util';\n\nconst colorCache = {};\nconst rgbReg = /rgb\\(/;\nconst extractRgbColor = /rgb\\((.*)\\)/;\n\n/* istanbul ignore next */\nfunction createMouseEvent(ctx) {\n  const parent = getRealParent(ctx);\n\n  function mousedown(e) {\n    e.stopImmediatePropagation();\n    document.onselectstart = () => false;\n    ctx.axisStartPos =\n      e[ctx.bar.client] -\n      ctx.$refs['thumb'].getBoundingClientRect()[ctx.bar.posName];\n\n    // Tell parent that the mouse has been down.\n    ctx.$emit('setBarDrag', true);\n    eventCenter(document, 'mousemove', mousemove);\n    eventCenter(document, 'mouseup', mouseup);\n  }\n\n  function mousemove(e) {\n    if (!ctx.axisStartPos) {\n      return;\n    }\n\n    const delta =\n      e[ctx.bar.client] - ctx.$el.getBoundingClientRect()[ctx.bar.posName];\n    const percent = (delta - ctx.axisStartPos) / ctx.$el[ctx.bar.offset];\n    parent.scrollTo(\n      {\n        [ctx.bar.axis.toLowerCase()]:\n          parent.scrollPanelElm[ctx.bar.scrollSize] * percent\n      },\n      false\n    );\n  }\n\n  function mouseup() {\n    ctx.$emit('setBarDrag', false);\n    parent.hideBar();\n\n    document.onselectstart = null;\n    ctx.axisStartPos = 0;\n\n    eventCenter(document, 'mousemove', mousemove, false, 'off');\n    eventCenter(document, 'mouseup', mouseup, false, 'off');\n  }\n\n  return mousedown;\n}\n\n/* istanbul ignore next */\nfunction createTouchEvent(ctx) {\n  const parent = getRealParent(ctx);\n\n  function touchstart(e) {\n    e.stopImmediatePropagation();\n    e.preventDefault();\n\n    document.onselectstart = () => false;\n\n    ctx.axisStartPos =\n      e.touches[0][ctx.bar.client] -\n      ctx.$refs['thumb'].getBoundingClientRect()[ctx.bar.posName];\n\n    // Tell parent that the mouse has been down.\n    ctx.$emit('setBarDrag', true);\n    eventCenter(document, 'touchmove', touchmove);\n    eventCenter(document, 'touchend', touchend);\n  }\n  function touchmove(e) {\n    if (!ctx.axisStartPos) {\n      return;\n    }\n\n    const delta =\n      e.touches[0][ctx.bar.client] -\n      ctx.$el.getBoundingClientRect()[ctx.bar.posName];\n    const percent = (delta - ctx.axisStartPos) / ctx.$el[ctx.bar.offset];\n\n    parent.scrollTo(\n      {\n        [ctx.bar.axis.toLowerCase()]:\n          parent.scrollPanelElm[ctx.bar.scrollSize] * percent\n      },\n      false\n    );\n  }\n  function touchend() {\n    ctx.$emit('setBarDrag', false);\n    parent.hideBar();\n\n    document.onselectstart = null;\n    ctx.axisStartPos = 0;\n\n    eventCenter(document, 'touchmove', touchmove, false, 'off');\n    eventCenter(document, 'touchend', touchend, false, 'off');\n  }\n  return touchstart;\n}\n\n// Transform a common color int oa `rgbA` color\nfunction getRgbAColor(color, opacity) {\n  const id = color + '&' + opacity;\n  if (colorCache[id]) {\n    return colorCache[id];\n  }\n\n  const div = document.createElement('div');\n  div.style.background = color;\n  document.body.appendChild(div);\n  const computedColor = window.getComputedStyle(div).backgroundColor;\n  document.body.removeChild(div);\n\n  /* istanbul ignore if */\n  if (!rgbReg.test(computedColor)) {\n    return color;\n  }\n\n  return (colorCache[id] = `rgba(${\n    extractRgbColor.exec(computedColor)[1]\n  }, ${opacity})`);\n}\n\n/* istanbul ignore next */\nfunction handleClickTrack(e) {\n  const ctx = this;\n  const parent = getRealParent(ctx);\n\n  const { client, offset, posName, axis } = ctx.bar;\n  const thumb = ctx.$refs['thumb'];\n\n  const barOffset = thumb[offset];\n\n  const percent =\n    (e[client] -\n      e.currentTarget.getBoundingClientRect()[posName] -\n      barOffset / 2) /\n    e.currentTarget[offset];\n\n  parent.scrollTo({\n    [axis.toLowerCase()]: percent * 100 + '%'\n  });\n}\n\nexport default {\n  name: 'bar',\n  props: {\n    ops: {\n      type: Object,\n      required: true\n    },\n    state: {\n      type: Object,\n      required: true\n    },\n    type: {\n      type: String,\n      required: true\n    }\n  },\n  computed: {\n    bar() {\n      return scrollMap[this.type];\n    }\n  },\n  render(h) {\n    const vm = this;\n\n    /** Scrollbar style */\n    let style = {\n      [vm.bar.size]: vm.state.size,\n      background: vm.ops.bar.background,\n      opacity: vm.state.opacity,\n      transform: `translate${scrollMap[vm.type].axis}(${vm.state.posValue}%)`\n    };\n    const bar = {\n      style: style,\n      class: `__bar-is-${vm.type}`,\n      ref: 'thumb',\n      on: {}\n    };\n\n    let originBarStyle = {};\n    let hoverBarStyle = vm.ops.bar.hoverStyle;\n    if (hoverBarStyle) {\n      bar.on['mouseenter'] = () => {\n        /* istanbul ignore next */\n        if (!hoverBarStyle) return;\n\n        Object.keys(hoverBarStyle).forEach(key => {\n          originBarStyle[key] = vm.$refs.thumb.style[key];\n        });\n\n        deepMerge(hoverBarStyle, vm.$refs.thumb.style, true);\n      };\n      bar.on['mouseleave'] = () => {\n        /* istanbul ignore next */\n        if (!hoverBarStyle) return;\n\n        Object.keys(hoverBarStyle).forEach(key => {\n          vm.$refs.thumb.style[key] = originBarStyle[key];\n        });\n      };\n    }\n\n    /* istanbul ignore if */\n    if (isSupportTouch()) {\n      bar.on['touchstart'] = createTouchEvent(this);\n    } else {\n      bar.on['mousedown'] = createMouseEvent(this);\n    }\n\n    /** Get rgbA format background color */\n    const railBackgroundColor = getRgbAColor(\n      vm.ops.rail.background,\n      vm.ops.rail.opacity\n    );\n\n    /** Rail Data */\n    const rail = {\n      class: `__rail-is-${vm.type}`,\n      style: {\n        borderRadius: vm.ops.rail.size,\n        background: railBackgroundColor,\n        [vm.bar.opsSize]: vm.ops.rail.size\n      },\n      on: {\n        click(e) /* istanbul ignore next */ {\n          handleClickTrack.call(vm, e);\n        }\n      }\n    };\n\n    return (\n      <div {...rail}>\n        <div {...bar} />\n      </div>\n    );\n  }\n};\n\n/**\n * create bars\n *\n * @param {any} size\n * @param {any} type\n */\nexport function createBar(h, vm, type) {\n  const axis = scrollMap[type].axis;\n  /** type.charAt(0) = vBar/hBar */\n  const barType = `${type.charAt(0)}Bar`;\n\n  if (\n    !vm.bar[barType].state.size ||\n    !vm.mergedOptions.scrollPanel['scrolling' + axis] ||\n    (vm.refreshLoad && type !== 'vertical' && vm.mode === 'slide')\n  ) {\n    return null;\n  }\n\n  const barData = {\n    props: {\n      type: type,\n      ops: {\n        bar: vm.mergedOptions.bar,\n        rail: vm.mergedOptions.rail\n      },\n      state: vm.bar[barType].state\n    },\n    on: {\n      setBarDrag: vm.setBarDrag\n    },\n    ref: `${type}Bar`\n  };\n\n  return <bar {...barData} />;\n}\n","// begin importing\nimport {\n  getGutter,\n  isSupportGivenStyle,\n  isIE,\n  insertChildrenIntoSlot,\n  getRealParent\n} from '../../util';\nimport { createContent } from './vuescroll-content';\n\nexport default {\n  name: 'scrollPanel',\n  props: { ops: { type: Object, required: true } },\n  methods: {\n    // trigger scrollPanel options initialScrollX,\n    // initialScrollY\n    updateInitialScroll() {\n      let x = 0;\n      let y = 0;\n\n      const parent = getRealParent(this);\n\n      if (this.ops.initialScrollX) {\n        x = this.ops.initialScrollX;\n      }\n      if (this.ops.initialScrollY) {\n        y = this.ops.initialScrollY;\n      }\n      if (x || y) {\n        parent.scrollTo({ x, y });\n      }\n    }\n  },\n  mounted() {\n    setTimeout(() => {\n      if (!this._isDestroyed) {\n        this.updateInitialScroll();\n      }\n    }, 0);\n  },\n  render(h) {\n    // eslint-disable-line\n    let data = {\n      class: ['__panel']\n    };\n\n    const parent = getRealParent(this);\n\n    const _customPanel = parent.$slots['scroll-panel'];\n    if (_customPanel) {\n      return insertChildrenIntoSlot(h, _customPanel, this.$slots.default, data);\n    }\n\n    return <div {...data}>{[this.$slots.default]}</div>;\n  }\n};\n\n/**\n * create a scrollPanel\n *\n * @param {any} size\n * @param {any} vm\n * @returns\n */\nexport function createPanel(h, vm) {\n  // scrollPanel data start\n  const scrollPanelData = {\n    ref: 'scrollPanel',\n    style: {},\n    class: [],\n    nativeOn: {\n      scroll: vm.handleScroll\n    },\n    props: {\n      ops: vm.mergedOptions.scrollPanel\n    }\n  };\n  // set overflow only if the in native mode\n  if (vm.mode == 'native') {\n    scrollPanelData.class.push('__native');\n    // dynamic set overflow scroll\n    // feat: #11\n    if (vm.mergedOptions.scrollPanel.scrollingY) {\n      scrollPanelData.style['overflowY'] = vm.bar.vBar.state.size\n        ? 'scroll'\n        : '';\n    } else {\n      scrollPanelData.style['overflowY'] = 'hidden';\n    }\n\n    if (vm.mergedOptions.scrollPanel.scrollingX) {\n      scrollPanelData.style['overflowX'] = vm.bar.hBar.state.size\n        ? 'scroll'\n        : '';\n    } else {\n      scrollPanelData.style['overflowX'] = 'hidden';\n    }\n\n    let gutter = getGutter();\n    /* istanbul ignore if */\n    if (!gutter) {\n      scrollPanelData.class.push('__hidebar');\n    } else {\n      // hide system bar by use a negative value px\n      // gutter should be 0 when manually disable scrollingX #14\n      if (vm.bar.vBar.state.size && vm.mergedOptions.scrollPanel.scrollingY) {\n        scrollPanelData.style.marginRight = `-${gutter}px`;\n      }\n      if (vm.bar.hBar.state.size && vm.mergedOptions.scrollPanel.scrollingX) {\n        scrollPanelData.style.height = `calc(100% + ${gutter}px)`;\n      }\n    }\n\n    // clear legency styles of slide mode...\n    scrollPanelData.style.transformOrigin = '';\n    scrollPanelData.style.transform = '';\n  } else if (vm.mode == 'slide') {\n    scrollPanelData.class.push('__slide');\n\n    let width = isSupportGivenStyle('width', 'fit-content');\n    if (width) {\n      scrollPanelData.style['width'] = width;\n    } /* istanbul ignore next */ else {\n      /* \n       * Fallback to inline-block while browser doesn't support fit-content\n       */\n      scrollPanelData['display'] = 'inline-block';\n    }\n  }\n\n  return (\n    <scrollPanel {...scrollPanelData}>{createPanelChildren(vm, h)}</scrollPanel>\n  );\n}\n\nfunction createPanelChildren(vm, h) {\n  if (vm.mode == 'native') {\n    return [createContent(h, vm)];\n  } else if (vm.mode == 'slide') {\n    let renderChildren = [vm.$slots.default];\n\n    /**\n     *  Keep the children-rendered-order in case of the style crash\n     *  when push-load or pull-refresh is enable\n     */\n    let _customPanel = vm.$slots['scroll-panel'];\n    if (_customPanel) {\n      /* istanbul ignore if */\n      if (_customPanel.length > 1) {\n        renderChildren = _customPanel.concat(renderChildren);\n      } else {\n        _customPanel = _customPanel[0];\n        const ch = _customPanel.children;\n\n        if (Array.isArray(ch)) {\n          renderChildren = ch.concat(renderChildren);\n        }\n      }\n    }\n\n    // handle refresh\n    if (vm.mergedOptions.vuescroll.pullRefresh.enable) {\n      let refreshDom = createTipDom(h, vm, 'refresh');\n      renderChildren.unshift(\n        <div class=\"__refresh\" ref=\"refreshDom\" key=\"refshDom\">\n          {[refreshDom, vm.pullRefreshTip]}\n        </div>\n      );\n    }\n\n    // handle load\n    if (vm.mergedOptions.vuescroll.pushLoad.enable) {\n      let loadDom = createTipDom(h, vm, 'load');\n      const enableLoad = vm.isEnableLoad();\n\n      renderChildren.push(\n        <div\n          ref=\"loadDom\"\n          key=\"loadDom\"\n          class={{ __load: true, '__load-disabled': !enableLoad }}\n        >\n          {[loadDom, vm.pushLoadTip]}\n        </div>\n      );\n    }\n\n    return renderChildren;\n  }\n}\n\n// Create load or refresh tip dom of each stages\n\nfunction createTipDom(h, vm, type) {\n  const stage = vm.vuescroll.state[`${type}Stage`];\n  let dom = null;\n  /* istanbul ignore if */\n  if ((dom = vm.$slots[`${type}-${stage}`])) {\n    return dom[0];\n  }\n  switch (stage) {\n  case 'deactive':\n    dom = (\n      <svg\n        version=\"1.1\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n        x=\"0px\"\n        y=\"0px\"\n        viewBox=\"0 0 1000 1000\"\n        enable-background=\"new 0 0 1000 1000\"\n        xmlSpace=\"preserve\"\n      >\n        <metadata> Svg Vector Icons : http://www.sfont.cn </metadata>\n        <g>\n          <g transform=\"matrix(1 0 0 -1 0 1008)\">\n            <path d=\"M10,543l490,455l490-455L885,438L570,735.5V18H430v717.5L115,438L10,543z\" />\n          </g>\n        </g>\n      </svg>\n    );\n    break;\n  case 'start':\n    // IE and edge seem not supporting  tag - `animateTransform`\n    // Just return null.\n    /* istanbul ignore if */\n    if (isIE()) {\n      dom = null;\n      break;\n    }\n    dom = (\n      <svg\n        version=\"1.1\"\n        id=\"loader-1\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n        x=\"0px\"\n        y=\"0px\"\n        viewBox=\"0 0 50 50\"\n        style=\"enable-background:new 0 0 50 50;\"\n        xmlSpace=\"preserve\"\n      >\n        <path\n          fill=\"#000\"\n          d=\"M43.935,25.145c0-10.318-8.364-18.683-18.683-18.683c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615c8.072,0,14.615,6.543,14.615,14.615H43.935z\"\n        >\n          <animateTransform\n            attributeType=\"xml\"\n            attributeName=\"transform\"\n            type=\"rotate\"\n            from=\"0 25 25\"\n            to=\"360 25 25\"\n            dur=\"0.6s\"\n            repeatCount=\"indefinite\"\n          />\n        </path>\n      </svg>\n    );\n    break;\n  case 'active':\n    dom = (\n      <svg\n        version=\"1.1\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n        x=\"0px\"\n        y=\"0px\"\n        viewBox=\"0 0 1000 1000\"\n        enable-background=\"new 0 0 1000 1000\"\n        xmlSpace=\"preserve\"\n      >\n        <metadata> Svg Vector Icons : http://www.sfont.cn </metadata>\n        <g>\n          <g transform=\"matrix(1 0 0 -1 0 1008)\">\n            <path d=\"M500,18L10,473l105,105l315-297.5V998h140V280.5L885,578l105-105L500,18z\" />\n          </g>\n        </g>\n      </svg>\n    );\n    break;\n  }\n  return dom;\n}\n","// detect content size change\nimport { eventCenter, isIE } from '../../util';\nexport function installResizeDetection(element, callback) {\n  return injectObject(element, callback);\n}\n\nfunction injectObject(element, callback) {\n  if (element.hasResized) {\n    return;\n  }\n\n  var OBJECT_STYLE =\n    'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; padding: 0; margin: 0; opacity: 0; z-index: -1000; pointer-events: none;';\n  // define a wrap due to ie's zIndex bug\n  var objWrap = document.createElement('div');\n  objWrap.style.cssText = OBJECT_STYLE;\n  var object = document.createElement('object');\n  object.style.cssText = OBJECT_STYLE;\n  object.type = 'text/html';\n  object.tabIndex = -1;\n  object.onload = () => {\n    eventCenter(object.contentDocument.defaultView, 'resize', callback);\n  };\n  // https://github.com/wnr/element-resize-detector/blob/aafe9f7ea11d1eebdab722c7c5b86634e734b9b8/src/detection-strategy/object.js#L159\n  if (!isIE()) {\n    object.data = 'about:blank';\n  }\n  objWrap.isResizeElm = true;\n  objWrap.appendChild(object);\n  element.appendChild(objWrap);\n  if (isIE()) {\n    object.data = 'about:blank';\n  }\n  return function destroy() {\n    if (object.contentDocument) {\n      eventCenter(\n        object.contentDocument.defaultView,\n        'resize',\n        callback,\n        'off'\n      );\n    }\n    element.removeChild(objWrap);\n    element.hasResized = false;\n  };\n}\n","import nativeMode from './mixins/native-mode';\nimport slideMode from './mixins/slide-mode';\n\nimport hackLifecycle from './mixins/hack-lifecycle';\n\nimport api from './mixins/api';\n\nimport bar, { createBar } from './children/vuescroll-bar';\nimport scrollContent from './children/vuescroll-content';\nimport scrollPanel, { createPanel } from './children/vuescroll-panel';\n\nimport {\n  isSupportTouch,\n  insertChildrenIntoSlot,\n  isChildInParent\n} from '../util';\n\nimport { smallChangeArray } from '../shared/constants';\n\nimport { installResizeDetection } from '../third-party/resize-detector';\n\n/**\n * Resolve coordinate by mode\n * @param {*} mode\n * @param {*} vm\n */\nfunction resolveOffset(mode, vm) {\n  let axis = {};\n  switch (mode) {\n  case 'native':\n    axis = {\n      x: vm.scrollPanelElm.scrollLeft,\n      y: vm.scrollPanelElm.scrollTop\n    };\n    break;\n  case 'slide':\n    axis = { x: vm.scroller.__scrollLeft, y: vm.scroller.__scrollTop };\n    break;\n  }\n  return axis;\n}\n\nexport default {\n  name: 'vueScroll',\n  components: { bar, scrollContent, scrollPanel },\n  props: {\n    ops: { type: Object }\n  },\n  mixins: [\n    /** Hack lifecycle to merge options*/\n    hackLifecycle,\n    api,\n    nativeMode,\n    slideMode\n  ],\n  data() {\n    return {\n      vuescroll: {\n        state: {\n          isDragging: false,\n          pointerLeave: true,\n          /** Internal states to record current positions */\n          internalScrollTop: 0,\n          internalScrollLeft: 0,\n          /** Current scrolling directions */\n          posX: null,\n          posY: null,\n          /** Default tips of refresh and load */\n          refreshStage: 'deactive',\n          loadStage: 'deactive',\n          /** Default sizeStrategies */\n          height: '100%',\n          width: '100%',\n          /** How many times you have scrolled */\n          scrollingTimes: 0\n        },\n        updatedCbs: []\n      },\n\n      bar: {\n        vBar: {\n          state: {\n            posValue: 0,\n            size: 0,\n            opacity: 0\n          }\n        },\n        hBar: {\n          state: {\n            posValue: 0,\n            size: 0,\n            opacity: 0\n          }\n        }\n      },\n\n      renderError: false\n    };\n  },\n\n  mounted() {\n    if (!this.renderError) {\n      this.initVariables();\n      this.initWatchOpsChange();\n      this.refreshInternalStatus();\n\n      this.$nextTick(() => {\n        if (!this._isDestroyed) {\n          // update again to ensure bar's size is correct.\n          this.updateBarStateAndEmitEvent();\n          // update scroller again since we get real dom.\n          if (this.mode == 'slide') {\n            this.updateScroller();\n          }\n          this.scrollToAnchor();\n        }\n      });\n    }\n  },\n  updated() {\n    this.vuescroll.updatedCbs.forEach(cb => {\n      cb.call(this);\n    });\n    // Clear\n    this.vuescroll.updatedCbs = [];\n  },\n  beforeDestroy() {\n    // remove registryed resize event\n    if (this.destroyParentDomResize) {\n      this.destroyParentDomResize();\n      this.destroyParentDomResize = null;\n    }\n    if (this.destroyResize) {\n      this.destroyResize();\n      this.destroyResize = null;\n    }\n  },\n\n  render(h) {\n    let vm = this;\n    if (vm.renderError) {\n      return <div>{[vm.$slots['default']]}</div>;\n    }\n    // vuescroll data\n    const vuescrollData = {\n      style: {\n        height: vm.vuescroll.state.height,\n        width: vm.vuescroll.state.width,\n        padding: 0\n      },\n      class: '__vuescroll'\n    };\n\n    if (!isSupportTouch()) {\n      vuescrollData.on = {\n        mouseenter() {\n          vm.vuescroll.state.pointerLeave = false;\n          vm.updateBarStateAndEmitEvent();\n        },\n        mouseleave() {\n          vm.vuescroll.state.pointerLeave = true;\n          vm.hideBar();\n        },\n        mousemove() /* istanbul ignore next */ {\n          vm.vuescroll.state.pointerLeave = false;\n          vm.updateBarStateAndEmitEvent();\n        }\n      };\n    } /* istanbul ignore next */ else {\n      vuescrollData.on = {\n        touchstart() {\n          vm.vuescroll.state.pointerLeave = false;\n          vm.updateBarStateAndEmitEvent();\n        },\n        touchend() {\n          vm.vuescroll.state.pointerLeave = true;\n          vm.hideBar();\n        },\n        touchmove() /* istanbul ignore next */ {\n          vm.vuescroll.state.pointerLeave = false;\n          vm.updateBarStateAndEmitEvent();\n        }\n      };\n    }\n\n    const _customContainer = this.$slots['scroll-container'];\n\n    const ch = [\n      createPanel(h, vm),\n      createBar(h, vm, 'vertical'),\n      createBar(h, vm, 'horizontal')\n    ];\n\n    if (_customContainer) {\n      return insertChildrenIntoSlot(h, _customContainer, ch, vuescrollData);\n    }\n\n    return <div {...vuescrollData}>{ch}</div>;\n  },\n\n  /** ------------------------------- Computed ----------------------------- */\n  computed: {\n    scrollPanelElm() {\n      return this.$refs['scrollPanel']._isVue\n        ? this.$refs['scrollPanel'].$el\n        : this.$refs['scrollPanel'];\n    },\n    scrollContentElm() {\n      return this.$refs['scrollContent']._isVue\n        ? this.$refs['scrollContent'].$el\n        : this.$refs['scrollContent'];\n    },\n    mode() {\n      return this.mergedOptions.vuescroll.mode;\n    },\n    pullRefreshTip() {\n      return this.mergedOptions.vuescroll.pullRefresh.tips[\n        this.vuescroll.state.refreshStage\n      ];\n    },\n    pushLoadTip() {\n      return this.mergedOptions.vuescroll.pushLoad.tips[\n        this.vuescroll.state.loadStage\n      ];\n    },\n    refreshLoad() {\n      return (\n        this.mergedOptions.vuescroll.pullRefresh.enable ||\n        this.mergedOptions.vuescroll.pushLoad.enable\n      );\n    }\n  },\n\n  /** ------------------------------- Methods -------------------------------- */\n  methods: {\n    updateBarStateAndEmitEvent(eventType, nativeEvent = null) {\n      if (this.mode == 'native') {\n        this.updateNativeModeBarState();\n      } else if (this.mode == 'slide') {\n        if (!this.scroller) {\n          return;\n        }\n\n        this.updateSlideModeBarState();\n      }\n      if (eventType) {\n        this.emitEvent(eventType, nativeEvent);\n      }\n      if (this.mergedOptions.bar.onlyShowBarOnScroll) {\n        if (\n          eventType == 'handle-scroll' ||\n          eventType == 'handle-resize' ||\n          eventType == 'refresh-status' ||\n          eventType == 'window-resize' ||\n          eventType == 'options-change'\n        ) {\n          this.showAndDefferedHideBar(true /* forceHideBar: true */);\n        }\n      } else {\n        this.showAndDefferedHideBar();\n      }\n    },\n    emitEvent(eventType, nativeEvent = null) {\n      let {\n        scrollHeight,\n        scrollWidth,\n        clientHeight,\n        clientWidth,\n        scrollTop,\n        scrollLeft\n      } = this.scrollPanelElm;\n\n      const vertical = {\n        type: 'vertical'\n      };\n      const horizontal = {\n        type: 'horizontal'\n      };\n\n      if (this.mode == 'slide') {\n        scrollHeight = this.scroller.__contentHeight;\n        scrollWidth = this.scroller.__contentWidth;\n        scrollTop = this.scroller.__scrollTop;\n        scrollLeft = this.scroller.__scrollLeft;\n        clientHeight = this.$el.clientHeight;\n        clientWidth = this.$el.clientWidth;\n      }\n\n      vertical['process'] = Math.min(\n        scrollTop / (scrollHeight - clientHeight),\n        1\n      );\n      horizontal['process'] = Math.min(\n        scrollLeft / (scrollWidth - clientWidth),\n        1\n      );\n\n      vertical['barSize'] = this.bar.vBar.state.size;\n      horizontal['barSize'] = this.bar.hBar.state.size;\n      vertical['scrollTop'] = scrollTop;\n      horizontal['scrollLeft'] = scrollLeft;\n      // Current scroll direction\n      vertical['directionY'] = this.vuescroll.state.posY;\n      horizontal['directionX'] = this.vuescroll.state.posX;\n\n      this.$emit(eventType, vertical, horizontal, nativeEvent);\n    },\n\n    /** ------------------------ Handlers --------------------------- */\n    handleScroll(nativeEvent) {\n      this.recordCurrentPos();\n      this.updateBarStateAndEmitEvent('handle-scroll', nativeEvent);\n    },\n    scrollingComplete() {\n      this.vuescroll.state.scrollingTimes++;\n      this.updateBarStateAndEmitEvent('handle-scroll-complete');\n    },\n    setBarDrag(val) {\n      /* istanbul ignore next */\n      this.vuescroll.state.isDragging = val;\n    },\n\n    /** ------------------------ Some Helpers --------------------------- */\n    /**\n     * We don't want it to be computed because computed\n     * will cache the result and we don't want to cache the result and always\n     * get the fresh.\n     */\n    isEnableLoad() {\n      // Enable load only when clientHeight <= scrollHeight\n      if (!this._isMounted) return false;\n      const panelElm = this.scrollPanelElm;\n      const containerElm = this.$el;\n\n      /* istanbul ignore if */\n      if (!this.mergedOptions.vuescroll.pushLoad.enable) {\n        return false;\n      }\n\n      let loadDom = null;\n      if (this.$refs['loadDom']) {\n        loadDom = this.$refs['loadDom'].elm || this.$refs['loadDom'];\n      }\n\n      const loadHeight = (loadDom && loadDom.offsetHeight) || 0;\n      /* istanbul ignore if */\n      if (panelElm.scrollHeight - loadHeight <= containerElm.clientHeight) {\n        return false;\n      }\n\n      return true;\n    },\n    /* \n     * To have a good ux, instead of hiding bar immediately, we hide bar\n     * after some seconds by using this simple debounce-hidebar method.\n     */\n    showAndDefferedHideBar(forceHideBar) {\n      this.showBar();\n\n      if (this.timeoutId) {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = 0;\n      }\n\n      this.timeoutId = setTimeout(() => {\n        this.timeoutId = 0;\n        this.hideBar(forceHideBar);\n      }, this.mergedOptions.bar.showDelay);\n    },\n    showBar() {\n      const opacity = this.mergedOptions.bar.opacity;\n      this.bar.vBar.state.opacity = opacity;\n      this.bar.hBar.state.opacity = opacity;\n    },\n    hideBar(forceHideBar) {\n      // when in non-native mode dragging content\n      // in slide mode, just return\n      /* istanbul ignore next */\n      if (this.vuescroll.state.isDragging) {\n        return;\n      }\n\n      if (forceHideBar && !this.mergedOptions.bar.keepShow) {\n        this.bar.hBar.state.opacity = 0;\n        this.bar.vBar.state.opacity = 0;\n      }\n\n      // add isDragging condition\n      // to prevent from hiding bar while dragging the bar\n      if (\n        !this.mergedOptions.bar.keepShow &&\n        !this.vuescroll.state.isDragging &&\n        this.vuescroll.state.pointerLeave\n      ) {\n        this.bar.vBar.state.opacity = 0;\n        this.bar.hBar.state.opacity = 0;\n      }\n    },\n    recordCurrentPos() {\n      let mode = this.mode;\n      if (this.mode !== this.lastMode) {\n        mode = this.lastMode;\n        this.lastMode = this.mode;\n      }\n\n      const state = this.vuescroll.state;\n      let axis = resolveOffset(mode, this);\n      const oldX = state.internalScrollLeft;\n      const oldY = state.internalScrollTop;\n\n      state.posX =\n        oldX - axis.x > 0 ? 'right' : oldX - axis.x < 0 ? 'left' : null;\n      state.posY = oldY - axis.y > 0 ? 'up' : oldY - axis.y < 0 ? 'down' : null;\n\n      state.internalScrollLeft = axis.x;\n      state.internalScrollTop = axis.y;\n    },\n    useNumbericSize() {\n      const parentElm = this.$el.parentNode;\n      const { position } = parentElm.style;\n      if (!position || position == 'static') {\n        this.$el.parentNode.style.position = 'relative';\n      }\n\n      this.vuescroll.state.height = parentElm.offsetHeight + 'px';\n      this.vuescroll.state.width = parentElm.offsetWidth + 'px';\n    },\n    usePercentSize() {\n      this.vuescroll.state.height = '100%';\n      this.vuescroll.state.width = '100%';\n    },\n    // Set its size to be equal to its parentNode\n    setVsSize() {\n      if (this.mergedOptions.vuescroll.sizeStrategy == 'number') {\n        this.useNumbericSize();\n        this.registryParentResize();\n      } else if (this.mergedOptions.vuescroll.sizeStrategy == 'percent') {\n        if (this.destroyParentDomResize) {\n          this.destroyParentDomResize();\n          this.destroyParentDomResize = null;\n        }\n        this.usePercentSize();\n      }\n    },\n\n    /** ------------------------ Init --------------------------- */\n    initWatchOpsChange() {\n      const watchOpts = {\n        deep: true,\n        sync: true\n      };\n      this.$watch(\n        'mergedOptions',\n        () => {\n          // record current position\n          this.recordCurrentPos();\n          setTimeout(() => {\n            if (this.isSmallChangeThisTick == true) {\n              this.isSmallChangeThisTick = false;\n              this.updateBarStateAndEmitEvent('options-change');\n              return;\n            }\n            this.refreshInternalStatus();\n          }, 0);\n        },\n        watchOpts\n      );\n\n      /**\n       * We also watch `small` changes, and when small changes happen, we send\n       * a signal to vuescroll, to tell it:\n       * 1. we don't need to registry resize\n       * 2. we don't need to registry scroller.\n       */\n      smallChangeArray.forEach(opts => {\n        this.$watch(\n          opts,\n          () => {\n            this.isSmallChangeThisTick = true;\n          },\n          watchOpts\n        );\n      });\n    },\n    // scrollTo hash-anchor while mounted component have mounted.\n    scrollToAnchor() /* istanbul ignore next */ {\n      const validateHashSelector = function(hash) {\n        return /^#[a-zA-Z_]\\d*$/.test(hash);\n      };\n\n      let hash = window.location.hash;\n      if (\n        !hash ||\n        ((hash = hash.slice(hash.lastIndexOf('#'))) &&\n          !validateHashSelector(hash))\n      ) {\n        return;\n      }\n\n      const elm = document.querySelector(hash);\n      if (\n        !isChildInParent(elm, this.$el) ||\n        this.mergedOptions.scrollPanel.initialScrollY ||\n        this.mergedOptions.scrollPanel.initialScrollX\n      ) {\n        return;\n      }\n\n      this.scrollIntoView(elm);\n    },\n    initVariables() {\n      this.lastMode = this.mode;\n      this.$el._isVuescroll = true;\n      this.clearScrollingTimes();\n    },\n\n    /** ------------------------ Refresh When data changes --------------------------- */\n    refreshMode() {\n      const x = this.vuescroll.state.internalScrollLeft;\n      const y = this.vuescroll.state.internalScrollTop;\n      if (this.destroyScroller) {\n        this.scroller.stop();\n        this.destroyScroller();\n        this.destroyScroller = null;\n      }\n      if (this.mode == 'slide') {\n        this.destroyScroller = this.registryScroller();\n      } else if (this.mode == 'native') {\n        // remove the legacy transform style attribute\n        this.scrollPanelElm.style.transform = '';\n        this.scrollPanelElm.style.transformOrigin = '';\n      }\n      // keep the last-mode's position.\n      this.scrollTo({ x, y }, false, true /* force */);\n    },\n    refreshInternalStatus() {\n      // 1.set vuescroll height or width according to\n      // sizeStrategy\n      this.setVsSize();\n      // 2. registry resize event\n      this.registryResize();\n      // 3. registry scroller if mode is 'slide'\n      // or remove 'transform origin' is the mode is not `slide`\n      this.refreshMode();\n      // 4. update scrollbar's height/width\n      this.updateBarStateAndEmitEvent('refresh-status');\n    },\n\n    /** ------------------------ Registry Resize --------------------------- */\n    registryResize() {\n      /* istanbul ignore next */\n      if (this.destroyResize) {\n        // when toggling the mode\n        // we should clean the flag-object.\n        this.destroyResize();\n      }\n\n      let contentElm = null;\n      if (this.mode == 'slide') {\n        contentElm = this.scrollPanelElm;\n      } else if (this.mode == 'native') {\n        // scrollContent maybe a vue-component or a pure-dom\n        contentElm = this.scrollContentElm;\n      }\n\n      const handleWindowResize = function() /* istanbul ignore next */ {\n        this.updateBarStateAndEmitEvent('window-resize');\n        if (this.mode == 'slide') {\n          this.vuescroll.updatedCbs.push(this.updateScroller);\n          this.$forceUpdate();\n        }\n      };\n      const handleDomResize = () => {\n        let currentSize = {};\n        if (this.mode == 'slide') {\n          currentSize['width'] = this.scroller.__contentWidth;\n          currentSize['height'] = this.scroller.__contentHeight;\n          this.updateBarStateAndEmitEvent('handle-resize', currentSize);\n          // update scroller should after rendering\n          this.vuescroll.updatedCbs.push(this.updateScroller);\n          this.$forceUpdate();\n        } else if (this.mode == 'native') {\n          currentSize['width'] = this.scrollPanelElm.scrollWidth;\n          currentSize['height'] = this.scrollPanelElm.scrollHeight;\n          this.updateBarStateAndEmitEvent('handle-resize', currentSize);\n        }\n      };\n      window.addEventListener('resize', handleWindowResize.bind(this), false);\n\n      const resizeEnable = this.mergedOptions.vuescroll.detectResize;\n      const destroyDomResize = resizeEnable\n        ? installResizeDetection(contentElm, handleDomResize)\n        : () => {};\n\n      const destroyWindowResize = () => {\n        window.removeEventListener('resize', handleWindowResize, false);\n      };\n\n      this.destroyResize = () => {\n        destroyWindowResize();\n        destroyDomResize();\n      };\n    },\n    registryParentResize() {\n      const resizeEnable = this.mergedOptions.vuescroll.detectResize;\n      this.destroyParentDomResize = resizeEnable\n        ? installResizeDetection(this.$el.parentNode, this.useNumbericSize)\n        : () => {};\n    }\n  }\n};\n","import {\n  deepMerge,\n  isSupportGivenStyle,\n  insertChildrenIntoSlot\n} from '../../util';\n// ScrollContent, stateless, treat as a functional component\nexport default {\n  name: 'scrollContent',\n  functional: true,\n  props: {\n    ops: { type: Object },\n    state: {\n      type: Object,\n      default() {\n        return {};\n      }\n    }\n  },\n  render(h, { props, slots, parent }) {\n    let style = deepMerge(props.state.style, {});\n    let width = isSupportGivenStyle('width', 'fit-content');\n\n    if (width) {\n      style.width = width;\n    } /* istanbul ignore next */ else {\n      // fallback to inline block while\n      // doesn't support 'fit-content',\n      // this may cause some issues, but this\n      // can make `resize` event work...\n      style['display'] = 'inline-block';\n    }\n\n    if (props.ops.padding) {\n      style.paddingRight = props.ops.paddingValue;\n    }\n\n    const propsData = {\n      style: style,\n      ref: 'scrollContent',\n      class: '__view'\n    };\n\n    const _customContent = parent.$slots['scroll-content'];\n    if (_customContent) {\n      return insertChildrenIntoSlot(\n        h,\n        _customContent,\n        slots().default,\n        propsData\n      );\n    }\n\n    return <div {...propsData}>{slots().default}</div>;\n  }\n};\n\n/**\n * create scroll content\n *\n * @param {any} size\n * @param {any} vm\n * @returns\n */\nexport function createContent(h, vm) {\n  const scrollContentData = {\n    props: {\n      ops: vm.mergedOptions.scrollContent\n    }\n  };\n  return (\n    <scrollContent {...scrollContentData}>{[vm.$slots.default]}</scrollContent>\n  );\n}\n","import {getPrefix} from '../../util';\n\n/* DOM-based rendering (Uses 3D when available, falls back on margin when transform not available) */\nexport function render(content, global, suffix, value) {\n  var x = null;\n  var y = null;\n\n  if (typeof content == 'string') {\n    y = content == 'vertical' ? (x = 0) || value : (x = value) && 0;\n  }\n\n  var vendorPrefix = getPrefix(global);\n\n  var helperElem = document.createElement('div');\n  var undef;\n\n  var perspectiveProperty = vendorPrefix + 'Perspective';\n  var transformProperty = 'transform'; //vendorPrefix + 'Transform';\n\n  if (helperElem.style[perspectiveProperty] !== undef) {\n    if (typeof content == 'string') {\n      return {\n        [transformProperty]:\n          'translate3d(' + x + suffix + ',' + y + suffix + ',0)'\n      };\n    }\n    return function(left, top, zoom) {\n      content.style[transformProperty] =\n        'translate3d(' +\n        -left +\n        suffix +\n        ',' +\n        -top +\n        suffix +\n        ',0) scale(' +\n        zoom +\n        ')';\n    };\n  } else if (helperElem.style[transformProperty] !== undef) {\n    if (typeof content == 'string') {\n      return {\n        [transformProperty]: 'translate(' + x + suffix + ',' + y + suffix + ')'\n      };\n    }\n    return function(left, top, zoom) {\n      content.style[transformProperty] =\n        'translate(' +\n        -left +\n        suffix +\n        ',' +\n        -top +\n        suffix +\n        ') scale(' +\n        zoom +\n        ')';\n    };\n  }\n}\n","export function listenContainer(\n  container,\n  scroller,\n  eventCallback,\n  zooming,\n  preventDefault\n) {\n  let destroy = null;\n  // for touch\n  function touchstart(e) {\n    // Don't react if initial down happens on a form element\n    if (\n      e.touches[0] &&\n      e.touches[0].target &&\n      e.touches[0].target.tagName.match(/input|textarea|select/i)\n    ) {\n      return;\n    }\n    eventCallback('mousedown');\n    scroller.doTouchStart(e.touches, e.timeStamp);\n    if (preventDefault) {\n      e.preventDefault();\n    }\n    // here , we want to manully prevent default, so we\n    // set passive to false\n    // see https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener\n    document.addEventListener('touchmove', touchmove, { passive: false });\n  }\n  function touchmove(e) {\n    eventCallback('mousemove');\n    scroller.doTouchMove(e.touches, e.timeStamp, e.scale);\n    e.preventDefault();\n  }\n  function touchend(e) {\n    eventCallback('mouseup');\n    scroller.doTouchEnd(e.timeStamp);\n    document.removeEventListener('touchmove', touchmove);\n  }\n  function touchcancel(e) {\n    scroller.doTouchEnd(e.timeStamp);\n  }\n\n  // for mouse\n  function mousedownEvent(e) {\n    if (e.target.tagName.match(/input|textarea|select/i)) {\n      return;\n    }\n    eventCallback('mousedown');\n    scroller.doTouchStart(\n      [\n        {\n          pageX: e.pageX,\n          pageY: e.pageY\n        }\n      ],\n      e.timeStamp\n    );\n\n    if (preventDefault) {\n      e.preventDefault();\n    }\n\n    mousedown = true;\n  }\n  function mousemove(e) {\n    if (!mousedown) {\n      return;\n    }\n    eventCallback('mousemove');\n    scroller.doTouchMove(\n      [\n        {\n          pageX: e.pageX,\n          pageY: e.pageY\n        }\n      ],\n      e.timeStamp\n    );\n\n    mousedown = true;\n  }\n  function mouseup(e) {\n    if (!mousedown) {\n      return;\n    }\n    eventCallback('mouseup');\n    scroller.doTouchEnd(e.timeStamp);\n\n    mousedown = false;\n  }\n  function zoomHandle(e) {\n    scroller.doMouseZoom(\n      e.detail ? e.detail * -120 : e.wheelDelta,\n      e.timeStamp,\n      e.pageX,\n      e.pageY\n    );\n  }\n  if ('ontouchstart' in window) {\n    container.addEventListener('touchstart', touchstart, false);\n\n    document.addEventListener('touchend', touchend, false);\n\n    document.addEventListener('touchcancel', touchcancel, false);\n\n    destroy = function() {\n      container.removeEventListener('touchstart', touchstart, false);\n\n      document.removeEventListener('touchend', touchend, false);\n\n      document.removeEventListener('touchcancel', touchcancel, false);\n    };\n  } else {\n    var mousedown = false;\n\n    container.addEventListener('mousedown', mousedownEvent, false);\n\n    document.addEventListener('mousemove', mousemove, false);\n\n    document.addEventListener('mouseup', mouseup, false);\n    if (zooming) {\n      container.addEventListener(\n        navigator.userAgent.indexOf('Firefox') > -1\n          ? 'DOMMouseScroll'\n          : 'mousewheel',\n        zoomHandle,\n        false\n      );\n    }\n    // container.addEventListener(navigator.userAgent.indexOf(\"Firefox\") > -1 ? \"DOMMouseScroll\" :  \"mousewheel\", function(e) {\n    //     scroller.doMouseZoom(e.detail ? (e.detail * -120) : e.wheelDelta, e.timeStamp, e.pageX, e.pageY);\n    // }, false);\n    destroy = function() {\n      container.removeEventListener('mousedown', mousedownEvent, false);\n      document.removeEventListener('mousemove', mousemove, false);\n      document.removeEventListener('mouseup', mouseup, false);\n      container.removeEventListener(\n        navigator.userAgent.indexOf('Firefox') > -1\n          ? 'DOMMouseScroll'\n          : 'mousewheel',\n        zoomHandle,\n        false\n      );\n    };\n  }\n  // handle __publish event\n  scroller.onScroll = () => {\n    eventCallback('onscroll');\n  };\n  return destroy;\n}\n","import Vue from 'vue';\nimport vuescroll from './core/vuescroll';\nimport GCF from './shared/global-config';\n\nimport { deepMerge } from './util';\nimport { refreshAll } from './core/mixins/api';\n\nimport './style/vuescroll.scss';\n\nconst Vuescroll = {\n  install(Vue) {\n    // registry vuescroll\n    Vue.component(vuescroll.name, vuescroll);\n    Vue.prototype.$vuescrollConfig = deepMerge(GCF, {});\n  },\n  version: '__version__',\n  refreshAll\n};\n\n/* istanbul ignore if */\nif (typeof window !== 'undefined' && window.Vue) {\n  Vue.use(Vuescroll);\n}\n\nexport default Vuescroll;\n"],"names":["isServer","Vue","prototype","$isServer","deepCopy","source","target","key","babelHelpers.typeof","deepMerge","from","to","force","defineReactive","souceKey","getter","defineProperty","scrollBarWidth","eventCenter","dom","eventName","hander","capture","addEventListener","removeEventListener","error","msg","warn","isChildInParent","child","parent","flag","parentNode","nodeType","_isVuescroll","pxValueReg","extractNumberFromPx","value","_return","exec","isSupportTouch","window","getPrefix","global","engine","docStyle","document","documentElement","style","opera","Object","toString","call","navigator","cpuClass","isSupportGivenStyle","property","compatibleValue","testElm","createElement","isIE","agent","userAgent","toLowerCase","indexOf","insertChildrenIntoSlot","h","parentVnode","childVNode","data","isComponent","componentOptions","tag","_data","nativeOn","on","props","propsData","getRealParent","ctx","$parent","_isVuescrollRoot","scrollPanel","this","scrollPanelElm","vuescroll","$el","isPercent","mergedOptions","sizeStrategy","clientWidth","state","width","clientHeight","height","heightPercentage","scrollHeight","widthPercentage","scrollWidth","bar","vBar","posValue","scrollTop","hBar","scrollLeft","size","createEasingFunction","easing","easingPattern","time","pattern","Date","now","running","counter","core","effect","Animate","requestFrame","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","isNative","test","callback","root","requests","rafHandle","intervalHandle","lastActive","callbackHandle","setInterval","currentRequests","hasOwnProperty","id","cleared","stepCallback","verifyCallback","completedCallback","duration","easingMethod","start","lastFrame","percent","dropCounter","body","newRunning","usedId","step","virtual","render","droppedFrames","Math","round","j","min","modes","NOOP","smallChangeArray","animatingMethod","noAnimatingMethod","Scroller","options","__callback","animatingEasing","noAnimatingEasing","members","contentWidth","contentHeight","animate","noScroll","self","__clientWidth","__clientHeight","__contentWidth","__contentHeight","__computeScrollMax","scrollTo","__scrollLeft","__scrollTop","left","top","__clientLeft","__clientTop","__snapWidth","__snapHeight","activateCallback","deactivateCallback","startCallback","beforeDeactivateCallback","__refreshHeight","__refreshActivate","__refreshBeforeDeactivate","__refreshDeactivate","__refreshStart","__loadHeight","__loadActivate","__loadBeforeDeactivate","__loadDeactivate","__loadStart","type","wasDecelerating","__isDecelerating","stop","__publish","__zoomLevel","__refreshActive","__maxScrollTop","__loadActive","__maxScrollLeft","level","originLeft","originTop","zooming","Error","__zoomComplete","oldLevel","max","maxZoom","minZoom","factor","zoomTo","zoom","scrollingX","paging","snapping","scrollingY","__isTracking","startLeft","__isAnimating","__scheduledLeft","startTop","__scheduledTop","__computePage","__currentPageX","__currentPageY","x","y","isNaN","wheelDelta","timeStamp","pageX","pageY","change","touches","length","valueOf","currentTouchLeft","currentTouchTop","__interruptedAnimation","isSingleTouch","abs","__initialTouchLeft","__initialTouchTop","__zoomLevelStart","__lastTouchLeft","__lastTouchTop","__lastTouchMove","__lastScale","__enableScrollX","__enableScrollY","__didDecelerationComplete","__isDragging","__isSingleTouch","__positions","scale","positions","moveX","moveY","currentTouchLeftRel","currentTouchTopRel","speedMultiplier","maxScrollLeft","bouncing","maxScrollTop","splice","push","minimumTrackingForScroll","locking","distanceX","distanceY","animating","endPos","startPos","i","timeOffset","movedLeft","movedTop","__decelerationVelocityX","__decelerationVelocityY","minVelocityToStartDeceleration","__startDeceleration","__scrollComplete","__disable","wasAnimating","__scheduledZoom","oldLeft","oldTop","oldZoom","diffLeft","diffTop","diffZoom","onScroll","renderedFramesPerSecond","animationId","wasFinished","animationDuration","zoomLevel","__totalXPage","ceil","__totalYPage","scrollingComplete","__minDecelerationScrollLeft","floor","__minDecelerationScrollTop","__maxDecelerationScrollLeft","__maxDecelerationScrollTop","minVelocityToKeepDecelerating","__stepThroughDeceleration","shouldContinue","scrollLeftFixed","scrollTopFixed","scrollOutsideX","scrollOutsideY","penetrationDeceleration","penetrationAcceleration","vm","$options","name","_gfc","$vuescrollConfig","ops","GCF","keys","forEach","scrollContent","rail","renderError","shouldStopRender","vRail","hRail","mode","enable","pullRefresh","pushLoad","initialScrollY","initialScrollX","String","match","vsInstances","getNumericValue","distance","number","colorCache","rgbReg","extractRgbColor","createBar","axis","scrollMap","barType","charAt","refreshLoad","setBarDrag","createTipDom","stage","$slots","transform","d","installResizeDetection","element","hasResized","OBJECT_STYLE","objWrap","cssText","object","tabIndex","onload","contentDocument","defaultView","isResizeElm","appendChild","removeChild","background","opacity","originBarStyle","hoverBarStyle","hoverStyle","mouseenter","$refs","thumb","mouseleave","touchstart","touchmove","e","axisStartPos","client","getBoundingClientRect","posName","offset","scrollSize","touchend","$emit","hideBar","onselectstart","stopImmediatePropagation","preventDefault","mousedown","mousemove","mouseup","railBackgroundColor","color","div","computedColor","getComputedStyle","backgroundColor","opsSize","barOffset","currentTarget","slots","display","padding","paddingRight","paddingValue","_customContent","default","required","_this","_isDestroyed","updateInitialScroll","_customPanel","_uid","internalScrollLeft","internalScrollTop","internalScrollTo","dx","dy","scroller","zoomBy","getCurrentPage","dest","goToPage","isRefresh","isLoad","triggerRefreshOrLoad","parentLeft","parentTop","parentHeight","parentWidth","children","scrollContentElm","domFragment","item","destX","destY","bind","elm","deltaX","deltaY","speed","startLocationY","startLocationX","positionX","positionY","percentage","parentElm","querySelector","diffX","diffY","scrollBy","refreshInternalStatus","scrollingTimes","nativeMode","updateDimesion","registryRefreshLoad","refreshHeight","refreshDom","offsetHeight","marginTop","isEnableLoad","loadDom","setDimensions","registryEvent","content","suffix","vendorPrefix","helperElem","perspectiveProperty","transformProperty","setSnapSize","rect","setPosition","clientLeft","clientTop","cb","container","eventCallback","destroy","tagName","doTouchStart","passive","doTouchMove","doTouchEnd","touchcancel","mousedownEvent","zoomHandle","doMouseZoom","detail","eventType","isDragging","handleScroll","updateScroller","outerLeft","outerTop","stageName","tipDom","listeners","domName","activateFunc","activatePullToRefresh","activatePushToLoad","cbs","finishRefreshOrLoad","$listeners","done","initVariables","initWatchOpsChange","$nextTick","updateBarStateAndEmitEvent","scrollToAnchor","updatedCbs","_this2","destroyParentDomResize","destroyResize","vuescrollData","pointerLeave","_customContainer","ch","scrollPanelData","class","overflowY","overflowX","gutter","outer","visibility","position","widthNoScroll","offsetWidth","overflow","inner","widthWithScroll","marginRight","transformOrigin","renderChildren","concat","Array","isArray","unshift","ref","pullRefreshTip","enableLoad","__load","__load-disabled","pushLoadTip","_isVue","tips","refreshStage","loadStage","nativeEvent","updateNativeModeBarState","updateSlideModeBarState","emitEvent","onlyShowBarOnScroll","showAndDefferedHideBar","vertical","horizontal","process","barSize","directionY","posY","directionX","posX","recordCurrentPos","val","_isMounted","panelElm","containerElm","loadHeight","forceHideBar","showBar","timeoutId","setTimeout","showDelay","keepShow","lastMode","oldX","oldY","useNumbericSize","registryParentResize","usePercentSize","watchOpts","$watch","_this4","isSmallChangeThisTick","opts","hash","location","slice","lastIndexOf","scrollIntoView","clearScrollingTimes","destroyScroller","registryScroller","setVsSize","registryResize","refreshMode","contentElm","handleWindowResize","$forceUpdate","destroyDomResize","detectResize","currentSize","_this5","resizeEnable","Vuescroll","component","vs","refresh","use"],"mappings":"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"}